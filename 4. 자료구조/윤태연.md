# 자료구조의 큰 그림

자료구조는 **데이터를 어떠한 구조**로 다룰지에 대해 학습하는 과목.
알고리즘과 깊은 연관성을 가지며, 시간 복잡도와 공간 복잡도를 통해 자료구조와 알고리즘의 효율성 판단 가능함.

## 자료구조와 알고리즘

- **자료구조**: 데이터를 효율적으로 저장하고 관리하기 위한 방법
- **알고리즘**: 어떠한 목적을 이루기 위한 효율적인 연산 절차

둘 사이의 연관성이 존재함.

- 사용하는 자료구조에 따라 적용 가능한 알고리즘 달라짐
- 너비 우선 탐색, 깊이 우선 탐색 등의 알고리즘은 그래프, 스택 등의 자료구조 이해 필요

## 시간 복잡도와 공간 복잡도

### 시간 복잡도

> [!NOTE]
> 입력의 크기에 따른 프로그램 실행 시간의 관계<br>
> 실행 시간은 연산 횟수에 비례한다고 간주

```python
# n번의 연산 필요
for _ in range(n):
    1 + 1  # 한 번의 연산

# 2n번의 연산 필요
for _ in range(2 * n):
    1 + 1

# n²번의 연산 필요
for _ in range(n):
    for _ in range(n):
        1 + 1

# (n² + 3n + 2)번의 연산 필요
for _ in range(n):
    for _ in range(n):
        1 + 1  # n²번
for _ in range(3 * n):
    1 + 1  # 3n번
1 + 1  # 1번
1 + 1  # 1번
```

> [!TIP]
> 프로그램의 시간 복잡도에 가장 많은 영향을 끼치는 문법은 반복문이 제일 큼!

### 빅 오 표기법

> [!NOTE]
> 함수의 **점근적 상한을 표기**하는 방법, 입력값이 무한대로 커질 때 **실행 시간의 상한**을 표현

빅 오 표기법 특징은 아래와 같다.

- 최고차항의 차수만 고려
- 계수와 낮은 차수의 항 무시
- 입력값 n이 증가할수록 영향력 커짐

#### 주요 시간 복잡도 (성능 좋은 순)

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c3287b1f-5c7c-4b34-a708-44118234e5f6" />

1. O(1) - 상수 시간
2. O(log n) - 로그 시간
3. O(n) - 선형 시간
4. O(n log n)
5. O(n²) - 제곱 시간
6. O(2ⁿ) - 지수 시간
7. O(n!) - 팩토리얼 시간

> [!TIP]
> 빅 오 표기법 외에도 빅 세타 표기법(평균적 실행 시간)과 빅 오메가 표기법(점근적 하한)이 있지만, 코드 성능 판단에는 주로 빅 오 표기법 사용함<br> <img width="600" alt="image" src="https://github.com/user-attachments/assets/45a2134b-3917-48c1-a2e9-883e7d49d325" />

### 공간 복잡도

> [!NOTE]
> 프로그램 실행 시 필요한 **메모리 자원**의 양<br>
> 입력에 따른 메모리 사용량의 척도

- 실행 과정에 많은 메모리가 필요한 경우 공간 복잡도가 큼
- 적은 메모리가 필요한 경우 공간 복잡도가 작음
- 시간 복잡도와 마찬가지로 빅 오 표기법으로 표현

> [!TIP]
> 오늘날 알고리즘 성능 판단은 주로 공간 복잡도보다 시간 복잡도를 기준임<br>
> 따라서 특별한 언급이 없으면 빅 오 표기법은 시간 복잡도를 의미

## 예시: 정렬 알고리즘의 시간 복잡도

| 정렬 알고리즘 | 시간 복잡도 |
| ------------- | ----------- |
| 삽입 정렬     | O(n²)       |
| 선택 정렬     | O(n²)       |
| 버블 정렬     | O(n²)       |
| 병합 정렬     | O(n log n)  |
| 퀵 정렬       | O(n log n)  |
| 힙 정렬       | O(n log n)  |

> [!TIP]
> 자료구조를 통한 다양한 연산(접근, 검색, 삽입, 삭제)의 성능도 빅 오 표기법으로 표현 가능
