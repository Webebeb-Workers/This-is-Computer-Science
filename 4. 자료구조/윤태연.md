# 자료구조의 큰 그림

자료구조는 **데이터를 어떠한 구조**로 다룰지에 대해 학습하는 과목.
알고리즘과 깊은 연관성을 가지며, 시간 복잡도와 공간 복잡도를 통해 자료구조와 알고리즘의 효율성 판단 가능함.

## 자료구조와 알고리즘

- **자료구조**: 데이터를 효율적으로 저장하고 관리하기 위한 방법
- **알고리즘**: 어떠한 목적을 이루기 위한 효율적인 연산 절차

둘 사이의 연관성이 존재함.

- 사용하는 자료구조에 따라 적용 가능한 알고리즘 달라짐
- 너비 우선 탐색, 깊이 우선 탐색 등의 알고리즘은 그래프, 스택 등의 자료구조 이해 필요

## 시간 복잡도와 공간 복잡도

### 시간 복잡도

> [!NOTE]
> 입력의 크기에 따른 프로그램 실행 시간의 관계 <br />
> 실행 시간은 연산 횟수에 비례한다고 간주

```python
# n번의 연산 필요
for _ in range(n):
    1 + 1  # 한 번의 연산

# 2n번의 연산 필요
for _ in range(2 * n):
    1 + 1

# n²번의 연산 필요
for _ in range(n):
    for _ in range(n):
        1 + 1

# (n² + 3n + 2)번의 연산 필요
for _ in range(n):
    for _ in range(n):
        1 + 1  # n²번
for _ in range(3 * n):
    1 + 1  # 3n번
1 + 1  # 1번
1 + 1  # 1번
```

> [!TIP]
> 프로그램의 시간 복잡도에 가장 많은 영향을 끼치는 문법은 반복문이 제일 큼!

### 빅 오 표기법

> [!NOTE]
> 함수의 **점근적 상한을 표기**하는 방법, 입력값이 무한대로 커질 때 **실행 시간의 상한**을 표현

빅 오 표기법 특징은 아래와 같다.

- 최고차항의 차수만 고려
- 계수와 낮은 차수의 항 무시
- 입력값 n이 증가할수록 영향력 커짐

#### 주요 시간 복잡도 (성능 좋은 순)

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c3287b1f-5c7c-4b34-a708-44118234e5f6" />

1. O(1) - 상수 시간
2. O(log n) - 로그 시간
3. O(n) - 선형 시간
4. O(n log n)
5. O(n²) - 제곱 시간
6. O(2ⁿ) - 지수 시간
7. O(n!) - 팩토리얼 시간

> [!TIP]
> 빅 오 표기법 외에도 빅 세타 표기법(평균적 실행 시간)과 빅 오메가 표기법(점근적 하한)이 있지만, 코드 성능 판단에는 주로 빅 오 표기법 사용함 <br /> <img width="600" alt="image" src="https://github.com/user-attachments/assets/45a2134b-3917-48c1-a2e9-883e7d49d325" />

### 공간 복잡도

> [!NOTE]
> 프로그램 실행 시 필요한 **메모리 자원**의 양 <br />
> 입력에 따른 메모리 사용량의 척도

- 실행 과정에 많은 메모리가 필요한 경우 공간 복잡도가 큼
- 적은 메모리가 필요한 경우 공간 복잡도가 작음
- 시간 복잡도와 마찬가지로 빅 오 표기법으로 표현

> [!TIP]
> 오늘날 알고리즘 성능 판단은 주로 공간 복잡도보다 시간 복잡도를 기준임 <br />
> 따라서 특별한 언급이 없으면 빅 오 표기법은 시간 복잡도를 의미

## 예시: 정렬 알고리즘의 시간 복잡도

| 정렬 알고리즘 | 시간 복잡도 |
| ------------- | ----------- |
| 삽입 정렬     | O(n²)       |
| 선택 정렬     | O(n²)       |
| 버블 정렬     | O(n²)       |
| 병합 정렬     | O(n log n)  |
| 퀵 정렬       | O(n log n)  |
| 힙 정렬       | O(n log n)  |

> [!TIP]
> 자료구조를 통한 다양한 연산(접근, 검색, 삽입, 삭제)의 성능도 빅 오 표기법으로 표현 가능

# 배열과 연결 리스트

## 배열(Array)

> [!NOTE]
> 배열은 일정한 메모리 공간을 차지하는 여러 요소들이 순차적으로 나열된 자료구조 <br />
> 각 요소는 0부터 시작하는 고유한 순서 번호인 인덱스로 식별됨

배열은 **RAM과 유사한 특성**을 가짐. RAM이 어떤 주소에 접근하든 접근 시간이 일정한 것처럼, 배열도 인덱스를 통해 요소에 접근하는 시간이 요소의 개수와 무관하게 일정함.

### 시간 복잡도 분석

시간 복잡도는 배열의 요소들이 정렬돼 있지 않다고 가정함.

| 연산             | 시간 복잡도 | 설명                    |
| ---------------- | ----------- | ----------------------- |
| 인덱스 기반 접근 | O(1)        | 인덱스를 통한 직접 접근 |
| 인덱스 기반 수정 | O(1)        | 특정 인덱스 값 변경     |
| 순차적 검색      | O(n)        | 순차적 탐색 필요        |
| 요소 추가        | O(n)        | 이후 요소들의 이동 필요 |
| 요소 삭제        | O(n)        | 이후 요소들의 이동 필요 |

### 다차원 배열

- **이차원 배열**: 2개의 인덱스(행, 열)로 요소 식별
- **삼차원 배열**: 3개의 인덱스(행, 열, 깊이)로 요소 식별
- 메모리 상에는 모두 일차원적으로 저장됨

<img width="600" alt="image" src="https://github.com/user-attachments/assets/59d22380-834e-483d-b401-e22a8aeeea18" />

> [!NOTE]
> 정적 배열 vs 동적 배열 비교,
>
> - **정적 배열**: 컴파일 시점에 크기 고정, 실행 중 크기 변경 불가
> - **동적 배열**: 실행 중 크기 조정 가능, 벡터(vector)라고도 부름

## 연결 리스트(Linked List)

> [!NOTE]
> 연결 리스트는 노드의 모음으로 구성된 자료구조임
> 각 노드는 데이터와 다음 노드의 위치 정보를 포함

### 노드의 구성

노드는 다음 두 요소를 포함.

```
┌─────────────┬──────────────┐
│    Data     │  Next Node   │
└─────────────┴──────────────┘
```

1. 저장하고자 하는 데이터
2. 다음 노드의 위치(메모리 상의 주소) 정보

### 연결 리스트의 구조

- 모든 노드들이 한 쪽 방향으로 꼬리에 꼬리를 무는 형태로 구성
- **헤드(head)**: 연결 리스트의 첫 번째 노드
- **테일(tail)**: 연결 리스트의 마지막 노드
- 더 이상의 노드가 없음은 NULL로 표기

<img width="600" alt="image" src="https://github.com/user-attachments/assets/fbb1acd8-56c8-48b0-8f2f-4fb230857fe3" />

### 메모리 저장 특성

연결 리스트를 구성하는 모든 노드는 반드시 메모리 내에 순차적으로 저장돼 있을 필요가 없음. 이 때문에 연속적으로 구성돼 있는 데이터를 불연속적으로 저장할 때 유용함.

### 연결 리스트의 접근 방식

> [!NOTE]
> 연결 리스트에서 특정 요소에 접근할 때는 앞에서부터 순차적으로 접근할 수밖에 없음  
> 찾고자 하는 데이터가 몇 번째 노드에 있는지 알아도 O(1)에 접근 불가능, **O(n) 소요됨**

배열과 달리 연결 리스트는 인덱스/임의 접근이 불가능함. 헤드부터 시작해 다음 노드 정보를 따라가며 순차적으로 탐색해야 함.

### 연결 리스트의 삽입과 삭제

연결 리스트는 배열에 비해 추가 및 삭제 연산에서 강점을 가짐.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/97f77b4d-867e-4fef-8e0e-5e788d345006" />

- **중간 요소 추가/삭제 시 재정렬 불필요**
- **노드의 위치 정보만 변경하면 됨**
- **삽입/삭제할 위치가 주어지면 O(1) 소요**

## 연결 리스트의 변형

### 싱글 연결 리스트(Singly Linked List)

> [!NOTE]
> 기본적인 연결 리스트 형태로, 각 노드가 다음 노드의 위치 정보만 저장함 <br />
> 한 쪽 방향으로만 탐색 가능한 단방향 구조

**한계점**: 특정 노드에서 **이전 노드의 위치를 알기 어려워 단방향 탐색**만 가능함

### 이중 연결 리스트(Doubly Linked List)

> [!NOTE]
> 각 노드가 다음 노드와 이전 노드의 위치 정보를 모두 포함하는 연결 리스트 <br />
> 양방향 탐색이 가능함

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c71098fc-2b04-46a1-9534-37e9a133fedc" />

#### **구성 요소**

- 이전 노드 위치 정보
- 데이터
- 다음 노드 위치 정보

**장점**: 양방향 탐색으로 싱글 연결 리스트의 **탐색 성능 개선**
**단점**: 2개의 위치 정보 저장으로 인한 **추가 저장 공간 필요**

### 환형 연결 리스트(Circular Linked List)

> [!NOTE]
> 꼬리 노드가 헤드 노드를 가리켜 노드들이 원형으로 구성된 연결 리스트 <br />
> 마지막 노드에서 NULL 대신 첫 번째 노드를 가리킴

<img width="600" alt="image" src="https://github.com/user-attachments/assets/20a61d9d-c5ee-45ea-8c8a-8681aae2045e" />

### 이중 환형 연결 리스트

이중 연결 리스트와 환형 연결 리스트의 결합됨.

- 헤드 노드의 이전 노드가 꼬리 노드를 가리킴
- 꼬리 노드의 다음 노드가 헤드 노드를 가리킴
- 양방향 탐색과 순환 구조를 모두 지원

**활용**: 모든 노드 데이터를 여러 차례 순회해야 할 때 유용

# 스택과 큐

스택과 큐는 범용적으로 활용되는 기본 자료구조로, 다른 자료구조나 알고리즘 구현 시 재료로 자주 사용됨.

## 스택

> [!NOTE]
> 한 쪽에서만 데이터 삽입 및 삭제가 가능한 자료구조 <br />
> 후입선출(LIFO: Last In First Out) 방식으로 데이터 처리

### 스택의 기본 연산

- **푸시(Push)**: 스택에 데이터 저장
- **팝(Pop)**: 스택에서 데이터 제거

### 스택 활용 상황

#### 1. 최근 임시 저장 데이터의 우선 활용

**함수 매개변수 저장**이 대표적 예시임.

```c
int foo(int x) {
    return x + 1;
}

int bar(int y) {
    return y + 2;
}

int foo(int x) {
    bar(2);    // bar 함수 호출
    return x + 1;
}

foo(1);  // 함수 호출
```

**함수 호출 과정**은 아래와 같다.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/b6c720b3-a983-4d6e-a5ce-4aaac0a913f3" />

1. `foo(1)` 호출 시 매개변수 `x = 1` 스택에 저장
2. `bar(2)` 호출 시 매개변수 `y = 2` 스택에 저장
3. `bar` 함수 종료 시 `y` 메모리에서 제거 (팝)
4. `foo` 함수 종료 시 `x` 메모리에서 제거 (팝)

기본적으로 최근에 호출된 함수의 매개변수가 가장 먼저 활용되고, 가장 먼저 메모리에서 삭제됨. 이러한 형태로 매개변수를 저장할 때 후입선출 자료구조인 스택이 가장 적합함.

#### 2. 뒤로가기 기능 구현

**웹 브라우저 뒤로가기**가 대표적 예시임.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/53350ca0-891a-4439-833d-e17f82c5e2af" />

- 웹사이트 방문 시마다 URL을 스택에 푸시
- 뒤로가기 버튼 클릭 시 URL을 스택에서 팝
- 이전 방문 페이지로 순차적 이동 가능

**미로 탐색에서의 경로 되돌리기**도 있음.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/a5917465-309c-4f9a-a38b-34ae5e2000ad" />

- 앞으로 이동 시마다 현재 위치를 스택에 푸시
- 막다른 길 도달 시 스택에서 팝하여 이전 위치로 복귀
- 다른 경로 탐색 가능

## 큐

> [!NOTE]
> 한 쪽으로 데이터를 삽입하고 다른 한 쪽으로 데이터를 삭제하는 자료구조 <br />
> 선입선출(FIFO: First In First Out) 방식으로 데이터 처리

### 큐의 기본 연산

- **인큐(Enqueue)**: 큐의 한 쪽 끝에 데이터 삽입
- **디큐(Dequeue)**: 큐의 다른 한 쪽 끝에서 데이터 삭제

큐는 임시 저장된 데이터를 차례차례 내보내거나 꺼내와야 하는 각종 버퍼로 활용됨. 줄 세우기에 자주 사용됨.

- 임시 저장된 데이터를 차례대로 처리
- 줄 세우기와 같은 순서 보장이 필요한 상황

## 큐의 변형 형태

### 원형 큐(Circular Queue)

<img width="600" alt="image" src="https://github.com/user-attachments/assets/29b95920-aed0-4432-b795-80e3fac9a18b" />

> [!NOTE]
> 데이터 삽입과 삭제 부분을 원형으로 연결한 자료구조 <br />
> 메모리 공간을 효율적으로 재사용 가능

### 덱(Deque)

<img width="600" alt="image" src="https://github.com/user-attachments/assets/8ebdd9de-ca5e-488f-82dc-649479df32b2" />

> [!NOTE]
> Double-ended Queue의 약자 <br />
> 양쪽 끝에서 데이터 삽입과 삭제가 모두 가능한 자료구조

### 우선순위 큐(Priority Queue)

> [!NOTE]
> 선입선출이 아닌 **우선순위가 높은 순서**대로 데이터 처리하는 큐 <br />
> 힙(Heap) 자료구조를 기반으로 구현됨

요소가 저장되어 있는 순서와 무관하게 우선순위가 높은 순서대로 빠져나가는 큐임.

- 저장 순서와 무관하게 우선순위 기준으로 데이터 처리
- 힙 자료구조 이해를 위해서는 트리 구조 선행 학습 필요

> [!WARNING]
> 우선순위 큐는 일반적인 큐와 달리 삽입 순서가 아닌 우선순위에 따라 처리 순서가 결정되므로, 사용 시 이 점을 반드시 고려해야 함
