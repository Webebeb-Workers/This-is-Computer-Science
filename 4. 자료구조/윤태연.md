# 자료구조의 큰 그림

자료구조는 **데이터를 어떠한 구조**로 다룰지에 대해 학습하는 과목.
알고리즘과 깊은 연관성을 가지며, 시간 복잡도와 공간 복잡도를 통해 자료구조와 알고리즘의 효율성 판단 가능함.

## 자료구조와 알고리즘

- **자료구조**: 데이터를 효율적으로 저장하고 관리하기 위한 방법
- **알고리즘**: 어떠한 목적을 이루기 위한 효율적인 연산 절차

둘 사이의 연관성이 존재함.

- 사용하는 자료구조에 따라 적용 가능한 알고리즘 달라짐
- 너비 우선 탐색, 깊이 우선 탐색 등의 알고리즘은 그래프, 스택 등의 자료구조 이해 필요

## 시간 복잡도와 공간 복잡도

### 시간 복잡도

> [!NOTE]
> 입력의 크기에 따른 프로그램 실행 시간의 관계 <br />
> 실행 시간은 연산 횟수에 비례한다고 간주

```python
# n번의 연산 필요
for _ in range(n):
    1 + 1  # 한 번의 연산

# 2n번의 연산 필요
for _ in range(2 * n):
    1 + 1

# n²번의 연산 필요
for _ in range(n):
    for _ in range(n):
        1 + 1

# (n² + 3n + 2)번의 연산 필요
for _ in range(n):
    for _ in range(n):
        1 + 1  # n²번
for _ in range(3 * n):
    1 + 1  # 3n번
1 + 1  # 1번
1 + 1  # 1번
```

> [!TIP]
> 프로그램의 시간 복잡도에 가장 많은 영향을 끼치는 문법은 반복문이 제일 큼!

### 빅 오 표기법

> [!NOTE]
> 함수의 **점근적 상한을 표기**하는 방법, 입력값이 무한대로 커질 때 **실행 시간의 상한**을 표현

빅 오 표기법 특징은 아래와 같다.

- 최고차항의 차수만 고려
- 계수와 낮은 차수의 항 무시
- 입력값 n이 증가할수록 영향력 커짐

#### 주요 시간 복잡도 (성능 좋은 순)

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c3287b1f-5c7c-4b34-a708-44118234e5f6" />

1. O(1) - 상수 시간
2. O(log n) - 로그 시간
3. O(n) - 선형 시간
4. O(n log n)
5. O(n²) - 제곱 시간
6. O(2ⁿ) - 지수 시간
7. O(n!) - 팩토리얼 시간

> [!TIP]
> 빅 오 표기법 외에도 빅 세타 표기법(평균적 실행 시간)과 빅 오메가 표기법(점근적 하한)이 있지만, 코드 성능 판단에는 주로 빅 오 표기법 사용함 <br /> <img width="600" alt="image" src="https://github.com/user-attachments/assets/45a2134b-3917-48c1-a2e9-883e7d49d325" />

### 공간 복잡도

> [!NOTE]
> 프로그램 실행 시 필요한 **메모리 자원**의 양 <br />
> 입력에 따른 메모리 사용량의 척도

- 실행 과정에 많은 메모리가 필요한 경우 공간 복잡도가 큼
- 적은 메모리가 필요한 경우 공간 복잡도가 작음
- 시간 복잡도와 마찬가지로 빅 오 표기법으로 표현

> [!TIP]
> 오늘날 알고리즘 성능 판단은 주로 공간 복잡도보다 시간 복잡도를 기준임 <br />
> 따라서 특별한 언급이 없으면 빅 오 표기법은 시간 복잡도를 의미

## 예시: 정렬 알고리즘의 시간 복잡도

| 정렬 알고리즘 | 시간 복잡도 |
| ------------- | ----------- |
| 삽입 정렬     | O(n²)       |
| 선택 정렬     | O(n²)       |
| 버블 정렬     | O(n²)       |
| 병합 정렬     | O(n log n)  |
| 퀵 정렬       | O(n log n)  |
| 힙 정렬       | O(n log n)  |

> [!TIP]
> 자료구조를 통한 다양한 연산(접근, 검색, 삽입, 삭제)의 성능도 빅 오 표기법으로 표현 가능

# 배열과 연결 리스트

## 배열(Array)

> [!NOTE]
> 배열은 일정한 메모리 공간을 차지하는 여러 요소들이 순차적으로 나열된 자료구조 <br />
> 각 요소는 0부터 시작하는 고유한 순서 번호인 인덱스로 식별됨

배열은 **RAM과 유사한 특성**을 가짐. RAM이 어떤 주소에 접근하든 접근 시간이 일정한 것처럼, 배열도 인덱스를 통해 요소에 접근하는 시간이 요소의 개수와 무관하게 일정함.

### 시간 복잡도 분석

시간 복잡도는 배열의 요소들이 정렬돼 있지 않다고 가정함.

| 연산             | 시간 복잡도 | 설명                    |
| ---------------- | ----------- | ----------------------- |
| 인덱스 기반 접근 | O(1)        | 인덱스를 통한 직접 접근 |
| 인덱스 기반 수정 | O(1)        | 특정 인덱스 값 변경     |
| 순차적 검색      | O(n)        | 순차적 탐색 필요        |
| 요소 추가        | O(n)        | 이후 요소들의 이동 필요 |
| 요소 삭제        | O(n)        | 이후 요소들의 이동 필요 |

### 다차원 배열

- **이차원 배열**: 2개의 인덱스(행, 열)로 요소 식별
- **삼차원 배열**: 3개의 인덱스(행, 열, 깊이)로 요소 식별
- 메모리 상에는 모두 일차원적으로 저장됨

<img width="600" alt="image" src="https://github.com/user-attachments/assets/59d22380-834e-483d-b401-e22a8aeeea18" />

> [!NOTE]
> 정적 배열 vs 동적 배열 비교,
>
> - **정적 배열**: 컴파일 시점에 크기 고정, 실행 중 크기 변경 불가
> - **동적 배열**: 실행 중 크기 조정 가능, 벡터(vector)라고도 부름

## 연결 리스트(Linked List)

> [!NOTE]
> 연결 리스트는 노드의 모음으로 구성된 자료구조임
> 각 노드는 데이터와 다음 노드의 위치 정보를 포함

### 노드의 구성

노드는 다음 두 요소를 포함.

```
┌─────────────┬──────────────┐
│    Data     │  Next Node   │
└─────────────┴──────────────┘
```

1. 저장하고자 하는 데이터
2. 다음 노드의 위치(메모리 상의 주소) 정보

### 연결 리스트의 구조

- 모든 노드들이 한 쪽 방향으로 꼬리에 꼬리를 무는 형태로 구성
- **헤드(head)**: 연결 리스트의 첫 번째 노드
- **테일(tail)**: 연결 리스트의 마지막 노드
- 더 이상의 노드가 없음은 NULL로 표기

<img width="600" alt="image" src="https://github.com/user-attachments/assets/fbb1acd8-56c8-48b0-8f2f-4fb230857fe3" />

### 메모리 저장 특성

연결 리스트를 구성하는 모든 노드는 반드시 메모리 내에 순차적으로 저장돼 있을 필요가 없음. 이 때문에 연속적으로 구성돼 있는 데이터를 불연속적으로 저장할 때 유용함.

### 연결 리스트의 접근 방식

> [!NOTE]
> 연결 리스트에서 특정 요소에 접근할 때는 앞에서부터 순차적으로 접근할 수밖에 없음  
> 찾고자 하는 데이터가 몇 번째 노드에 있는지 알아도 O(1)에 접근 불가능, **O(n) 소요됨**

배열과 달리 연결 리스트는 인덱스/임의 접근이 불가능함. 헤드부터 시작해 다음 노드 정보를 따라가며 순차적으로 탐색해야 함.

### 연결 리스트의 삽입과 삭제

연결 리스트는 배열에 비해 추가 및 삭제 연산에서 강점을 가짐.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/97f77b4d-867e-4fef-8e0e-5e788d345006" />

- **중간 요소 추가/삭제 시 재정렬 불필요**
- **노드의 위치 정보만 변경하면 됨**
- **삽입/삭제할 위치가 주어지면 O(1) 소요**

## 연결 리스트의 변형

### 싱글 연결 리스트(Singly Linked List)

> [!NOTE]
> 기본적인 연결 리스트 형태로, 각 노드가 다음 노드의 위치 정보만 저장함 <br />
> 한 쪽 방향으로만 탐색 가능한 단방향 구조

**한계점**: 특정 노드에서 **이전 노드의 위치를 알기 어려워 단방향 탐색**만 가능함

### 이중 연결 리스트(Doubly Linked List)

> [!NOTE]
> 각 노드가 다음 노드와 이전 노드의 위치 정보를 모두 포함하는 연결 리스트 <br />
> 양방향 탐색이 가능함

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c71098fc-2b04-46a1-9534-37e9a133fedc" />

#### **구성 요소**

- 이전 노드 위치 정보
- 데이터
- 다음 노드 위치 정보

**장점**: 양방향 탐색으로 싱글 연결 리스트의 **탐색 성능 개선**
**단점**: 2개의 위치 정보 저장으로 인한 **추가 저장 공간 필요**

### 환형 연결 리스트(Circular Linked List)

> [!NOTE]
> 꼬리 노드가 헤드 노드를 가리켜 노드들이 원형으로 구성된 연결 리스트 <br />
> 마지막 노드에서 NULL 대신 첫 번째 노드를 가리킴

<img width="600" alt="image" src="https://github.com/user-attachments/assets/20a61d9d-c5ee-45ea-8c8a-8681aae2045e" />

### 이중 환형 연결 리스트

이중 연결 리스트와 환형 연결 리스트의 결합됨.

- 헤드 노드의 이전 노드가 꼬리 노드를 가리킴
- 꼬리 노드의 다음 노드가 헤드 노드를 가리킴
- 양방향 탐색과 순환 구조를 모두 지원

**활용**: 모든 노드 데이터를 여러 차례 순회해야 할 때 유용

# 스택과 큐

스택과 큐는 범용적으로 활용되는 기본 자료구조로, 다른 자료구조나 알고리즘 구현 시 재료로 자주 사용됨.

## 스택

> [!NOTE]
> 한 쪽에서만 데이터 삽입 및 삭제가 가능한 자료구조 <br />
> 후입선출(LIFO: Last In First Out) 방식으로 데이터 처리

### 스택의 기본 연산

- **푸시(Push)**: 스택에 데이터 저장
- **팝(Pop)**: 스택에서 데이터 제거

### 스택 활용 상황

#### 1. 최근 임시 저장 데이터의 우선 활용

**함수 매개변수 저장**이 대표적 예시임.

```c
int foo(int x) {
    return x + 1;
}

int bar(int y) {
    return y + 2;
}

int foo(int x) {
    bar(2);    // bar 함수 호출
    return x + 1;
}

foo(1);  // 함수 호출
```

**함수 호출 과정**은 아래와 같다.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/b6c720b3-a983-4d6e-a5ce-4aaac0a913f3" />

1. `foo(1)` 호출 시 매개변수 `x = 1` 스택에 저장
2. `bar(2)` 호출 시 매개변수 `y = 2` 스택에 저장
3. `bar` 함수 종료 시 `y` 메모리에서 제거 (팝)
4. `foo` 함수 종료 시 `x` 메모리에서 제거 (팝)

기본적으로 최근에 호출된 함수의 매개변수가 가장 먼저 활용되고, 가장 먼저 메모리에서 삭제됨. 이러한 형태로 매개변수를 저장할 때 후입선출 자료구조인 스택이 가장 적합함.

#### 2. 뒤로가기 기능 구현

**웹 브라우저 뒤로가기**가 대표적 예시임.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/53350ca0-891a-4439-833d-e17f82c5e2af" />

- 웹사이트 방문 시마다 URL을 스택에 푸시
- 뒤로가기 버튼 클릭 시 URL을 스택에서 팝
- 이전 방문 페이지로 순차적 이동 가능

**미로 탐색에서의 경로 되돌리기**도 있음.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/a5917465-309c-4f9a-a38b-34ae5e2000ad" />

- 앞으로 이동 시마다 현재 위치를 스택에 푸시
- 막다른 길 도달 시 스택에서 팝하여 이전 위치로 복귀
- 다른 경로 탐색 가능

## 큐

> [!NOTE]
> 한 쪽으로 데이터를 삽입하고 다른 한 쪽으로 데이터를 삭제하는 자료구조 <br />
> 선입선출(FIFO: First In First Out) 방식으로 데이터 처리

### 큐의 기본 연산

- **인큐(Enqueue)**: 큐의 한 쪽 끝에 데이터 삽입
- **디큐(Dequeue)**: 큐의 다른 한 쪽 끝에서 데이터 삭제

큐는 임시 저장된 데이터를 차례차례 내보내거나 꺼내와야 하는 각종 버퍼로 활용됨. 줄 세우기에 자주 사용됨.

- 임시 저장된 데이터를 차례대로 처리
- 줄 세우기와 같은 순서 보장이 필요한 상황

## 큐의 변형 형태

### 원형 큐(Circular Queue)

<img width="600" alt="image" src="https://github.com/user-attachments/assets/29b95920-aed0-4432-b795-80e3fac9a18b" />

> [!NOTE]
> 데이터 삽입과 삭제 부분을 원형으로 연결한 자료구조 <br />
> 메모리 공간을 효율적으로 재사용 가능

### 덱(Deque)

<img width="600" alt="image" src="https://github.com/user-attachments/assets/8ebdd9de-ca5e-488f-82dc-649479df32b2" />

> [!NOTE]
> Double-ended Queue의 약자 <br />
> 양쪽 끝에서 데이터 삽입과 삭제가 모두 가능한 자료구조

### 우선순위 큐(Priority Queue)

> [!NOTE]
> 선입선출이 아닌 **우선순위가 높은 순서**대로 데이터 처리하는 큐 <br />
> 힙(Heap) 자료구조를 기반으로 구현됨

요소가 저장되어 있는 순서와 무관하게 우선순위가 높은 순서대로 빠져나가는 큐임.

- 저장 순서와 무관하게 우선순위 기준으로 데이터 처리
- 힙 자료구조 이해를 위해서는 트리 구조 선행 학습 필요

> [!WARNING]
> 우선순위 큐는 일반적인 큐와 달리 삽입 순서가 아닌 우선순위에 따라 처리 순서가 결정되므로, 사용 시 이 점을 반드시 고려해야 함

# 해시 테이블

## 해시 테이블 개념

> [!NOTE]
> 해시 테이블(hash table)은 키(Key)와 값(Value)의 대응으로 이루어진 표(테이블)와 같은 형태의 자료구조 <br />
> 키는 해시 테이블에 대한 입력, 값은 키를 통해 얻고자 하는 데이터에 해당

### 해시 테이블 일상 예시

- **전화번호부**: 이름(키) - 전화번호(값) 대응
- **도서 정보**: ISBN(키) - 책 제목(값) 대응

| ISBN(키)      | 책 제목(값)                          |
| ------------- | ------------------------------------ |
| 9791162243091 | 혼자 공부하는 컴퓨터 구조 + 운영체제 |
| 9791162243664 | 혼자 공부하는 머신러닝 + 딥러닝      |
| 9791162245651 | 혼자 공부하는 파이썬                 |

### 해시 테이블의 활용

- 운영체제 내부에서 자주 사용됨
- 리눅스 커널 내부에 해시 테이블 정의
- 과거 페이지 캐시, 아이노드 캐시 등으로 활용
- 네트워크, DB 등에 자주 사용됨

## 해시 테이블의 구조

해시 테이블의 핵심 구성 요소는 아래와 같다.

- **버킷(bucket)**: 데이터가 저장되는 공간
- **해시 함수**: 키를 인자로 활용해 인덱스를 반환하는 함수
- **버킷 배열**: 여러 버킷들이 배열을 형성

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c1bba43b-e0da-4538-8b1e-cacfbcaab1f8" />

> [!NOTE]
> 로드 팩터(load factor)는 해시 테이블에 저장된 데이터 수를 버킷의 수로 나눈 값 <br />
> 로드 팩터가 클수록 해시 테이블의 성능이 떨어짐

## 해시 함수

> [!NOTE]
> 해시 함수(hash function)는 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 변환하는 단방향 함수 <br />
> 특정 입력 데이터를 고정된 길이의 해시 값으로 변환할 수는 있어도, 반대로 해시 값을 토대로 어떤 데이터가 입력되었는지를 도출하기는 어려움

### 대표적 해시 알고리즘

- MD5
- SHA-1
- SHA-256
- SHA-512
- SHA3
- HMAC

### 해시 함수 특징

같은 데이터라도 적용된 해시 알고리즘이 다르면 해시 값의 길이나 값이 달라짐. 문자열이 한 글자만 달라져도 해시 값은 크게 달라질 수 있음.

#### 예시: SHA-256 해시 값

- "hanbit": 3f5e2cf9fe54c5c8df8589d53f6f787f66b7cc556b1543d5cd002c29d8b12b28
- "hanbitedia": f6c3a369cb093a0d8975b74a94035a75266f5c2032712b471443bf17e469a5ef
- "hanbit media": 7b860e4e58c1b4c86de890837b6a4653ba5a0a31ec6f4b66e1b6f438a26512ea

### 해시 함수의 활용

<img width="600" alt="image" src="https://github.com/user-attachments/assets/25f71a26-abe8-43a7-983a-15faf05860d6" />

#### 1. 데이터 무결성 검증

> [!NOTE]
> 해시 함수를 이용한 무결성 검증은 데이터가 전송 과정에서 변조되지 않았는지 확인하는 메커니즘 <br />
> 송신자와 수신자가 동일한 해시 값을 가지는지 비교하여 데이터의 무결성을 보장

**무결성 검증 프로세스**는 아래와 같음.

1. **송신 측**
   - 보낼 데이터에 대한 해시 값 계산 (예: aabb)
   - 원본 데이터와 해시 값을 함께 전송
2. **수신 측**
   - 받은 데이터에 대한 해시 값 계산
   - 전달받은 해시 값(aabb)과 계산한 해시 값 비교
3. **검증 결과**
   - **일치**: 데이터가 정상적으로 전송됨
   - **불일치**: 전송 과정에서 데이터 변조 또는 손상 발생

> [!TIP]
> 해시 함수의 특성상 데이터가 1비트만 변경되어도 완전히 다른 해시 값이 생성되므로, 아주 작은 변조도 즉시 감지 가능

#### 2. 비밀번호 저장

> [!NOTE]
> 웹 서비스에서 사용자 비밀번호는 평문으로 저장하지 않고, 단방향 해시 함수를 통해 암호화하여 저장함. 이는 법적 규제사항이며 보안의 기본 원칙임.

**비밀번호 저장 과정**은 아래와 같다.

1. 사용자가 비밀번호 입력
2. 해시 함수 적용하여 해시 값 생성
3. 해시 값만 데이터베이스에 저장
4. 로그인 시 입력된 비밀번호를 같은 방식으로 해시화하여 저장된 값과 비교

**주요 비밀번호 해시 함수**는 아래와 같다.(어떤 해시 함수인지 임의 작성함)

- **bcrypt**: 의도적으로 느리게 설계되어 브루트포스 공격에 강함
- **PBKDF2**: 반복적인 해시 연산으로 보안성 강화
- **scrypt**: 메모리 사용량이 많아 하드웨어 공격에 강함
- **argon2**: 가장 최신 알고리즘으로 메모리와 시간 복잡도 모두 고려

> [!WARNING]
> 개인정보보호법에 따라 비밀번호는 반드시 복호화가 불가능한 일방향 암호화로 저장해야 함 <br />
> MD5, SHA-1 같은 단순 해시 함수는 보안상 취약하므로 사용하지 않아야 함

**실제 구현 예시**를 스프링, 장고로 보여주자면,

- **Spring Framework**: BCryptPasswordEncoder 제공
- **Django Framework**: PBKDF2를 기본으로 사용하며 argon2, bcrypt 등 지원

> [!TIP]
> 모듈러 연산을 이용한 간단한 해시 함수: 키를 해시 테이블 크기로 나눈 나머지를 해시 값으로 사용, 예: h(k) = k mod m (k는 키, m은 해시 테이블 크기)

## 해시 테이블 성능

### 장점

- 검색, 삽입, 삭제 연산의 시간 복잡도: O(1)
- 입력과 무관하게 항상 일정한 속도 보장

### 단점

- 상대적으로 많은 메모리 공간 소모
- 해시 충돌 문제 발생 가능

## 해시 충돌

<img width="600" alt="image" src="https://github.com/user-attachments/assets/3382c19e-590e-4cc1-bc33-3b2f9f715f22" />

> [!NOTE]
> 해시 충돌(hash collision): 서로 다른 키에 대해 같은 해시 값이 대응되는 상황

### SHA-1 해시 충돌 사례

구글과 CWI 암스테르담 연구소가 SHA-1 해시 함수의 충돌을 입증함. 서로 다른 PDF 파일이 동일한 SHA-1 해시 값을 가지는 사례 발견.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/6fbf6800-7f6a-45f6-a59d-526b41e024b3" />

또한 해시 값은 무결성 검증에도 사용되는데, 위 두 파일이 같다는 오해를 불러일으키거나 데이터를 가로채 위조할 수 있는 보안상 위험도 존재함.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/6cf82e13-6b63-4fcc-8532-a1e60de49fff" />

### 해시 충돌 해결 방법

#### 1. 체이닝(Chaining)

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c0e32ff0-ac10-436e-8813-9e32871ef9f0" />

- 충돌이 발생한 데이터를 연결 리스트로 추가하는 방법
- 하나의 테이블 인덱스에 여러 데이터가 연결 리스트의 노드로 존재 가능
- **단점**: 모든 데이터가 충돌할 경우 탐색 성능이 O(n)으로 떨어짐

#### 2. 개방 주소법(Open Addressing)

충돌 발생 시 충돌한 버킷의 인덱스가 아닌 **다른 인덱스에 데이터를 저장**하는 방법.

##### 선형 조사법(Linear Probing)

<img width="600" alt="image" src="https://github.com/user-attachments/assets/d406c016-373c-4cdf-82c8-87ce777db22e" />

- 충돌 발생 시 다음 인덱스부터 순차적으로 가용한 인덱스 탐색
- `f(key)`, `f(key)+1`, `f(key)+2`, ... 순으로 탐색
- **문제점**: 데이터의 군집화(clustering) 현상 발생 가능

<img width="600" alt="image" src="https://github.com/user-attachments/assets/139248c2-ab0b-43eb-af18-d27e54c58027" />

> [!TIP]
> 이차 조사법(Quadratic Probing): 충돌 발생 시 제곱수만큼 떨어진 거리의 인덱스 탐색 <br />
> 즉, `f(key)+1²`, `f(key)+2²`, `f(key)+3²` 순으로 탐색

##### 이중 해싱(Double Hashing)

- 2개의 해시 함수 사용
- 충돌 발생 시 보조 해시 함수의 값만큼 떨어진 인덱스 탐색
- `f(key)+g(key)`, `f(key)+2g(key)`, `f(key)+3g(key)` 순으로 탐색

## 프로그래밍 언어별 해시 테이블 구현

| 프로그래밍 언어 | 해시 테이블 구현   |
| --------------- | ------------------ |
| C++             | unordered_map      |
| 자바            | HashTable, HashMap |
| 파이썬          | dictionary         |
| 자바스크립트    | Map                |
| Go              | map                |

아래는 좀 더 임의대로 구체화한 표다.

| 프로그래밍 언어 | 해시 테이블 구현체           | 키-값 쌍 지원 | 키만 지원 | 동작 원리 및 특징 요약                                                                    |
| --------------- | ---------------------------- | :-----------: | :-------: | ----------------------------------------------------------------------------------------- |
| C++             | unordered_map, unordered_set |       O       |     O     | 체이닝 기반 해시 테이블, 평균 O(1) 성능, unordered_map은 키-값, unordered_set은 키만 저장 |
| Java            | HashMap, HashTable, HashSet  |       O       |     O     | 해시 버킷 기반, HashMap은 동기화X, HashTable은 동기화O, HashSet은 키만 저장               |
| Python          | dict, set                    |       O       |     O     | dict/set 모두 오픈 어드레싱 기반, dict는 키-값, set은 키만 저장                           |
| JavaScript      | Map, Set, Object             |       O       |     O     | Map/Set은 ES6 표준 해시 테이블, Object도 해시 역할, Map은 키-값, Set은 키만 저장          |
| Go              | map                          |       O       |     X     | 내장 map 타입, 해시 버킷 기반, 키-값 저장, set은 별도 타입 없음 (`map[T]struct{}`로 흉내) |
