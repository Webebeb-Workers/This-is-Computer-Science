# 1. 네트워크의 큰 그림

## 네트워크의 기본 구조

<img width="507" alt="Image" src="https://github.com/user-attachments/assets/acfb1b4e-0524-4c29-b99e-c899337ddc71" />

- 네트워크는 노드(네트워크 기기)와 간선(유무선 통신 매체)으로 이루어진 그래프 형태
- 네트워크 상에서 노드와 노드 사이의 연결 구조는 **네트워크 토폴로지**라고 부름
- 노드가 어떻게 연결/배치 되느냐에 따라 망형, 트리형, 링형 등의 유형으로 나눌 수 있음

  <img width="549" alt="Image" src="https://github.com/user-attachments/assets/b332b2c3-33dd-4f21-9e6a-a8b024fcea32" />

- **호스트**: 네트워크를 통해 주고받는 정보를 최초로 송신/수신하는 노드
  - ex) 노트북의 웹 브라우저를 통해 구글 홈페이지에 접속했다면 노트북과 구글 서버 컴퓨터가 호스트임
  - **클라이언트**: 요청을 보내는 호스트
  - **서버**: 응답을 보내는 호스트
  - 클라이언트와 서버는 주고받는 정보의 방향(요청과 응답)에 따라 부여된 역할
- **중간 노드**: 네트워크 그래프에서 중간에 위치한 노드, 호스트가 주고받는 정보들을 원하는 수신지까지 안정적으로 전송하는 역할을 함
  - ex) 스위치, 라우터, 공유기

### LAN과 WAN

- 네트워크는 규모에 따라 LAN과 WAN으로 나뉨
- **LAN**
  - 근거리 네트워크를 의미
  - 가정이나 기업처럼 비교적 가까운 거리를 연결하는 한정된 공간에서의 네트워크를 말함
- **WAN**
  - 원거리 네트워크를 의미
  - WAN을 통해 LAN 간 통신이 이루어짐
  - 인터넷을 가능하게 만드는 네트워크
  - ISP(Internet Service Provider)라는 인터넷 서비스 업체가 구축하고 관리함
    - ex) KT, LG 유플러스, SK브로드밴드

### 패킷 교환 네트워크

- 네트워크를 통해 주고받는 데이터는 한 번에 송수신되지 않고, 여러 데이터로 쪼개져서 송수신됨
- **패킷**: 네트워크를 통해 송수신되는 데이터의 단위
- **패킷 교환 네트워크**: 패킷 단위로 주고받는 정보를 쪼개서 송수신하고 수신지에서 재조립하여 패킷을 주고받는 네트워크, 오늘날의 대부분의 네트워크
- 하나의 패킷은 **페이로드**와 **헤더**로 구성되어 있음, 때로는 **트레일러**라는 정보가 포함되기도 함
- **페이로드**: 패킷에서 송수신하고자 하는 데이터
- **헤더**, **트레일러**: 패킷에 추가되는 부가 정보

> 트레일러 정보는 예를 들어 뭐가 있을까

### 주소의 개념과 전송 방식

- 네트워크 상의 두 호스트가 올바르게 정보를 주고받기 위해서는 서로를 특정할 수 있는 정보, 즉 주소가 필요함
- **주소**: 패킷의 헤더에 명시되는 정보, 네트워크에서 사용되는 대표적인 주소로는 **IP 주소**와 **MAC 주소**가 있음
- 주소를 바탕으로 다양한 수신지 유형을 지정해 패킷을 보낼 수 있음
- **유니캐스트**: 송신지와 수신지가 일대일로 메시지를 주고받는 전송 방식
- **브로드캐스트**: 네트워크상의 모든 호스트에게 메시지를 전송하는 전송 방식
  - **브로드캐스트 도메인**: 브로드캐스트가 전송되는 범위
  - 호스트가 같은 브로드캐스트 도메인에 속해 있는 경우 같은 LAN에 속해 있다고 간주
- **멀티캐스트**: 네트워크 내의 동일 그룹에 속한 호스트에게만 전송하는 방식
- **애니캐스트**: 네트워크 내의 동일 그룹에 속한 호스트 중 가장 가까운 호스트에게 전송하는 방식

## 두 호스트가 패킷을 주고받는 과정

- 호스트가 서로 주고받는 정보를 이해하기 위한 규칙인 프로토콜과 네트워크 참조 모델을 알아보고, 두 호스트가 패킷을 주고받는 과정 전반에 대해 이해하자

### 프로토콜

- **프로토콜**: 네트워크에서 통신을 주고받는 노드 간의 합의된 규칙이나 방법
- 패킷을 주고받는 호스트와 네트워크 장비들이 서로 주고받는 정보를 이해하려면 같은 프로토콜을 이해해야 하고, 같은 프로토콜로 통신해야 함
- 프로토콜의 종류
  - **IP**, **ARP**, ICMP, **TCP**, **UDP**, DHCP, DNS, **HTTP**, SSL/TLS, HTTPS
- 프로토콜마다 목적과 특징이 다름
  - IP: 네트워크 간의 주소를 지정한다는 목적
  - ARP: IP 주소와 MAC 주소를 대응시킨다는 목적
  - HTTPS: 보안상 HTTP에 비해 안전하다는 특징
  - TCP: UDP에 비해 신뢰성이 높다는 특징
- 패킷은 프로토콜의 목적과 특징에 따라 그에 맞는 패킷 헤더를 가짐 (프르토콜에 따라 패킷의 내용이 달라짐) 따라서 프로토콜의 목적과 특징을 이해하기 위해서는 프로토콜의 패킷 헤더를 분석해보면 좋음

  <img width="565" alt="Image" src="https://github.com/user-attachments/assets/65730efe-8f7b-467f-b5a5-d5567ddbc0be" />

### 네트워크 참조 모델

<img width="578" alt="Image" src="https://github.com/user-attachments/assets/8be9792b-2f10-4702-a670-34dcc8a8eb90" />

- 패킷을 주고받는 과정에는 정형화된 순서가 있고, 계층적으로 표현할 수 있음
- **네트워크 참조 모델**: 통신이 이루어지는 단계를 계층적으로 표현한 것
- 패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들임
- 네트워크 참조 모델에서 각각의 계층이 하는 일이 명확하게 정해져 있음
  - 계층별 목적에 맞는 프로토클과 장비를 구성하면 네트워크의 구성과 설계, 문제의 진단과 해결이 용이해짐
  - 대표적인 네트워크 참조 모델인 **OSI 모델**과 **TCP/IP 모델**에 대해 알아보자

#### OSI 모델

<img width="219" alt="Image" src="https://github.com/user-attachments/assets/db70636d-8481-4225-bf64-cfb1b39e8f8e" />

- 국제 표준화 기구에서 만든 네트워크 참조 모델
- 통신 단계를 7개의 계층으로 나눔
- 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층으로 구성돼 있음

##### 1. 물리 계층

- 가장 최하위 계층으로, 비트 신호를 주고 받는 계층
- 컴퓨터는 0과 1만을 이해할 수 있기 때문에 네트워크를 통해 주고받는 정보 또한 0과 1로 이루어진 신호로 구성됨
- 이러한 0과 1로 이루어진 신호를 유무선 통신 매체를 통해 운반하는 계층

##### 2. 데이터 링크 계층

- 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층
- 이를 위해 같은 네트워크에 속한 호스트를 식별할 수 있는 주소 MAC 주소를 사용함
- 물리 계층을 통해 주고받는 정보에 오류가 없는지 확인하기도 함
- 물리 계층과 데이터 링크 계층은 서로 밀접하게 연간돼 있으며, 하드웨어와 밀접하게 맞닿아 있는 계층임

##### 3. 네트워크 계층

- 네트워크 간 통신을 가능하게 하는 계층
- 데이터 링크 계층이 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위해 필요한 계층이라면, 네트워크 계층은 LAN을 넘어 다른 네트워크와 통신을 주고받기 위해 필요한 계층임
- 네트워크 간 통신 과정에서 호스트를 식별할 수 있는 주소(IP 주소)가 필요함
- 대표적 프로토콜: IP

##### 4. 전송 계층

- 네트워크를 통해 송수신되는 패킷은 전송 도중 유실될 때도 있고, 순서가 뒤바뀔 때도 있음
- 이러한 상황에 대비해 신뢰성 있는 전송을 가능하게 하는 계층
- '포트' 라는 정보를 통해 특정 응용 프로그램과의 연결 다리 역할을 수행하는 계층
- 대표적 프로토콜: TCP, UDP

##### 5. 세션 계층

- 응용 프로그램 간의 연결 상태를 의미하는 '세션'을 관리하기 위한 계층
- 응용 프로그램 간의 연결 상태를 유지하거나 새롭게 생성하고, 필요하다면 연결을 끊는 역할을 함

##### 6. 표현 계층

- 번역가와 같은 역할을 하는 계층
- 인코딩과 압축, 암호화와 같은 작업을 수행함
- 세션 계층과 표현 계층은 다른 계층과 달리, 두 계층을 명확하게 구분하지 않거나 응용 계층에 포함하여 간주하는 경우가 많음

##### 7. 응용 계층

- 사용자와 가장 밀접하게 맞닿아 있어 여러 네트워크 서비스를 제공하는 계층
- 대표적 프로토콜: HTTP, HTTPS, DNS

#### TCP/IP 모델

<img width="220" alt="Image" src="https://github.com/user-attachments/assets/e41eeffb-f7aa-4df7-ba1e-9c03c1ea2bde" />

- TCP/IP 4계층이라고도 불림
- 네트워크 액세스 계층, 인터넷 계층, 전송 계층, 응용 계층으로 구성돼있음
- OSI 모델은 네트워크의 이론적 기술을 목적으로 사용하는 반면, TCP/IP 모델은 구현과 프로토콜에 중점을 둔 네트워크 참조 모델임

##### 1. 네트워크 액세스 계층

- 링크 계층 또는 네트워크 인터페이스 계층이라고도 부름
- OSI 모델의 데이터 링크 계층과 유사

##### 2. 인터넷 계층

- OSI 모델의 네트워크 계층과 유사

##### 3. 전송 계층

- OSI 모델의 전송 계층과 유사

##### 4. 응용 계층

- OSI 모델의 세션 계층, 표현 계층, 응용 계층을 합친 것과 유사

### 캡슐화와 역캡슐화

<img width="572" alt="Image" src="https://github.com/user-attachments/assets/f0e51399-b610-4c10-aa7a-6ea46b8661a4" />

- 프로토콜과 네트워크 참조 모델을 토대로 이루어지는 패킷의 송수신 과정 중 송신 과정에서는 캡슐화가 이뤄지고, 수신 과정에서는 역캡슐화가 이뤄짐
- 각 계층에서는 어떤 정보를 송신할 때 상위 계층으로부터 내려받은 패킷을 페이로드로 삼아, 각 계층에 포함된 프로토콜에 따라 헤더 혹은 트레일러를 덧붙인 다음 하위 계층으로 전달함 즉, 상위 계층의 패킷이 하위 계층의 페이로드로 간주됨
- **캡슐화**: 송신 과정에서 헤더 및 트레일러를 추가해 나가는 과정
- **역캡슐화**: 캡슐화 과정에서 붙인 헤더 및 트레일러를 각 계층에서 확인한 뒤 제거하는 과정
- 각 계층에서 주고받는 패킷(정보)를 지칭하는 이름이 다름

    <img width="565" alt="Image" src="https://github.com/user-attachments/assets/5b133a42-3745-4577-acc5-432f6883b4cb" />

# 2. 물리 계층과 데이러 링크 계층

- 이더넷, 이더넷 프레임, 통신 매체, 네트워크 장비에 대해 알아보자

## 이더넷

- 물리 계층과 데이터 링크 계층에는 LAN 내의 호스트들이 올바르게 정보를 주고받을 수 있게 해주는 다양한 기술들이 이 있음
- **이더넷**: 통신 매체를 통해 신호를 송수신하는 방법, 데이터링크 계층에서 주고받는 데이터프레임 형식 등이 정의된 기술을 말함
- 현대 대부분의 유선 LAN은 이더넷을 기반으로 구현돼있음

### 이더넷 표준

- 이더넷은 IEEE 802.3이라는 이름으로 국제 표준화된 기술
- 서로 다른 네트워크 제조사의 장비여도 LAN 내의 모든 컴퓨터가 문제없이 호환되는 이유는 네트워크 장비들이 표준을 준수하여 제작되었기 때문임
- 1. 오늘날의 (유선)LAN 대부분이 이더넷 표준을 따르기 때문에 대다수의 LAN 장비들이 특정 이더넷 표준을 따름
- 2. 이더넷 표준이 달라지면 통신 매체의 종류를 비롯한 신호 송수신 방법, 나아가 최대 지원 속도도 달라질 수 있음
- 케이블, 허브, 스위치, NIC 등 다양한 네트워크 장비들 모두 특정 이더넷 표준을 이해하고 따름

### 이더넷 프레임

<img width="572" alt="Image" src="https://github.com/user-attachments/assets/973f4fbc-70c6-4d16-9fbd-c746a4cc3b3f" />

- **이더넷 프레임**: 이더넷 기반의 네트워크에서 주고받는 프레임
- 프리앰블, 수신지 MAC주소 등의 정보를 포함하고 있음

#### 1. 프리앰블

- **프리앰블**: 송수신지 동기화를 위해 사용되는 8바이트 크기의 정보
- 첫 7바이트는 10101010이라는 값을 가지고, 마지막 바이트는 10101011이라는 값을 가짐
- 프릴앰블 비트를 통해 현재의 이더넷 프레임이 수신되고 있다는 사실을 알아차리게 됨

#### 2. 송수신지 MAC 주소

- 프레임에서 가장 중요한 정보
- 송신지와 수신지를 특정할 수 있는 6바이트 길이의 MAC 주소
- 콜론(:) 으로 구분된 12자리 16진수로 구성돼 있음 `ab:cd:ab:cd:00:01`
- 네트워크 인터페이스마다 하나씩 부여됨
  - 네트워크 인터페이스: 컴퓨터나 기기가 네트워크와 연결되는 '출입구'로 보통 NIC라는 장치가 네트워크 인터페이스를 담당함
  - 네트워크 인터페이스가 여러개면 한 호스트가 여러 개의 MAC 주소를 가질 수 있음

#### 3. 타입/길이

- MAC 주소의 타입/길이 필드에 명시된 크기가 05DC(16) 이하이면 이 필드는 프레임의 크기를 나타내고, 0600(16) 이상이면 타입을 나타냄
- 타입은 캡슐화된 상위 계층의 정보를 의미하므로 어떤 상위 계층 프로토콜이 캡슐화되었는지 알 수 있음
  - ex) IP(IPv4)가 캡슐화된 정보를 운반하면 타입에는 0800(16)이 명시됨
  - ex) ARP 프로토콜이 캡슐화된 정보를 운반하면 타입에는 0806(16)이 명시됨

#### 4. 데이터

- 페이로드, 즉 상위 계층으로 전달하거나 전달받을 데이터가 명시됨
- 데이터 필드에 포함될 수 있는 데이터의 최대 크기가 일반적으로 **1500바이트** 이하로 제한돼있음, 이보다 큰 데이터를 보낼 경우에는 여러 패킷으로 나뉘어 보내짐
- 점보 프레임: 페이로드 크기로 1500바이트보다 더 큰 데이터를 포함할 수 있는 특별한 프레임

#### 5. FCS(Frame Check Sequence)

- **FCS**는 트레일러임
- 프레임의 오류가 있는지의 여부를 확인하기 위한 필드
- **CRC**라는 오류 검출용 값이 명시됨
- 송신지에서 전송할 데이터에 대한 CRC 값을 계산하여 보내면 수신지에서는 전달받은 데이터에 대한 CRC 값을 계산해, 그 값을 전달받은 CRC 값과 대조함. 두 값이 같으면 프레임에 오류가 없다고 판단함

## 유무선 통신 매체

- 물리 계층과 데이터 링크 계층에 속한 다양한 네트워크 하드웨어(통신 매체와 네트워크 장비)에 대해 알아보자
- 호스트가 아무리 빠르게 데이터를 처리할 수 있어도 이를 뒷받침하는 연결 매체의 성능이 안좋으면 호스트의 빠른 속도는 아무 효용이 없음

### 유선 매체 - 트위스티드 페어 케이블

<img width="557" alt="Image" src="https://github.com/user-attachments/assets/f77e5ab7-bbc4-4644-b65f-15c70daca052" />

- 두 가닥씩 꼬아져 있는 구리선을 통해 전기적으로 신호를 주고 받는 통신 매체
- 트위스티드 페어 케이블의 성능은 **카테고리**에 따라 다름
- 카테고리에 따라 대응되는 이더넷 표준이 다르고 그에따라 최대 지원 속도도 달라질 수 있음
- 오늘날 자주 사용되는 카테고리 종류는 아래와 같음

  | 특징      | Cat5    | Cat5e | Cat6  | Cat6a  | Cat7   | Cat8   |
  | --------- | ------- | ----- | ----- | ------ | ------ | ------ |
  | 전송 속도 | 100Mbps | 1Gbps | 1Gbps | 10Gbps | 10Gbps | 40Gbps |

<img width="537" alt="Image" src="https://github.com/user-attachments/assets/9fd0eb9f-b5cd-4114-80be-c66c76ba366f" />

- **노이즈**: 전기 신호에 왜곡을 줄 수 있는 주변 잡음
- **포일**: 그물 모양의 철사나 포일로 감싸 노이즈를 방지함
- **차폐**: 구리선 주변을 보호해 노이즈를 감소시키는 방식
- **브레이드 실드**: 차폐에 사용된 그물 모양의 철사
- **포일 실드** 차폐에 사용된 포일
- **STP(Shielded Twisted Pair)**: 브레이드 실드로 노이즈를 감소시킨 케이블
- **FTP(Foil Twisted Pair)**: 포일 실드로 노이즈를 감소시킨 케이블
- **UTP(Unshielded Twisted Pair)**: 아무것도 감싸지 않아 구리선만 있는 케이블
- 실드의 상세한 표기: [ ] / [ ] TP
  - 첫 번째 괄호는 케이블의 외부를 감싸는 실드 종류
  - 두 번째 괄호는 꼬아 놓은 구리선을 감싸는 실드의 종류
  - ex) S/FTP : 브레이드 실드로 케이블 외부를 보호하고, 포일 실드로 구리선을 감싼 케이블
  - ex) SF/FTP: 브레이드 실드와 포일 실드로 케이블 외부를 보호하고, 포일 실드로 구리선을 감싼 케이블

### 무선 매체 - 전파와 WIFI

#### 전파

- 전파는 약 3kHz부터 3THz 사이의 진동수를 갖는 전자기파를 의미
- 2.4GHz와 5GHz 두 진동수는 3kHz부터 3THz 사이에 속한 진동수로, 와이파이를 사용할 때 주로 활용됨

#### 와이파이

- 유선 LAN에서 가장 대중적으로 활용되는 기술이 이더넷이라면, 무선 LAN에서 가장 대중적으로 사용되는 기술은 **와이파이**
- 와이파이는 IEEE 802.11 표준을 따르는 무선 LAN 기술
- 표준에 따라 지원되는 최대 속도나 주파수 대역 등이 달라질 수 있음
- 와이파이 세대에 따라 지원되는 표준 규격이 달라 지원 가능한 최대 속도나 주파수 역시 달라짐

  | 세대 이름 | 표준 규격     |
  | --------- | ------------- |
  | Wi-Fi 7   | IEEE 802.11be |
  | Wi-Fi 6   | IEEE 802.11ax |
  | Wi-Fi 5   | IEEE 802.11ac |
  | Wi-Fi 4   | IEEE 802.11n  |

#### 채널

<img width="488" alt="Image" src="https://github.com/user-attachments/assets/f50c15bc-3a2a-4b84-b232-4a6d765a5fa4" />

- 와이파이에서 주로 사용되는 주파수 대역: 2.4GHz와 5GHz
- 같은 지역에서 주파수가 같은 무선 네트워크가 여러 개 존재하면 통신을 주고받을 때 신호 간섭이 발생할 수 있음
  - ex) 신호 간섭: 특정 지역에서 2개의 무전기가 같은 주파수를 사용할 경우, 다른 무전기 소리가 섞여 들릴 수 있음
- **채널**: 같은 대역을 사용하는 서로 다른 무선 네트워크를 구분하기 위해 채널이라는 하위 주파수 대역으로 세분화하고, 해당 채널 대역에서 무선 통신이 이루어짐
- 채널은 자동 설정되지만, 특정 채널을 사용하도록 수동으로 설정할 수도 있음
- 무선 네트워크의 성능 저하를 방지하려면 신호가 중첩되지 않는 채널을 사용하는 것이 중요함
  - 2.4GHz 대역 채널을 살펴보면 1,6,11번 채널의 주파수는 서로 중첩되지 않기 때문에 1,6,11번 채널을 사용하는 무선 네트워크는 아무리 많은 통신이 이뤄져도 신호 간섭으로 인한 성능 저하가 발생하지 않음
  - 반면 1,2,3번 채널을 사용하는 무선 네트워크는 신호가 중첩될 여지가 많아 자주 발생하는 신호 간섭으로 인해 성능이 현저히 저하될 수 있음

## 네트워크 인터페이스: NIC

- 네트워크 상에서 노드와 통신 매체가 연결되는 지점
- 네트워크 인터페이스마다 물리적 주소인 MAC 주소가 부여되고, NIC라는 하드웨어가 네트워크 인터페이스 역할을 함
- NIC: 네트워크 인터페이스 카드, 네트워크 어댑터, LAN 카드, 네트워크 카드 등 다양한 명칭으로 불리는 하드웨어
- 통신 매체의 신호를 호스트가 이해하는 프레임으로 변환하거나 호스트가 이해하는 프레임을 통신 매체의 신호로 변환하는 역할을 함
- 입출력장치와 다르지 않음. NIC를 작동시키는 시스템 콜이 호출되면 커널 모드로 전환된 뒤 송수신이 수행되고, 입출력이 완료되면 인터럽트를 통해 CPU에게 작업이 완료되었음을 알림

  <img width="557" alt="Image" src="https://github.com/user-attachments/assets/1af24d14-490e-4145-bcef-f936b0e60e10" />

## 허브와 스위치

- 허브와 스위치는 물리 계층과 데이터 링크 계층의 중간 노드
- 허브는 오늘날 잘 사용하지 않고 대신 스위치를 사용하는 경우가 많음

### 물리 계층의 허브

<img width="202" alt="Image" src="https://github.com/user-attachments/assets/92e56b6a-8d27-4d10-8d97-c0de7ba63183" />

- 허브는 물리 계층의 대표적인 네트워크 장비로, 여러 대의 호스트를 연결하는 장치임
- **리피터 허브**라고 부르기도 함, 이더넷 네트워크의 허브는 **이더넷 허브**라고 부르기도 함
- **포트**: 허브에서 케이블의 커넥터가 꽂히는 부분, 통신 매체를 연결하는 지점
- 중요한 특징

  <img width="424" alt="Image" src="https://github.com/user-attachments/assets/3eda7451-979c-419b-9a8e-b1b786eb8fc8" />

  1. 전달받은 신호를 모든 포트로 내보냄: 허브는 신호를 전달받으면 해당 신호에 대한 어떠한 조작이나 판단도 하지 않고, 모든 포트에 단순하게 신호를 내보냄
  2. 반이중 모드로 통신함: 송신 또는 수신을 번갈아 가면서 수행함 즉, 동시 송수신이 불가능함

- **반이중**: 동시에 송/수신 하는 것이 불가능
- **전이중**: 동시에 송/수신 하는 것이 가능

### 데이터 링크 계층의 스위치

<img width="572" alt="Image" src="https://github.com/user-attachments/assets/b928e32d-d952-4beb-bb7d-8e1ff931e0aa" />

- **스위치**: 허브의 한계를 보완하기 위한 네트워크 장비
- 전달받은 신호를 목적지 호스트가 연결된 포트로만 내보내고, 전이중 모드를 지원함

#### MAC 주소 학습

- 특정 포트에만 보낼 수 있는 이유: **MAC 주소 학습** 기능이 있기 때문
- **MAC 주소 테이블**: 스위치는 프레임 속 MAC 주소를 토대로 어떤 포트에 어떤 MAC 주소를 가진 호스트가 연결돼있는지 파악하고, `포트, 연결된 호스트의 MAC 주소` 의 대응 관계를 테이블 형태로 메모리에 저장함
- 즉, 스위치가 전달받은 신호를 목적지 호스트가 연결된 포트로만 내보낼 수 있는 이유는 MAC 주소 테이블을 생성하고 참조할 수 있기 때문임

#### VLAN

<img width="594" alt="Image" src="https://github.com/user-attachments/assets/3bcce825-0aaa-4b03-96f7-57c2919384ac" />

- **VLAN**: 가상의 LAN을 의미함, 같은 스위치에 연결된 모든 호스트를 하나의 네트워크로 간주하고 싶지 않을 때, 여러 논리적이 네트워크로 나누고 싶을 때 주로 사용됨
- 호스트 A~D와 호스트 E~I는 다른 VLAN에 속해 있으므로 서로 다른 네트워크로 간주되며, 브로드 캐스트 도메인도 겹치지 않아 VLAN1의 브로드캐스트 메시지가 VLAN2에 도달하지 않음
- 호스트 A~D와 호스트 E~I가 서로 통신을 주고받으려면 네트워크 계층 이상의 장비가 필요함

# 3. 네트워크 계층 - IP

- 물리 계층과 데이터 링크 계층에 속한 기술은 LAN을 위한 기술임
- LAN을 넘어서 다른 네트워크와 통신을 주고받으려면 네트워크 계층 이상의 기술이 필요함
- IP(Internet Protocol)은 이러한 네트워크 계층의 가장 핵심적인 프로토콜임

## IP의 목적과 특징

- IP의 목적: **주소 지정**, **단편화**
- 주소 지정: 네트워크 간의 통신 과정에서 호스트를 특정하는 것
- 단편화: 데이터를 여러 IP 패킷으로 올바르게 쪼개어 보내는 것
- IP 특징: **신뢰할 수 없는 통신**, **비연결형 통신**

### 주소 지정과 단편화

#### 주소 지정

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/75436d41-ac48-4a9d-a8d3-b2a0a4f47eb1" />

- 네트워크 간의 통신 과정에서 호스트를 특정하는 것
- 주소 지정은 IP 주소를 통해 이루어지며, IP 주소는 패킷 헤더의 **송신지 IP 주소**, **수신지 IP 주소**를 통해 알 수 있음
- 하나의 IP 주소는 총 4바이트의 크기로 구성되고, 숫자당 8비트로 표현되므로 0~255 범위의 10진수 4개로 표기됨
- **옥텟**: 각각의 진수는 점(.)으로 구분하는데, 점으로 구분된 하나의 10진수를 의미
  - ex) `192.168.0.1` 이라는 IP 주소에서 옥텟은 192, 168, 0, 1
- 오늘날의 IP는 IPv4, IPv6 두 종류가 있음
  - IPv4 주소는 총 2^32개의 주소가 할당 가능하기 때문에 부족하기 때문에 IPv6 등장함
  - IPv6 주소는 16바이트로 주소를 표현할 수 있기 때문에 2^128개의 주소가 할당 가능함
  - IPv6은 콜론(:)으로 구분된 8개 그룹의 16진수로 표기됨 `2001:0230:abcd:ffff:0000:0000:ffff:1111`

**라우터**

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/98ef7788-a138-49cb-9e6f-7963d21354b0" />

- 서로 다른 네트워크에 속한 두 호스트가 네트워크 간 통신을 할 때, IP 주소를 바탕으로 목적지까지 IP 패킷을 전달하는 네트워크 장비
- 네트워크 계층에 속한 장비로, 전달받은 패킷을 목적지까지 전달하는 역할을 함
- **라우팅**: IP 패킷을 전달할 최적의 경로를 결정하고 해당 경로로 패킷을 내보내는 과정

#### IP 단편화

<img width="587" alt="Image" src="https://github.com/user-attachments/assets/2d2d2d1a-9b1a-4824-bd4f-8a77a2a96dc9" />

- 데이터를 여러 IP 패킷으로 올바르게 쪼개어 보내는 것
- **MTU(Maximum Transmission Unit)**: 최대 전송 단위
  - 전송하고자 하는 IP 패킷(IP 헤더 + 페이로드)의 크기가 MTU 단위보다 클 경우 패킷을 여러 패킷으로 쪼개서 전송하고, 쪼개서 전송된 패킷들은 수신지에서 재조합됨
  - 일반적인 MTU 크기는 1500바이트임.
- IP 패킷에서 단편화와 관련된 필드: **식별자**, **플래그**, **단편화 오프셋**

**식별자**

- 특정 패킷이 어떤 데이터에서 쪼개진 패킷인지를 식별하기 위해 사용되는 필드
- 같은 정보엥서 쪼개진 패킷들은 같은 식별자를 공유하기 때문에 식별자를 통해 단편화되어 전송되는 패킷을 구분할 수 있음

**플래그**

<img width="528" alt="Image" src="https://github.com/user-attachments/assets/1f3d600a-c2a0-4bc4-ae77-6128583c58cd" />

- 3비트로 구성된 필드
- 첫 번째 비트를 제외한 나머지 2개의 비트는 각각 DF와 MF라는 이름이 붙어 있음
- 첫 번째 비트: 항상 0으로 설정되어 오늘날 사용되지 않음
- 두 번째 비트 DF: 'IP 단편화를 수행하지 말라' 는 표시를 남기기 위한 비트
- 세 번째 비트 MF: '단편화된 패킷이 더 있다'는 표시를 남기기 위한 비트

**단편화 오프셋**

- 특정 패킷이 초기 데이터에서 얼마나 떨어져 있는지가 명시된 필드
- 단편화되어 전송되는 패킷을 목적지에서 재조합하기 위해 패킷의 올바른 순서를 나타내는 데 사용됨

**IP 단편화 피하기 - 경로 MTU 발견**

<img width="380" alt="Image" src="https://github.com/user-attachments/assets/77ece947-65ad-406d-a48d-eec1d9147bcd" />

- 사실 오늘날의 네트워크 환경에서는 IP 단편화가 잘 발생하지 않음.
- 네트워크 성능의 발전, IP 단편화가 발생하지 않는 것이 좋기 때문
- 단편화된 패킷들이 많아지면 전송해야 할 패킷의 헤더들이 많아져서 불필요한 트래픽 증가와 대역폭 낭비를 초래하고, 단편화된 패킷을 재조립하는 과정에서 발생하는 부하도 성능 저하로 이어질 수 있음
- IP 단편화 피하는 방법: IP 패킷을 주고받는 경로에 존재하는 모든 호스트의 '처리 가능한 MTU 크기'를 고려하여, IP 단편화 없이 주고 받을 수 있는 최대 크기인 **경로 MTU**만큼 전송해야 함
- **경로 MTU 발견**: 주고받을 수 있는 경로 MTU를 구하고 해당 크기만큼만 송수신하여 IP 단편화를 피하는 기술
- 오늘날 네트워크에서는 대부분 경로 MTU 발견을 지원하고, 처리 가능한 최대 MTU 크기도 균일해서 IP 단편화 자주 발생하지 않음

> 애초에 보내야 하는 데이터 크기가 1500바이트가 넘으면?

### 신뢰할 수 없는 통신과 비연결형 통신

- IP는 신뢰할 수 없는 프로토콜이자, 비연결형 프로토콜임

#### 신뢰할 수 없는 프로토콜

- 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는 프로토콜
- 패킷이 유실되거나 목적지에 순서대로 전송하지 않아도 조치를 취하지 않음
- 신뢰할 수 없는 프로토콜의 송수신은 신뢰할 수 없는 통신, 신뢰성이 낮은 통신, **최선형 전달**이라고 부름

#### 비연결형 프로토콜

- 패킷을 주고받기 전에 사전 연결 과정을 거치지 않음
- 상대 호스트의 수신 가능 여부는 고려하지 않고, 수신지를 향해 그저 패킷을 전송함

## IP 주소의 구조

<img width="241" alt="Image" src="https://github.com/user-attachments/assets/cff390a0-1b80-4aaa-a450-4fccd78cddd6" />

<img width="344" alt="Image" src="https://github.com/user-attachments/assets/38daf81d-f597-496e-9630-a9446a80b313" />

- 0~255 범위의 10진수 4개로 표기되는 IP 주소는 네트워크 주소와 호스트 주소로 이루어져 있음
- **네트워크 주소**: 호스트가 속한 네트워크를 특정하기 위해 사용됨
  - 네트워크 ID, 네트워크 식별자 등으로 불림
- **호스트 주소**: 네트워크에 속한 호스트를 특정하기 위해 사용됨
  - 호스트 ID, 호스트 식별자 등으로 불림
- 하나의 IP 주소에서 네트워크 주소를 표현하는 크기와 호스트를 표현하는 크기는 유동적임
  - a는 호스트 주소에 24비트를 사용할 수 있어서, 네트워크당 많은 호스트에 IP 주소 할당 가능
  - c는 호스트 주소에 8비트를 사용할 수 있어서, 네트워크당 적은 호스트에 IP 주소 할당 가능

### 클래스풀 주소 체계

- IP 주소에서 네트워크 주소와 호스트 주소 구분 범위가 유동적이면 어느 정도가 적당할까?
  - 호스트 주소의 공간을 너무 크게 할당하면 호스트가 할당되지 않은 다수의 IP 주소가 낭비됨
  - 호스트 주소의 공간을 너무 작게 할당하면 호스트가 사용할 IP 주소가 부족해질 수 있음
- 이를 해결하기 위한 것이 IP 주소의 **클래스**임

**클래스**

- 네트워크의 크기에 따라 유형별로 IP 주소를 분류하는 기준
- 어떤 클래스에 속한 IP 주소인지 알면 IP 주소에서 네트워크 부분과 호스트 부분의 크기를 알 수 있음
- 클래스 종류: A, B, C, D, E

  - D, E: 멀티캐스트를 위한 클래스, 특수한 목적을 위해 예약된 클래스
  - A, B, C: 네트워크의 크기별로 IP 주소를 분류하는데 실질적으로 사용되는 클래스

**클래스풀 주소 체계**

- 클래스를 바탕으로 IP 주소를 관리하는 주소 체계

<img width="371" alt="Image" src="https://github.com/user-attachments/assets/c161ab1c-762c-48c4-a593-c36651e4e145" />

- A 클래스

  - 네트워크 주소는 비트 '0'으로 시작하며 1옥텟으로 구성됨
  - 호스트 주소는 3옥텟으로 구성됨
  - 상대적으로 가장 많은 호스트를 할당할 수 있는 클래스

- B 클래스

  - 네트워크 주소는 비트 '10'으로 시작해 2옥텟으로 구성됨
  - 호스트 주소도 2옥텟으로 구성됨

- C 클래스

  - 네트워크 주소는 비트 '110'으로 시작해 3옥텟으로 구성됨
  - 호스트 주소는 1옥텟으로 구성됨

- 클래스별 IP 주소의 표현 가능 범위

<img width="490" alt="Image" src="https://github.com/user-attachments/assets/0e96fd47-19bd-45d4-a802-bc44c6d981de" />

- 참고) 네트워크/브로드캐스트 주소와 예약 주소

  <img width="488" alt="Image" src="https://github.com/user-attachments/assets/583f95dd-501e-48c6-a57a-d731f099e2c6" />

  - 호스트의 주소 공간을 모두 사용할 수 있는 것은 아님
  - 호스트 주소가 전부 0인 IP 주소: 해당 네트워크 자체를 의미하는 주소로 사용됨
  - 호스트 주소가 전부 1인 IP 주소: 브로드캐스트를 위한 주소로 사용됨
  - 예약된 IP 주소

    <img width="509" alt="Image" src="https://github.com/user-attachments/assets/cce2cff0-223d-4794-8081-358072f41b99" />

### 클래스리스 주소 체계와 서브넷 마스크

- 클래스풀 주소 체계에서는 클래스별 네트워크 크기가 고정돼 있어서 고정된 크기 외에 다른 크기의 네트워크를 구성할 수 없어 IP 주소가 낭비될 수 있다는 한계가 있음
- **클래스리스 주소 체계**: 클래스를 이용하지 않고 네트워크와 호스트를 구분하는 방식
  - 클래스풀 주소 체계보다 더 정교하고 유동적으로 네트워크 영역을 나눌 수 있는 방법
  - 네트워크와 호스트를 구분하는 수단으로 서브넷 마스크 이용
- **서브넷 마스크**: IP 주소상에서 네트워크 주소를 1로 표기하고, 호스트 주소를 0으로 표기한 비트열

  - A 클래스: 255.0.0.0(11111111.00000000.00000000.00000000)
  - B 클래스: 255.255.0.0(11111111.11111111.00000000.00000000)
  - C 클래스: 255.255.255.0(11111111.1111111111111111.00000000)

- **서브네트워크(서브넷)**: IP 주소에서 네트워크 주소로 구분할 수 있는 네트워크의 부분집합
- **서브네팅**: 서브넷 마스크를 이용해 원하는 크기로 클래스를 잘게 쪼개 사용하는 것
- 서브넷 마스크와 IP 주소 간에 비트 AND 연산을 수행하면 IP 주소 내의 네트워크 주소를 알아낼 수 있음

  - IP 주소 162.168.200.102와 서브넷 마스크 255.255.255.0 => 네트워크 주소 192.168.200.0

    <img width="383" alt="Image" src="https://github.com/user-attachments/assets/aaf84b3d-9ad2-4ebc-8221-a03dccf4cee1" />

- 서브넷 마스크 표기법: **CIDR 표기**
  - `IP 주소/서브넷 마스크상의 1의 개수`
  - 192.168.20.3/30는 서브넷 마스크에서 1이 30개가 있다는 의미 -> 11111111.11111111.1111111.11111100(255.255.255.252)

> 그래서 실제로 클래스리스 주소 체계와 서브넷 마스크 사용해서 어떻게 유연하게 사용한다는거지?

## 공인 IP 주소와 사설 IP 주소

- 호스트의 IP 주소는 네트워크 설정이나 명령어를 통해 확인할 수 있음
  - 윈도우: ipconfig/all
  - 맥OS, 리눅스: ifconfig
- 온라인 검색을 통해서도 확인할 수 있음
  - 'what is my ip address'로 검색
- 두 가지 방식으로 확인한 IP 주소가 다를 수 있음

### 공인 IP 주소

<img width="380" alt="Image" src="https://github.com/user-attachments/assets/f47e030e-422b-43fa-bf17-7c784ab99287" />

- 전 세계에서 고유한 IP 주소
- 인터넷을 비롯한 네트워크 간 통신에서 사용되는 IP
- 검색 사이트를 통해 확인했던 IP 주소
- 검색 사이트의 서버와 패킷을 주고받으려면 호스트가 속한 네트워크의 공인 IP 주소를 사용해야 하기 때문
- 공인 IP 주소는 ISP나 공인 IP 주소 할당 기관을 통해 할당받을 수 있음

### 사설 IP 주소

- 사설 네트워크에서 사용하기 위한 IP 주소
- 외부 네트워크에 공개되지 않은 네트워크
- 일반적으로 라우터(공유기)를 통해 할당되기 때문에 공유기(라우터)를 중심으로 구성된 LAN 대부분은 사설 네트워크에 해당됨
- 사설 IP 주소로 사용하도록 특별히 예약된 IP 주소 공간이 있음
  - 10.0.0.0/8 (10.0.0.0 ~ 10.255.255.255)
  - 172.16.0.0/12 (172.16.0.0 172.31.255.255)
  - 192.168.0.0/16 (192.168.0.0 ~ 192.168.255.255)

## IP 주소의 할당(사설 IP 주소 할당)

- 호스트에 IP 주소를 할당하는 방법을 알아보자

### 정적 할당

<img width="572" alt="Image" src="https://github.com/user-attachments/assets/76559ee0-f320-4dd3-8019-21e1b46f3dd5" />

<img width="328" alt="Image" src="https://github.com/user-attachments/assets/c970149e-86f4-4b62-9287-4837dd1121fd" />

- 수작업으로 IP 주소를 부여하는 방식
- **정적 IP 주소**: 정적 할당을 통해 할당된 IP 주소
- IP 주소, 서브넷 마스크, 게이트웨이(라우터) 주소, DNS 주소 등 필요
- **게이트웨이**: 서로 다른 네트워크를 연결하는 하드웨어적/소프트웨어적 수단
- **기본 게이트웨이**: 호스트가 속한 네트워크의 외부로 나가기 위한 첫 기본 경로, 네트워크 외부와 연결된 라우터(공유기)의 주소를 의미하는 경우가 많음
- **DNS 주소**: 호스트가 도메인 네임을 토대로 IP 주소를 알아내기 위해 질의하는 서버의 주소

### 동적 할당

- 프로토콜을 통해 자동으로 IP 주소를 부여하는 방식
- **동적 IP 주소**: 동적 할당을 통해 할당된 IP 주소
- 호스트에 수동으로 직접 IP 주소를 할당하지 않고도 호스트에 IP 주소가 부여되어 있다면 IP 주소가 동적으로 할당되었기 때문임
- **DHCP(Dynamic Host Configuration Protocol)** 프로토콜: 호스트에 할당 가능한 IP 주소 목록을 관리하다가, IP 주소 할당 요청을 받았을 때 IP 주소를 할당해 주는 호스트
- 일반적으로 라우터(공유기)가 DHCP 서버 역할을 수행함
- 특징
  1. 동적 IP 주소에는 사용 가능한 기간(임대 기간)이 정해져 있음
  2. 동적 IP 주소는 할당받을 때마다 다른 주소를 받을 수 있음
- DHCP로 할당받은 IP 주소는 사용할 기간이 정해져 있고, 사용되지 않을 경우 회수됨
- 사용 기간이 끝난 IP 주소는 DHCP 서버로 반납되고, 새롭게 IP 주소를 할당받는 경우 다른 IP 주소를 할당받을 수 있음
- DHCP를 통한 IP 주소의 동적 할당은 이런 점에서 'IP 주소의 임대' 라고도 표현함
- **임대 갱신**: IP 주소의 임대 기간이 끝나기 전에 임대 기간을 연장하는 것, 기본적으로 자동으로 두 차례 수행되고, 두 번의 임대 갱신 모두 실패하면 IP 주소가 DHCP 서버로 반납됨

## IP 전송 특징의 보완: ICMP(Internet Control Message Protocol)

### IP의 전송 특징

- IP의 신뢰할 수 없는 전송과 연결을 수립하지 않는 전송은 성능 측면으로 봤을 때 반드시 나쁜 것은 아님
  - 신뢰성 높은 송수신, 연결형 송수신을 위해서는 매번 점검, 오류 제어, 연결 관리 등이 필요한데 많은 시간과 대역폭, 부하가 필요하기 때문에 성능에 불리하게 작용할 수 있음
  - 따라서 IP의 신뢰할 수 없는 비연결형 전송이라는 특징은 반드시 극복해야할 단점은 아님
- IP의 신뢰할 수 없는 비연결형 통신이라는 특징을 보완해야 할 때가 있기는 함
  - 방법 1. 신뢰할 수 있는 연결형 통신을 지원하는 상위 계층 프로토콜 사용
  - 방법 2. 네트워크 계층의 ICMP 프로토콜 사용

### ICMP

<img width="343" alt="Image" src="https://github.com/user-attachments/assets/dd37d74a-67da-4de3-9bc5-55dc437ff47f" />

- IP의 '신뢰할 수 없는 프로토콜', '비연결형 프로토콜' 이라는 특징을 보완하기 위한 프로토콜
- IP 패킷의 전송 과정에 대한 피드백 메시지(ICMP 메시지)를 얻기 위해 사용하는 프로토콜
- ICMP 메시지를 통해 패킷이 상대방에게 어떻게 전송됐는지 알려줄 수 있어 IP 전송의 결과를 알 수 있음
- 유의: ICMP가 IP의 신뢰성을 완전히 보장하지는 않음 (완전히 보장하려면 전송 계층 프로토콜 필요)
- ICMP 메시지는 1. 전송 과정에서 발생한 오류 보고, 2. 네트워크에 대한 진단 정보로 유형을 나눌 수 있음

  <img width="468" alt="Image" src="https://github.com/user-attachments/assets/1c5b952e-05c9-4899-967e-9ff3cc4139c7" />

- **네트워크 도달 불가**: 네트워크 장비 가령 라우터가 패킷을 전달받았는데, 어떤 네트워크로 전송해야할 지 알 수 없는 경우 되돌려 보내지는 ICMP 메시지
- **단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음**: 처리하기에 너무 큰 패킷을 전달받았는데, DF 플래그가 설정돼있어 단편화가 불가능한 경우 되돌려 보내지는 ICMP 메시지
- **시간 초과**: IP 헤더의 패킷의 수명을 의미하는 TTL(Time To Live) 필드가 라우터를 거치면서 0이 되면 패킷은 폐기되고, 패킷을 송신한 호스트에게 되돌려 보내지는 ICMP 메시지

  <img width="530" alt="Image" src="https://github.com/user-attachments/assets/604bf2d6-38bf-49c0-8097-a0eb3e406c27" />

  - 패킷이 하나의 라우터를 거칠 때마다 TTL이 1씩 감소함
  - **홉**: 패킷이 호스트 또는 라우터에 한 번 전달되는 것
  - 즉, 홉마다 TTL 필드의 값이 1씩 감소함
  - TTL 필드의 존재 이유: 무의미한 패킷이 네트워크상에 지속적으로 남아있는 것을 방지하기 위함

- ICMP 메시지는 네트워크상의 간단한 문제를 진단하고 테스트하기 위해 사용되기도 함
  - traceroute 또는 tracert: 네트워크 상의 경로 확인하는 명령어
  - ping: 네트워크 상태 점검하기 위한 패킷 송신 명령어

## IP 주소와 MAC 주소의 대응: ARP

- 상대의 IP 주소는 알고, MAC 주소는 모를 때 사용되는 프로토콜
- **ARP**: IP 주소와 MAC 주소를 함께 활용하는 통신 과정에서 동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아내는 프로토콜
- IP 주소를 통해 MAC 주소를 알아내는 과정은 ARP 요청 메시지와 ARP 응답 메시지를 통해 이루어짐
- **ARP 요청 메시지**: 알고 싶은 MAC 주소에 대응되는 IP 주소 포함돼있음
  - 1. 브로드캐스트 메시지여서 네트워크 내에 있는 모든 호스트에게 보내짐
  - 2. 호스트들은 IP 주소를 확인하고 자신과 관련 없으면 무시, 자신의 IP 주소이면 ARP 응답 메시지 전송함
  - 3. ARP 요청 메시지를 보낸 호스트가 ARP 응답 메시지를 수신하면 IP에 대한 MAC 주소를 알게됨
  - 4. 매번 브로드캐스트(ARP 요청) 메시지 보내는 것을 피하기 위해 송신한 호스트에서는 알게된 `<IP 주소, MAC 주소>` 쌍을 기억해둠
- **ARP 테이블**: `<IP 주소, MAC 주소>` 의 항목들로 구성된 표 형태의 정보
  - 각 항목은 일정 시간이 지나면 삭제되고, 임의로 삭제할 수도 있음

> 데이터 링크 계층은 MAC 기반으로 동작하기 때문에 MAC으로 변환해줘야함

# 4. 전송 계층 - TCP와 UDP

## TCP와 UDP의 목적과 특징

### 포트를 통한 프로세스 식별

- IP 주소와 MAC 주소는 호스트를 특정할 수 있지만 패킷의 최종 송수신 대상은 '호스트가 실행하는 프로세스'임
- **포트**번호 를 통해 호스트가 실행하는 프로세스를 식별할 수 있음
- 즉 IP 주소와 포트 번호의 조합을 통해 '특정 호스트가 실행하는 특정 프로세스'를 식별할 수 있음
- `IP 주소: 포트 번호` 형태

  <img width="334" alt="Image" src="https://github.com/user-attachments/assets/0dca53dc-50b4-4082-a1a3-37a4876ed048" />

- TCP/UDP 헤더에는 송신지 포트 번호와 수신지 포트 번호를 포함함

  <img width="569" alt="Image" src="https://github.com/user-attachments/assets/5ce23d17-8213-4258-8329-34c28f2151b7" />

#### 포트 번호

- 포트 번호는 16비트를 차지하므로 2^16 = 65536개(0~65535) 표현할 수 있음
- 포트 번호는 범위에 따라 3가지 종류로 나뉨

  | 포트 종류      | 포트 번호 범위 |
  | -------------- | -------------- |
  | 잘 알려진 포트 | 0 ~ 1023       |
  | 등록된 포트    | 1024 ~ 49151   |
  | 동적 포트      | 49152 ~ 65535  |

**잘 알려진 포트**: 가장 대중적으로 사용되는 애플리케이션을 위한 포트 번호, 프로토콜이 주로 사용하는 포트 번호 목록

| 잘 알려진 포트 번호 | 설명   |
| ------------------- | ------ |
| 20, 21              | FTP    |
| 22                  | SSH    |
| 23                  | TELNET |
| 53                  | DNS    |
| 67, 68              | DHCP   |
| 80                  | HTTP   |
| 443                 | HTTPS  |

**등록된 포트**: 흔히 사용되는 애플리케이션에 주로 사용하는 포트 번호

| 등록된 포트 번호 | 설명                              |
| ---------------- | --------------------------------- |
| 1194             | OpenVPN                           |
| 1433             | Microsoft SQL Server 데이터베이스 |
| 3306             | MySQL 데이터베이스                |
| 6379             | Redis                             |
| 8080             | HTTP 대체                         |

**동적 포트**

- 사설 포트 또는 임시 포트라고도 함
- 비교적 자유롭게 사용 가능
- 보통 서버 프로그램은 잘 알려진 포트나 등록된 포트가 할당되지만 클라이언트 프로그램같은 경우 동적 포트가 할당되는 경우가 많음

**NAT(Network Address Translation)와 NAPT()**

- NAT: 공인 IP와 사설 IP 간의 변환에 사용되는 기술

  <img width="518" alt="Image" src="https://github.com/user-attachments/assets/dc9ebb9a-0302-49e4-8df4-8601f8e09074" />

  - 대부분의 라우터와 공유기는 NAT 기능을 내장하고 있음

- NAPT: IP 주소 변환 과정에서 변환할 IP 주소의 쌍과 더불어, 포트 번호도 함께 고려하는 포트 기반의 NAT

  <img width="526" alt="Image" src="https://github.com/user-attachments/assets/8d153ddd-8496-4a23-a122-6d00c44ddd61" />

  - 하나의 공유 IP에서 다수의 사설 IP가 사용되는데, 사설 IP 주소가 같은 공인 IP 주소로 변환되더라도 다른 포트 번호로 변환되면 네트워크 내부의 호스트를 특정할 수 있음
  - NAT의 한 종류

### (비)신뢰성과 (비)연결형 보장

<img width="410" alt="Image" src="https://github.com/user-attachments/assets/0c560a17-1381-4a45-a4e3-97faf8857617" />

- 신뢰할 수 있는 연결형 송수신에는 시간과 연산이 소요되기 때문에 일반적으로 TCP가 UDP에 비해 송수신 속도가 느림
- 패킷의 유실 없는 송수신을 원하면 UDP보다 TCP를 선택하는 것이 유리, 비교적 빠른 송수신을 원한다면 TCP보다 UDP를 선택하는 것이 유리

#### UDP 헤더

<img width="277" alt="Image" src="https://github.com/user-attachments/assets/6d062c86-f325-4d7b-9ec0-c3a5c150456e" />

- **송신지 포트**: 송신 프로세스가 할당된 포트 번호
- **수신지 포트**: 수신 프로세스가 할당된 포트 번호
- **길이**: 헤더를 포함함 UDP 패킷(데이터그램)의 바이트 크기
- **체크섬**: 송수신 과정에서의 데이터그램 훼손 여부를 알 수 있는 정보

#### TCP 헤더

<img width="268" alt="Image" src="https://github.com/user-attachments/assets/0aec12e5-7cd6-4b78-9c13-5aeb28bb22af" />

- **순서 번호**: TCP 패킷(세그먼트)의 올바른 송수신 순서를 보장하기 위한 번호
  - 송수신하고자 하는 데이터의 몇번째 바이트에 해당하는지 알 수 있음
- **확인 응답 번호**: 상대 호스트가 보낸 세그먼트에 대한 응답, 다음으로 수신하길 기대하는 순서 번호

  - 일반적으로 '올바르게 수신한 순서 번호에 1이 더해진 값'으로 설정됨

  <img width="308" alt="Image" src="https://github.com/user-attachments/assets/5266660b-741c-4316-b45e-db75809f8790" />

- **제어 비트**: 세그먼트에 대한 부가 정보를 나타내난 정보, 플래그 비트라고도 부름
  - 8비트로 구성되며, 각 자리의 비트가 각기 다른 의미를 가짐
  - ACK: 세그먼트의 승인을 나타내기 위한 비트
  - SYN: 연결을 수립하기 위한 비트
  - FIN: 연결을 종료하기 위한 비트

## TCP의 연결부터 종료까지

### TCP의 연결 수립

- 3way handshake를 통해 이루어짐

**단계**

<img width="357" alt="Image" src="https://github.com/user-attachments/assets/a1cbe147-3fc2-45ae-b617-add439b44acf" />

<img width="295" alt="Image" src="https://github.com/user-attachments/assets/03886f74-1d49-42b2-b5f5-c6f247086ed8" />

1. [송수신 방향 A -> B] SYN 세그먼트 전송

- 호스트 A는 SYN 비트가 1로 설정된 세그먼트를 호스트 B에게 전송
- 이때 세그먼트의 순서 번호에는 호스트 A에서 보내는 패킷에 대한 순서 번호가 포함돼있음

2. [송수신 방향 B -> A] SYN + ACK 세그먼트 전송

- 1에 대한 호스트 B의 응답
- 호스트 B는 ACK 비트와 SYN 비트가 1로 설정된 세그먼트를 호스트 A에게 전송함
- 세그먼트의 순서 번호에는 호스트 B에서 보내는 패킷에 대한 순서 번호와 1에서 보낸 세그먼트에 대한 확인 응답 번호가 포함돼 있음

3. [송수신 방향 A -> B] ACK 세그먼트 전송

- 호스트 A는 ACK 비트가 1로 설정된 세그먼트를 호스트 B에게 전송
- 세그먼트의 순서 번호에는 호스트 A의 순서 번호와 2에서 보낸 세그먼트에 대한 확인 응답 번호가 포함돼 있음

**액티브 오픈**

- 처음 연결을 시작하는 과정
- 서버 - 클라이언트에서 보통 클라이언트에 의해 액티브 오픈이 수행됨

**패시브 오픈**

- 연결 요청을 수신한 뒤 그에 대한 연결을 수립하는 과정
- 서버 - 클라이언트에서 보통 서버에 의해 수행됨

### TCP의 오류/흐름/혼잡 제어

- TCP는 송수신하는 패킷의 신뢰성을 보장하고 위해 오류 제어, 흐름 제어, 혼잡 제어 기능을 제공함
- 재전송을 기반으로 다양한 오류를 제어
- 송수신의 흐름을 제어해 처리할 수 있을 만큼의 데이터만 주고받음
- 혼잡 제어를 통해 네트워크의 혼잡 정도에 따라 데이터의 전송량 조절

#### 1. 재전송을 통한 오류 제어

- TCP는 송수신 과정에서 잘못 전송된 세그먼트가 있을 경우, 이를 재전송하여 오류를 제어함
- TCP가 잘못 전송된 세그먼트가 있음을 인지하는 상황

  1. 중복된 ACK 세그먼트가 도착했을 때

  <img width="586" alt="Image" src="https://github.com/user-attachments/assets/7cdf8426-1743-464f-b3d7-06e9bce4dae5" />

  2. 타임아웃이 발생했을 때

  <img width="332" alt="Image" src="https://github.com/user-attachments/assets/338ce844-dd69-4d05-ac8d-3e511da4bbe8" />

  - TCP 세그먼트를 송신하는 호스트는 모두 **재전송 타이머** 값을 가짐
  - 호스트 세그먼트를 전송할 때마다 이 재전송 타이머가 시작되며, 타이머가 끝난 상황을 **타임 아웃**이라고 함
  - 타임아웃 발생 시점까지 ACK 세그먼트를 받지 못하면 세그먼트 전송 과정에 문제가 발생했다고 간주해 세그먼트를 재전송함

**파이프라이닝 전송**

<img width="339" alt="Image" src="https://github.com/user-attachments/assets/b1ef6bc7-2b21-4b69-b8bf-f063508b18f8" />

- '세그먼트 전송, 확인 응답 받기, 다음 순서번호 담은 세그먼트 전송' 의 과정은 한 번에 여러 세그먼트를 보낼 수 있는 상황에서도 확인 응답을 받기 전까지는 보낼 수 없다는 단점이 있음
- **파이프라이닝**: 확인 응답을 받기 전이라도 여러 메시지를 보내는 방식으로 송신하는 것

#### 2. 흐름 제어

- **흐름 제어**: 수신 호스트가 한 번에 받아 처리할 수 있을 만큼만 전송하는 것
- 수신 호스트가 한 번에 받을 수 있는 전송량은 TCP 수신 버퍼의 크기에 의해 결정됨, 수신 버퍼는 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시 저장되는 공간으로, 커널에 정의돼 있음
- 수신 호스트가 한 번에 받아 처리할 수 있는 양 어떻게 아는가: TCP 헤더의 윈도우 필드에 수신 호스트가 한 번에 처리할 수 있는 **수신 윈도우** 크기가 명시됨

#### 3. 혼잡 제어

- **혼잡**: 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황
- **혼잡 제어**: 혼잡을 제어하기 위한 기능
- 송신 호스트에서 네트워크가 혼잡함을 인지하는 상황
  1. 중복된 ACK 세그먼트가 도착했을 때
  2. 타임아웃이 발생했을 때
- 네트워크의 혼잡 가능성을 검출한 송신 호스트는 '혼잡 없이 전송할 수 있을 정도의 양'만큼만 송신함
- **혼잡 윈도우**: 혼잡 없이 전송할 수 있을 정도의 양
- 혼잡 윈도우가 크면 한 번에 전송할 수 있는 세그먼트의 수가 많음을 의미, 작으면 네트워크가 혼잡한 상황이므로 한 번에 전송할 수 있는 세그먼트의 수가 적음을 의미

**혼잡 제어 알고리즘**

- 혼잡 윈도우의 크기는 송신 호스트가 직접 계산해서 알아내야함
- 가장 대표적인 혼잡 제어 알고리즘: AIMD
- **AIMD(Additive Increase/Multiplicative Decrease)**: 합으로 증가 곱으로 감소

  <img width="317" alt="Image" src="https://github.com/user-attachments/assets/bece221c-dd45-4c9e-9923-b08ea3445cee" />

  - 세그먼트를 보내고 나서 혼잡이 감지되지 않으면 RTT마다 혼잡 윈도우를 1씩 선형적으로 증가시키고 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨림

- **RTT(Round Trip Time)**: 패킷을 보내고 그에 대한 응답이 수신되기까지의 시간

### TCP의 종료

- 4way handshake 방식

**단계**

<img width="389" alt="Image" src="https://github.com/user-attachments/assets/a4757b34-af82-4bb9-9aa6-65f29394aef1" />

1. [송수신 방향 A -> B] FIN 세그먼트

- 호스트 A는 FIN 비트가 1로 설정된 FIN 세그먼트를 호스트 B에게 전송

2. [송수신 방향 B -> A] ACK 세그먼트

- 1에 대한 호스트 B의 응답, 호스트 B는 ACK 세그먼트를 호스트 A에게 전송

3. [송수신 방향 B -> A] FIN 세그먼트

- 호스트 B는 FIN 세그먼트를 호스트 A에게 전송

4. [송수신 방향 A -> B] ACK 세그먼트

- 3에 대한 호스트 A의 응답, 호스트 A는 ACK 세그먼트를 호스트 B에게 전송

**액티브 클로즈**

- 연결을 종료하려는 호스트에 의해 수행되는 동작

**패시브 클로즈**

- 연결 종료 요청을 받아들이는 호스트에 의해 수행되는 동작

## TCP의 상태 관리

<img width="521" alt="Image" src="https://github.com/user-attachments/assets/923e300b-3063-4c74-8940-d2812d6378b9" />

<img width="461" alt="Image" src="https://github.com/user-attachments/assets/3bd66246-bc56-4e42-abdb-690f8374b943" />

- TCP의 중요한 특징: 상태를 유지함
- TCP는 상태를 유지하고 관리하는 프로토콜이라는 점에서 **스테이트풀 프로토콜**이라고도 부름
- TCP에서의 **상태**: 현재 어떤 통신 과정에 있는지를 나타내는 정보
- TCP에는 다양한 상태가 존재하고, 호스트는 TCP를 통한 송수신 과정에서 다양한 상태를 오가게됨

### 연결이 수립되지 않았을 때 주로 활용되는 상태

| 상태   | 설명                                                                          |
| ------ | ----------------------------------------------------------------------------- |
| CLOSED | 아무런 연결이 없는 상태                                                       |
| LISTEN | 연결 대기 상태(서버 쪽에 핸드셰이크의 첫 단계인 SYN 세그먼트를 대기하는 상태) |

- 패시브 오픈 호스트는 일반적으로 항상 LISTEN 상태로써 연결 요청(SYN)을 기다림

### 연결 수립 과정에서 주로 활용되는 상태

<img width="435" alt="Image" src="https://github.com/user-attachments/assets/2ac89ff0-2d6a-4566-a6a7-67784d460c5c" />

| 상태         | 설명                                                                                                             |
| ------------ | ---------------------------------------------------------------------------------------------------------------- |
| SYN-SENT     | 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤, 그에 대한 응답인 SYN + ACK 세그먼트를 기다리는 상태(연결 요청 전송) |
| SYN-RECEIVED | 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤, 그에 대한 ACK 세그먼트를 기다리는 상태(연결 요청 수신)        |
| ESTABLISHED  | 쓰리 웨이 핸드셰이크가 끝난 뒤 데이터를 송수신할 수 있는 상태(연결 수립)                                         |

### 연결 종료 과정에서 주료 활용되는 상태

<img width="443" alt="Image" src="https://github.com/user-attachments/assets/1ce4e881-15bb-44df-8ad1-d6afbf81708d" />

| 상태       | 설명                                                                                                                    |
| ---------- | ----------------------------------------------------------------------------------------------------------------------- |
| FIN-WAIT-1 | 액티브 클로즈 호스트가 FIN 세그먼트로 연결 종료 요청을 보낸 상태(연결 종료 요청 전송)                                   |
| CLOSE-WAIT | FIN 세그먼트를 받은 패시브 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태(연결 종료 요청 승인) |
| FIN-WAIT-2 | FIN-WAIT-1 상태에서 ACK 세그먼트를 받은 상태                                                                            |
| LAST-ACK   | CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 대기하는 상태                                                              |
| TIME-WAIT  | 액티브 클로즈 호스트가 마지막 ACK 세그먼트를 전송한 뒤 잠어드는 상태                                                    |

- 액티브 클로즈 호스트가 ACK을 보낸 뒤 TIME-WAIT 상태에서 일정 시간 뒤 CLOSED 상태가 되는 이유: 마지막 ACK 세그먼트가 올바르게 전송되지 않았을 경우 재전송이 필요하기 때문
