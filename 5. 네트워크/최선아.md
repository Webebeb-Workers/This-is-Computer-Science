# 1. 네트워크의 큰 그림

## 네트워크의 기본 구조

<img width="507" alt="Image" src="https://github.com/user-attachments/assets/acfb1b4e-0524-4c29-b99e-c899337ddc71" />

- 네트워크는 노드(네트워크 기기)와 간선(유무선 통신 매체)으로 이루어진 그래프 형태
- 네트워크 상에서 노드와 노드 사이의 연결 구조는 **네트워크 토폴로지**라고 부름
- 노드가 어떻게 연결/배치 되느냐에 따라 망형, 트리형, 링형 등의 유형으로 나눌 수 있음

  <img width="549" alt="Image" src="https://github.com/user-attachments/assets/b332b2c3-33dd-4f21-9e6a-a8b024fcea32" />

- **호스트**: 네트워크를 통해 주고받는 정보를 최초로 송신/수신하는 노드
  - ex) 노트북의 웹 브라우저를 통해 구글 홈페이지에 접속했다면 노트북과 구글 서버 컴퓨터가 호스트임
  - **클라이언트**: 요청을 보내는 호스트
  - **서버**: 응답을 보내는 호스트
  - 클라이언트와 서버는 주고받는 정보의 방향(요청과 응답)에 따라 부여된 역할
- **중간 노드**: 네트워크 그래프에서 중간에 위치한 노드, 호스트가 주고받는 정보들을 원하는 수신지까지 안정적으로 전송하는 역할을 함
  - ex) 스위치, 라우터, 공유기

### LAN과 WAN

- 네트워크는 규모에 따라 LAN과 WAN으로 나뉨
- **LAN**
  - 근거리 네트워크를 의미
  - 가정이나 기업처럼 비교적 가까운 거리를 연결하는 한정된 공간에서의 네트워크를 말함
- **WAN**
  - 원거리 네트워크를 의미
  - WAN을 통해 LAN 간 통신이 이루어짐
  - 인터넷을 가능하게 만드는 네트워크
  - ISP(Internet Service Provider)라는 인터넷 서비스 업체가 구축하고 관리함
    - ex) KT, LG 유플러스, SK브로드밴드

### 패킷 교환 네트워크

- 네트워크를 통해 주고받는 데이터는 한 번에 송수신되지 않고, 여러 데이터로 쪼개져서 송수신됨
- **패킷**: 네트워크를 통해 송수신되는 데이터의 단위
- **패킷 교환 네트워크**: 패킷 단위로 주고받는 정보를 쪼개서 송수신하고 수신지에서 재조립하여 패킷을 주고받는 네트워크, 오늘날의 대부분의 네트워크
- 하나의 패킷은 **페이로드**와 **헤더**로 구성되어 있음, 때로는 **트레일러**라는 정보가 포함되기도 함
- **페이로드**: 패킷에서 송수신하고자 하는 데이터
- **헤더**, **트레일러**: 패킷에 추가되는 부가 정보

> 트레일러 정보는 예를 들어 뭐가 있을까

### 주소의 개념과 전송 방식

- 네트워크 상의 두 호스트가 올바르게 정보를 주고받기 위해서는 서로를 특정할 수 있는 정보, 즉 주소가 필요함
- **주소**: 패킷의 헤더에 명시되는 정보, 네트워크에서 사용되는 대표적인 주소로는 **IP 주소**와 **MAC 주소**가 있음
- 주소를 바탕으로 다양한 수신지 유형을 지정해 패킷을 보낼 수 있음
- **유니캐스트**: 송신지와 수신지가 일대일로 메시지를 주고받는 전송 방식
- **브로드캐스트**: 네트워크상의 모든 호스트에게 메시지를 전송하는 전송 방식
  - **브로드캐스트 도메인**: 브로드캐스트가 전송되는 범위
  - 호스트가 같은 브로드캐스트 도메인에 속해 있는 경우 같은 LAN에 속해 있다고 간주
- **멀티캐스트**: 네트워크 내의 동일 그룹에 속한 호스트에게만 전송하는 방식
- **애니캐스트**: 네트워크 내의 동일 그룹에 속한 호스트 중 가장 가까운 호스트에게 전송하는 방식

## 두 호스트가 패킷을 주고받는 과정

- 호스트가 서로 주고받는 정보를 이해하기 위한 규칙인 프로토콜과 네트워크 참조 모델을 알아보고, 두 호스트가 패킷을 주고받는 과정 전반에 대해 이해하자

### 프로토콜

- **프로토콜**: 네트워크에서 통신을 주고받는 노드 간의 합의된 규칙이나 방법
- 패킷을 주고받는 호스트와 네트워크 장비들이 서로 주고받는 정보를 이해하려면 같은 프로토콜을 이해해야 하고, 같은 프로토콜로 통신해야 함
- 프로토콜의 종류
  - **IP**, **ARP**, ICMP, **TCP**, **UDP**, DHCP, DNS, **HTTP**, SSL/TLS, HTTPS
- 프로토콜마다 목적과 특징이 다름
  - IP: 네트워크 간의 주소를 지정한다는 목적
  - ARP: IP 주소와 MAC 주소를 대응시킨다는 목적
  - HTTPS: 보안상 HTTP에 비해 안전하다는 특징
  - TCP: UDP에 비해 신뢰성이 높다는 특징
- 패킷은 프로토콜의 목적과 특징에 따라 그에 맞는 패킷 헤더를 가짐 (프르토콜에 따라 패킷의 내용이 달라짐) 따라서 프로토콜의 목적과 특징을 이해하기 위해서는 프로토콜의 패킷 헤더를 분석해보면 좋음

  <img width="565" alt="Image" src="https://github.com/user-attachments/assets/65730efe-8f7b-467f-b5a5-d5567ddbc0be" />

### 네트워크 참조 모델

<img width="578" alt="Image" src="https://github.com/user-attachments/assets/8be9792b-2f10-4702-a670-34dcc8a8eb90" />

- 패킷을 주고받는 과정에는 정형화된 순서가 있고, 계층적으로 표현할 수 있음
- **네트워크 참조 모델**: 통신이 이루어지는 단계를 계층적으로 표현한 것
- 패킷을 송신하는 쪽에서는 상위 계층에서 하위 계층으로 정보를 보내고, 패킷을 수신하는 쪽에서는 하위 계층에서 상위 계층으로 정보를 받아들임
- 네트워크 참조 모델에서 각각의 계층이 하는 일이 명확하게 정해져 있음
  - 계층별 목적에 맞는 프로토클과 장비를 구성하면 네트워크의 구성과 설계, 문제의 진단과 해결이 용이해짐
  - 대표적인 네트워크 참조 모델인 **OSI 모델**과 **TCP/IP 모델**에 대해 알아보자

#### OSI 모델

<img width="219" alt="Image" src="https://github.com/user-attachments/assets/db70636d-8481-4225-bf64-cfb1b39e8f8e" />

- 국제 표준화 기구에서 만든 네트워크 참조 모델
- 통신 단계를 7개의 계층으로 나눔
- 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층으로 구성돼 있음

##### 1. 물리 계층

- 가장 최하위 계층으로, 비트 신호를 주고 받는 계층
- 컴퓨터는 0과 1만을 이해할 수 있기 때문에 네트워크를 통해 주고받는 정보 또한 0과 1로 이루어진 신호로 구성됨
- 이러한 0과 1로 이루어진 신호를 유무선 통신 매체를 통해 운반하는 계층

##### 2. 데이터 링크 계층

- 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층
- 이를 위해 같은 네트워크에 속한 호스트를 식별할 수 있는 주소 MAC 주소를 사용함
- 물리 계층을 통해 주고받는 정보에 오류가 없는지 확인하기도 함
- 물리 계층과 데이터 링크 계층은 서로 밀접하게 연간돼 있으며, 하드웨어와 밀접하게 맞닿아 있는 계층임

##### 3. 네트워크 계층

- 네트워크 간 통신을 가능하게 하는 계층
- 데이터 링크 계층이 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위해 필요한 계층이라면, 네트워크 계층은 LAN을 넘어 다른 네트워크와 통신을 주고받기 위해 필요한 계층임
- 네트워크 간 통신 과정에서 호스트를 식별할 수 있는 주소(IP 주소)가 필요함
- 대표적 프로토콜: IP

##### 4. 전송 계층

- 네트워크를 통해 송수신되는 패킷은 전송 도중 유실될 때도 있고, 순서가 뒤바뀔 때도 있음
- 이러한 상황에 대비해 신뢰성 있는 전송을 가능하게 하는 계층
- '포트' 라는 정보를 통해 특정 응용 프로그램과의 연결 다리 역할을 수행하는 계층
- 대표적 프로토콜: TCP, UDP

##### 5. 세션 계층

- 응용 프로그램 간의 연결 상태를 의미하는 '세션'을 관리하기 위한 계층
- 응용 프로그램 간의 연결 상태를 유지하거나 새롭게 생성하고, 필요하다면 연결을 끊는 역할을 함

##### 6. 표현 계층

- 번역가와 같은 역할을 하는 계층
- 인코딩과 압축, 암호화와 같은 작업을 수행함
- 세션 계층과 표현 계층은 다른 계층과 달리, 두 계층을 명확하게 구분하지 않거나 응용 계층에 포함하여 간주하는 경우가 많음

##### 7. 응용 계층

- 사용자와 가장 밀접하게 맞닿아 있어 여러 네트워크 서비스를 제공하는 계층
- 대표적 프로토콜: HTTP, HTTPS, DNS

#### TCP/IP 모델

<img width="220" alt="Image" src="https://github.com/user-attachments/assets/e41eeffb-f7aa-4df7-ba1e-9c03c1ea2bde" />

- TCP/IP 4계층이라고도 불림
- 네트워크 액세스 계층, 인터넷 계층, 전송 계층, 응용 계층으로 구성돼있음
- OSI 모델은 네트워크의 이론적 기술을 목적으로 사용하는 반면, TCP/IP 모델은 구현과 프로토콜에 중점을 둔 네트워크 참조 모델임

##### 1. 네트워크 액세스 계층

- 링크 계층 또는 네트워크 인터페이스 계층이라고도 부름
- OSI 모델의 데이터 링크 계층과 유사

##### 2. 인터넷 계층

- OSI 모델의 네트워크 계층과 유사

##### 3. 전송 계층

- OSI 모델의 전송 계층과 유사

##### 4. 응용 계층

- OSI 모델의 세션 계층, 표현 계층, 응용 계층을 합친 것과 유사

### 캡슐화와 역캡슐화

<img width="572" alt="Image" src="https://github.com/user-attachments/assets/f0e51399-b610-4c10-aa7a-6ea46b8661a4" />

- 프로토콜과 네트워크 참조 모델을 토대로 이루어지는 패킷의 송수신 과정 중 송신 과정에서는 캡슐화가 이뤄지고, 수신 과정에서는 역캡슐화가 이뤄짐
- 각 계층에서는 어떤 정보를 송신할 때 상위 계층으로부터 내려받은 패킷을 페이로드로 삼아, 각 계층에 포함된 프로토콜에 따라 헤더 혹은 트레일러를 덧붙인 다음 하위 계층으로 전달함 즉, 상위 계층의 패킷이 하위 계층의 페이로드로 간주됨
- **캡슐화**: 송신 과정에서 헤더 및 트레일러를 추가해 나가는 과정
- **역캡슐화**: 캡슐화 과정에서 붙인 헤더 및 트레일러를 각 계층에서 확인한 뒤 제거하는 과정
- 각 계층에서 주고받는 패킷(정보)를 지칭하는 이름이 다름

    <img width="565" alt="Image" src="https://github.com/user-attachments/assets/5b133a42-3745-4577-acc5-432f6883b4cb" />

# 2. 물리 계층과 데이러 링크 계층

- 이더넷, 이더넷 프레임, 통신 매체, 네트워크 장비에 대해 알아보자

## 이더넷

- 물리 계층과 데이터 링크 계층에는 LAN 내의 호스트들이 올바르게 정보를 주고받을 수 있게 해주는 다양한 기술들이 이 있음
- **이더넷**: 통신 매체를 통해 신호를 송수신하는 방법, 데이터링크 계층에서 주고받는 데이터프레임 형식 등이 정의된 기술을 말함
- 현대 대부분의 유선 LAN은 이더넷을 기반으로 구현돼있음

### 이더넷 표준

- 이더넷은 IEEE 802.3이라는 이름으로 국제 표준화된 기술
- 서로 다른 네트워크 제조사의 장비여도 LAN 내의 모든 컴퓨터가 문제없이 호환되는 이유는 네트워크 장비들이 표준을 준수하여 제작되었기 때문임
- 1. 오늘날의 (유선)LAN 대부분이 이더넷 표준을 따르기 때문에 대다수의 LAN 장비들이 특정 이더넷 표준을 따름
- 2. 이더넷 표준이 달라지면 통신 매체의 종류를 비롯한 신호 송수신 방법, 나아가 최대 지원 속도도 달라질 수 있음
- 케이블, 허브, 스위치, NIC 등 다양한 네트워크 장비들 모두 특정 이더넷 표준을 이해하고 따름

### 이더넷 프레임

<img width="572" alt="Image" src="https://github.com/user-attachments/assets/973f4fbc-70c6-4d16-9fbd-c746a4cc3b3f" />

- **이더넷 프레임**: 이더넷 기반의 네트워크에서 주고받는 프레임
- 프리앰블, 수신지 MAC주소 등의 정보를 포함하고 있음

#### 1. 프리앰블

- **프리앰블**: 송수신지 동기화를 위해 사용되는 8바이트 크기의 정보
- 첫 7바이트는 10101010이라는 값을 가지고, 마지막 바이트는 10101011이라는 값을 가짐
- 프릴앰블 비트를 통해 현재의 이더넷 프레임이 수신되고 있다는 사실을 알아차리게 됨

#### 2. 송수신지 MAC 주소

- 프레임에서 가장 중요한 정보
- 송신지와 수신지를 특정할 수 있는 6바이트 길이의 MAC 주소
- 콜론(:) 으로 구분된 12자리 16진수로 구성돼 있음 `ab:cd:ab:cd:00:01`
- 네트워크 인터페이스마다 하나씩 부여됨
  - 네트워크 인터페이스: 컴퓨터나 기기가 네트워크와 연결되는 '출입구'로 보통 NIC라는 장치가 네트워크 인터페이스를 담당함
  - 네트워크 인터페이스가 여러개면 한 호스트가 여러 개의 MAC 주소를 가질 수 있음

#### 3. 타입/길이

- MAC 주소의 타입/길이 필드에 명시된 크기가 05DC(16) 이하이면 이 필드는 프레임의 크기를 나타내고, 0600(16) 이상이면 타입을 나타냄
- 타입은 캡슐화된 상위 계층의 정보를 의미하므로 어떤 상위 계층 프로토콜이 캡슐화되었는지 알 수 있음
  - ex) IP(IPv4)가 캡슐화된 정보를 운반하면 타입에는 0800(16)이 명시됨
  - ex) ARP 프로토콜이 캡슐화된 정보를 운반하면 타입에는 0806(16)이 명시됨

#### 4. 데이터

- 페이로드, 즉 상위 계층으로 전달하거나 전달받을 데이터가 명시됨
- 데이터 필드에 포함될 수 있는 데이터의 최대 크기가 일반적으로 **1500바이트** 이하로 제한돼있음, 이보다 큰 데이터를 보낼 경우에는 여러 패킷으로 나뉘어 보내짐
- 점보 프레임: 페이로드 크기로 1500바이트보다 더 큰 데이터를 포함할 수 있는 특별한 프레임

#### 5. FCS(Frame Check Sequence)

- **FCS**는 트레일러임
- 프레임의 오류가 있는지의 여부를 확인하기 위한 필드
- **CRC**라는 오류 검출용 값이 명시됨
- 송신지에서 전송할 데이터에 대한 CRC 값을 계산하여 보내면 수신지에서는 전달받은 데이터에 대한 CRC 값을 계산해, 그 값을 전달받은 CRC 값과 대조함. 두 값이 같으면 프레임에 오류가 없다고 판단함

## 유무선 통신 매체

- 물리 계층과 데이터 링크 계층에 속한 다양한 네트워크 하드웨어(통신 매체와 네트워크 장비)에 대해 알아보자
- 호스트가 아무리 빠르게 데이터를 처리할 수 있어도 이를 뒷받침하는 연결 매체의 성능이 안좋으면 호스트의 빠른 속도는 아무 효용이 없음

### 유선 매체 - 트위스티드 페어 케이블

<img width="557" alt="Image" src="https://github.com/user-attachments/assets/f77e5ab7-bbc4-4644-b65f-15c70daca052" />

- 두 가닥씩 꼬아져 있는 구리선을 통해 전기적으로 신호를 주고 받는 통신 매체
- 트위스티드 페어 케이블의 성능은 **카테고리**에 따라 다름
- 카테고리에 따라 대응되는 이더넷 표준이 다르고 그에따라 최대 지원 속도도 달라질 수 있음
- 오늘날 자주 사용되는 카테고리 종류는 아래와 같음

  | 특징      | Cat5    | Cat5e | Cat6  | Cat6a  | Cat7   | Cat8   |
  | --------- | ------- | ----- | ----- | ------ | ------ | ------ |
  | 전송 속도 | 100Mbps | 1Gbps | 1Gbps | 10Gbps | 10Gbps | 40Gbps |

<img width="537" alt="Image" src="https://github.com/user-attachments/assets/9fd0eb9f-b5cd-4114-80be-c66c76ba366f" />

- **노이즈**: 전기 신호에 왜곡을 줄 수 있는 주변 잡음
- **포일**: 그물 모양의 철사나 포일로 감싸 노이즈를 방지함
- **차폐**: 구리선 주변을 보호해 노이즈를 감소시키는 방식
- **브레이드 실드**: 차폐에 사용된 그물 모양의 철사
- **포일 실드** 차폐에 사용된 포일
- **STP(Shielded Twisted Pair)**: 브레이드 실드로 노이즈를 감소시킨 케이블
- **FTP(Foil Twisted Pair)**: 포일 실드로 노이즈를 감소시킨 케이블
- **UTP(Unshielded Twisted Pair)**: 아무것도 감싸지 않아 구리선만 있는 케이블
- 실드의 상세한 표기: [ ] / [ ] TP
  - 첫 번째 괄호는 케이블의 외부를 감싸는 실드 종류
  - 두 번째 괄호는 꼬아 놓은 구리선을 감싸는 실드의 종류
  - ex) S/FTP : 브레이드 실드로 케이블 외부를 보호하고, 포일 실드로 구리선을 감싼 케이블
  - ex) SF/FTP: 브레이드 실드와 포일 실드로 케이블 외부를 보호하고, 포일 실드로 구리선을 감싼 케이블

### 무선 매체 - 전파와 WIFI

#### 전파

- 전파는 약 3kHz부터 3THz 사이의 진동수를 갖는 전자기파를 의미
- 2.4GHz와 5GHz 두 진동수는 3kHz부터 3THz 사이에 속한 진동수로, 와이파이를 사용할 때 주로 활용됨

#### 와이파이

- 유선 LAN에서 가장 대중적으로 활용되는 기술이 이더넷이라면, 무선 LAN에서 가장 대중적으로 사용되는 기술은 **와이파이**
- 와이파이는 IEEE 802.11 표준을 따르는 무선 LAN 기술
- 표준에 따라 지원되는 최대 속도나 주파수 대역 등이 달라질 수 있음
- 와이파이 세대에 따라 지원되는 표준 규격이 달라 지원 가능한 최대 속도나 주파수 역시 달라짐

  | 세대 이름 | 표준 규격     |
  | --------- | ------------- |
  | Wi-Fi 7   | IEEE 802.11be |
  | Wi-Fi 6   | IEEE 802.11ax |
  | Wi-Fi 5   | IEEE 802.11ac |
  | Wi-Fi 4   | IEEE 802.11n  |

#### 채널

<img width="488" alt="Image" src="https://github.com/user-attachments/assets/f50c15bc-3a2a-4b84-b232-4a6d765a5fa4" />

- 와이파이에서 주로 사용되는 주파수 대역: 2.4GHz와 5GHz
- 같은 지역에서 주파수가 같은 무선 네트워크가 여러 개 존재하면 통신을 주고받을 때 신호 간섭이 발생할 수 있음
  - ex) 신호 간섭: 특정 지역에서 2개의 무전기가 같은 주파수를 사용할 경우, 다른 무전기 소리가 섞여 들릴 수 있음
- **채널**: 같은 대역을 사용하는 서로 다른 무선 네트워크를 구분하기 위해 채널이라는 하위 주파수 대역으로 세분화하고, 해당 채널 대역에서 무선 통신이 이루어짐
- 채널은 자동 설정되지만, 특정 채널을 사용하도록 수동으로 설정할 수도 있음
- 무선 네트워크의 성능 저하를 방지하려면 신호가 중첩되지 않는 채널을 사용하는 것이 중요함
  - 2.4GHz 대역 채널을 살펴보면 1,6,11번 채널의 주파수는 서로 중첩되지 않기 때문에 1,6,11번 채널을 사용하는 무선 네트워크는 아무리 많은 통신이 이뤄져도 신호 간섭으로 인한 성능 저하가 발생하지 않음
  - 반면 1,2,3번 채널을 사용하는 무선 네트워크는 신호가 중첩될 여지가 많아 자주 발생하는 신호 간섭으로 인해 성능이 현저히 저하될 수 있음

## 네트워크 인터페이스: NIC

- 네트워크 상에서 노드와 통신 매체가 연결되는 지점
- 네트워크 인터페이스마다 물리적 주소인 MAC 주소가 부여되고, NIC라는 하드웨어가 네트워크 인터페이스 역할을 함
- NIC: 네트워크 인터페이스 카드, 네트워크 어댑터, LAN 카드, 네트워크 카드 등 다양한 명칭으로 불리는 하드웨어
- 통신 매체의 신호를 호스트가 이해하는 프레임으로 변환하거나 호스트가 이해하는 프레임을 통신 매체의 신호로 변환하는 역할을 함
- 입출력장치와 다르지 않음. NIC를 작동시키는 시스템 콜이 호출되면 커널 모드로 전환된 뒤 송수신이 수행되고, 입출력이 완료되면 인터럽트를 통해 CPU에게 작업이 완료되었음을 알림

  <img width="557" alt="Image" src="https://github.com/user-attachments/assets/1af24d14-490e-4145-bcef-f936b0e60e10" />

## 허브와 스위치

- 허브와 스위치는 물리 계층과 데이터 링크 계층의 중간 노드
- 허브는 오늘날 잘 사용하지 않고 대신 스위치를 사용하는 경우가 많음

### 물리 계층의 허브

<img width="202" alt="Image" src="https://github.com/user-attachments/assets/92e56b6a-8d27-4d10-8d97-c0de7ba63183" />

- 허브는 물리 계층의 대표적인 네트워크 장비로, 여러 대의 호스트를 연결하는 장치임
- **리피터 허브**라고 부르기도 함, 이더넷 네트워크의 허브는 **이더넷 허브**라고 부르기도 함
- **포트**: 허브에서 케이블의 커넥터가 꽂히는 부분, 통신 매체를 연결하는 지점
- 중요한 특징

  <img width="424" alt="Image" src="https://github.com/user-attachments/assets/3eda7451-979c-419b-9a8e-b1b786eb8fc8" />

  1. 전달받은 신호를 모든 포트로 내보냄: 허브는 신호를 전달받으면 해당 신호에 대한 어떠한 조작이나 판단도 하지 않고, 모든 포트에 단순하게 신호를 내보냄
  2. 반이중 모드로 통신함: 송신 또는 수신을 번갈아 가면서 수행함 즉, 동시 송수신이 불가능함

- **반이중**: 동시에 송/수신 하는 것이 불가능
- **전이중**: 동시에 송/수신 하는 것이 가능

### 데이터 링크 계층의 스위치

<img width="572" alt="Image" src="https://github.com/user-attachments/assets/b928e32d-d952-4beb-bb7d-8e1ff931e0aa" />

- **스위치**: 허브의 한계를 보완하기 위한 네트워크 장비
- 전달받은 신호를 목적지 호스트가 연결된 포트로만 내보내고, 전이중 모드를 지원함

#### MAC 주소 학습

- 특정 포트에만 보낼 수 있는 이유: **MAC 주소 학습** 기능이 있기 때문
- **MAC 주소 테이블**: 스위치는 프레임 속 MAC 주소를 토대로 어떤 포트에 어떤 MAC 주소를 가진 호스트가 연결돼있는지 파악하고, `포트, 연결된 호스트의 MAC 주소` 의 대응 관계를 테이블 형태로 메모리에 저장함
- 즉, 스위치가 전달받은 신호를 목적지 호스트가 연결된 포트로만 내보낼 수 있는 이유는 MAC 주소 테이블을 생성하고 참조할 수 있기 때문임

#### VLAN

<img width="594" alt="Image" src="https://github.com/user-attachments/assets/3bcce825-0aaa-4b03-96f7-57c2919384ac" />

- **VLAN**: 가상의 LAN을 의미함, 같은 스위치에 연결된 모든 호스트를 하나의 네트워크로 간주하고 싶지 않을 때, 여러 논리적이 네트워크로 나누고 싶을 때 주로 사용됨
- 호스트 A~D와 호스트 E~I는 다른 VLAN에 속해 있으므로 서로 다른 네트워크로 간주되며, 브로드 캐스트 도메인도 겹치지 않아 VLAN1의 브로드캐스트 메시지가 VLAN2에 도달하지 않음
- 호스트 A~D와 호스트 E~I가 서로 통신을 주고받으려면 네트워크 계층 이상의 장비가 필요함

# 3. 네트워크 계층 - IP

- 물리 계층과 데이터 링크 계층에 속한 기술은 LAN을 위한 기술임
- LAN을 넘어서 다른 네트워크와 통신을 주고받으려면 네트워크 계층 이상의 기술이 필요함
- IP(Internet Protocol)은 이러한 네트워크 계층의 가장 핵심적인 프로토콜임

## IP의 목적과 특징

- IP의 목적: **주소 지정**, **단편화**
- 주소 지정: 네트워크 간의 통신 과정에서 호스트를 특정하는 것
- 단편화: 데이터를 여러 IP 패킷으로 올바르게 쪼개어 보내는 것
- IP 특징: **신뢰할 수 없는 통신**, **비연결형 통신**

### 주소 지정과 단편화

#### 주소 지정

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/75436d41-ac48-4a9d-a8d3-b2a0a4f47eb1" />

- 네트워크 간의 통신 과정에서 호스트를 특정하는 것
- 주소 지정은 IP 주소를 통해 이루어지며, IP 주소는 패킷 헤더의 **송신지 IP 주소**, **수신지 IP 주소**를 통해 알 수 있음
- 하나의 IP 주소는 총 4바이트의 크기로 구성되고, 숫자당 8비트로 표현되므로 0~255 범위의 10진수 4개로 표기됨
- **옥텟**: 각각의 진수는 점(.)으로 구분하는데, 점으로 구분된 하나의 10진수를 의미
  - ex) `192.168.0.1` 이라는 IP 주소에서 옥텟은 192, 168, 0, 1
- 오늘날의 IP는 IPv4, IPv6 두 종류가 있음
  - IPv4 주소는 총 2^32개의 주소가 할당 가능하기 때문에 부족하기 때문에 IPv6 등장함
  - IPv6 주소는 16바이트로 주소를 표현할 수 있기 때문에 2^128개의 주소가 할당 가능함
  - IPv6은 콜론(:)으로 구분된 8개 그룹의 16진수로 표기됨 `2001:0230:abcd:ffff:0000:0000:ffff:1111`

**라우터**

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/98ef7788-a138-49cb-9e6f-7963d21354b0" />

- 서로 다른 네트워크에 속한 두 호스트가 네트워크 간 통신을 할 때, IP 주소를 바탕으로 목적지까지 IP 패킷을 전달하는 네트워크 장비
- 네트워크 계층에 속한 장비로, 전달받은 패킷을 목적지까지 전달하는 역할을 함
- **라우팅**: IP 패킷을 전달할 최적의 경로를 결정하고 해당 경로로 패킷을 내보내는 과정

#### IP 단편화

<img width="587" alt="Image" src="https://github.com/user-attachments/assets/2d2d2d1a-9b1a-4824-bd4f-8a77a2a96dc9" />

- 데이터를 여러 IP 패킷으로 올바르게 쪼개어 보내는 것
- **MTU(Maximum Transmission Unit)**: 최대 전송 단위
  - 전송하고자 하는 IP 패킷(IP 헤더 + 페이로드)의 크기가 MTU 단위보다 클 경우 패킷을 여러 패킷으로 쪼개서 전송하고, 쪼개서 전송된 패킷들은 수신지에서 재조합됨
  - 일반적인 MTU 크기는 1500바이트임.
- IP 패킷에서 단편화와 관련된 필드: **식별자**, **플래그**, **단편화 오프셋**

**식별자**

- 특정 패킷이 어떤 데이터에서 쪼개진 패킷인지를 식별하기 위해 사용되는 필드
- 같은 정보엥서 쪼개진 패킷들은 같은 식별자를 공유하기 때문에 식별자를 통해 단편화되어 전송되는 패킷을 구분할 수 있음

**플래그**

<img width="528" alt="Image" src="https://github.com/user-attachments/assets/1f3d600a-c2a0-4bc4-ae77-6128583c58cd" />

- 3비트로 구성된 필드
- 첫 번째 비트를 제외한 나머지 2개의 비트는 각각 DF와 MF라는 이름이 붙어 있음
- 첫 번째 비트: 항상 0으로 설정되어 오늘날 사용되지 않음
- 두 번째 비트 DF: 'IP 단편화를 수행하지 말라' 는 표시를 남기기 위한 비트
- 세 번째 비트 MF: '단편화된 패킷이 더 있다'는 표시를 남기기 위한 비트

**단편화 오프셋**

- 특정 패킷이 초기 데이터에서 얼마나 떨어져 있는지가 명시된 필드
- 단편화되어 전송되는 패킷을 목적지에서 재조합하기 위해 패킷의 올바른 순서를 나타내는 데 사용됨

**IP 단편화 피하기 - 경로 MTU 발견**

<img width="380" alt="Image" src="https://github.com/user-attachments/assets/77ece947-65ad-406d-a48d-eec1d9147bcd" />

- 사실 오늘날의 네트워크 환경에서는 IP 단편화가 잘 발생하지 않음.
- 네트워크 성능의 발전, IP 단편화가 발생하지 않는 것이 좋기 때문
- 단편화된 패킷들이 많아지면 전송해야 할 패킷의 헤더들이 많아져서 불필요한 트래픽 증가와 대역폭 낭비를 초래하고, 단편화된 패킷을 재조립하는 과정에서 발생하는 부하도 성능 저하로 이어질 수 있음
- IP 단편화 피하는 방법: IP 패킷을 주고받는 경로에 존재하는 모든 호스트의 '처리 가능한 MTU 크기'를 고려하여, IP 단편화 없이 주고 받을 수 있는 최대 크기인 **경로 MTU**만큼 전송해야 함
- **경로 MTU 발견**: 주고받을 수 있는 경로 MTU를 구하고 해당 크기만큼만 송수신하여 IP 단편화를 피하는 기술
- 오늘날 네트워크에서는 대부분 경로 MTU 발견을 지원하고, 처리 가능한 최대 MTU 크기도 균일해서 IP 단편화 자주 발생하지 않음

> 애초에 보내야 하는 데이터 크기가 1500바이트가 넘으면?

### 신뢰할 수 없는 통신과 비연결형 통신

- IP는 신뢰할 수 없는 프로토콜이자, 비연결형 프로토콜임

#### 신뢰할 수 없는 프로토콜

- 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는 프로토콜
- 패킷이 유실되거나 목적지에 순서대로 전송하지 않아도 조치를 취하지 않음
- 신뢰할 수 없는 프로토콜의 송수신은 신뢰할 수 없는 통신, 신뢰성이 낮은 통신, **최선형 전달**이라고 부름

#### 비연결형 프로토콜

- 패킷을 주고받기 전에 사전 연결 과정을 거치지 않음
- 상대 호스트의 수신 가능 여부는 고려하지 않고, 수신지를 향해 그저 패킷을 전송함

## IP 주소의 구조

<img width="241" alt="Image" src="https://github.com/user-attachments/assets/cff390a0-1b80-4aaa-a450-4fccd78cddd6" />

<img width="344" alt="Image" src="https://github.com/user-attachments/assets/38daf81d-f597-496e-9630-a9446a80b313" />

- 0~255 범위의 10진수 4개로 표기되는 IP 주소는 네트워크 주소와 호스트 주소로 이루어져 있음
- **네트워크 주소**: 호스트가 속한 네트워크를 특정하기 위해 사용됨
  - 네트워크 ID, 네트워크 식별자 등으로 불림
- **호스트 주소**: 네트워크에 속한 호스트를 특정하기 위해 사용됨
  - 호스트 ID, 호스트 식별자 등으로 불림
- 하나의 IP 주소에서 네트워크 주소를 표현하는 크기와 호스트를 표현하는 크기는 유동적임
  - a는 호스트 주소에 24비트를 사용할 수 있어서, 네트워크당 많은 호스트에 IP 주소 할당 가능
  - c는 호스트 주소에 8비트를 사용할 수 있어서, 네트워크당 적은 호스트에 IP 주소 할당 가능

### 클래스풀 주소 체계

- IP 주소에서 네트워크 주소와 호스트 주소 구분 범위가 유동적이면 어느 정도가 적당할까?
  - 호스트 주소의 공간을 너무 크게 할당하면 호스트가 할당되지 않은 다수의 IP 주소가 낭비됨
  - 호스트 주소의 공간을 너무 작게 할당하면 호스트가 사용할 IP 주소가 부족해질 수 있음
- 이를 해결하기 위한 것이 IP 주소의 **클래스**임

**클래스**

- 네트워크의 크기에 따라 유형별로 IP 주소를 분류하는 기준
- 어떤 클래스에 속한 IP 주소인지 알면 IP 주소에서 네트워크 부분과 호스트 부분의 크기를 알 수 있음
- 클래스 종류: A, B, C, D, E

  - D, E: 멀티캐스트를 위한 클래스, 특수한 목적을 위해 예약된 클래스
  - A, B, C: 네트워크의 크기별로 IP 주소를 분류하는데 실질적으로 사용되는 클래스

**클래스풀 주소 체계**

- 클래스를 바탕으로 IP 주소를 관리하는 주소 체계

<img width="371" alt="Image" src="https://github.com/user-attachments/assets/c161ab1c-762c-48c4-a593-c36651e4e145" />

- A 클래스

  - 네트워크 주소는 비트 '0'으로 시작하며 1옥텟으로 구성됨
  - 호스트 주소는 3옥텟으로 구성됨
  - 상대적으로 가장 많은 호스트를 할당할 수 있는 클래스

- B 클래스

  - 네트워크 주소는 비트 '10'으로 시작해 2옥텟으로 구성됨
  - 호스트 주소도 2옥텟으로 구성됨

- C 클래스

  - 네트워크 주소는 비트 '110'으로 시작해 3옥텟으로 구성됨
  - 호스트 주소는 1옥텟으로 구성됨

- 클래스별 IP 주소의 표현 가능 범위

<img width="490" alt="Image" src="https://github.com/user-attachments/assets/0e96fd47-19bd-45d4-a802-bc44c6d981de" />

- 참고) 네트워크/브로드캐스트 주소와 예약 주소

  <img width="488" alt="Image" src="https://github.com/user-attachments/assets/583f95dd-501e-48c6-a57a-d731f099e2c6" />

  - 호스트의 주소 공간을 모두 사용할 수 있는 것은 아님
  - 호스트 주소가 전부 0인 IP 주소: 해당 네트워크 자체를 의미하는 주소로 사용됨
  - 호스트 주소가 전부 1인 IP 주소: 브로드캐스트를 위한 주소로 사용됨
  - 예약된 IP 주소

    <img width="509" alt="Image" src="https://github.com/user-attachments/assets/cce2cff0-223d-4794-8081-358072f41b99" />

### 클래스리스 주소 체계와 서브넷 마스크

- 클래스풀 주소 체계에서는 클래스별 네트워크 크기가 고정돼 있어서 고정된 크기 외에 다른 크기의 네트워크를 구성할 수 없어 IP 주소가 낭비될 수 있다는 한계가 있음
- **클래스리스 주소 체계**: 클래스를 이용하지 않고 네트워크와 호스트를 구분하는 방식
  - 클래스풀 주소 체계보다 더 정교하고 유동적으로 네트워크 영역을 나눌 수 있는 방법
  - 네트워크와 호스트를 구분하는 수단으로 서브넷 마스크 이용
- **서브넷 마스크**: IP 주소상에서 네트워크 주소를 1로 표기하고, 호스트 주소를 0으로 표기한 비트열

  - A 클래스: 255.0.0.0(11111111.00000000.00000000.00000000)
  - B 클래스: 255.255.0.0(11111111.11111111.00000000.00000000)
  - C 클래스: 255.255.255.0(11111111.1111111111111111.00000000)

- **서브네트워크(서브넷)**: IP 주소에서 네트워크 주소로 구분할 수 있는 네트워크의 부분집합
- **서브네팅**: 서브넷 마스크를 이용해 원하는 크기로 클래스를 잘게 쪼개 사용하는 것
- 서브넷 마스크와 IP 주소 간에 비트 AND 연산을 수행하면 IP 주소 내의 네트워크 주소를 알아낼 수 있음

  - IP 주소 162.168.200.102와 서브넷 마스크 255.255.255.0 => 네트워크 주소 192.168.200.0

    <img width="383" alt="Image" src="https://github.com/user-attachments/assets/aaf84b3d-9ad2-4ebc-8221-a03dccf4cee1" />

- 서브넷 마스크 표기법: **CIDR 표기**
  - `IP 주소/서브넷 마스크상의 1의 개수`
  - 192.168.20.3/30는 서브넷 마스크에서 1이 30개가 있다는 의미 -> 11111111.11111111.1111111.11111100(255.255.255.252)

> 그래서 실제로 클래스리스 주소 체계와 서브넷 마스크 사용해서 어떻게 유연하게 사용한다는거지?

## 공인 IP 주소와 사설 IP 주소

- 호스트의 IP 주소는 네트워크 설정이나 명령어를 통해 확인할 수 있음
  - 윈도우: ipconfig/all
  - 맥OS, 리눅스: ifconfig
- 온라인 검색을 통해서도 확인할 수 있음
  - 'what is my ip address'로 검색
- 두 가지 방식으로 확인한 IP 주소가 다를 수 있음

### 공인 IP 주소

<img width="380" alt="Image" src="https://github.com/user-attachments/assets/f47e030e-422b-43fa-bf17-7c784ab99287" />

- 전 세계에서 고유한 IP 주소
- 인터넷을 비롯한 네트워크 간 통신에서 사용되는 IP
- 검색 사이트를 통해 확인했던 IP 주소
- 검색 사이트의 서버와 패킷을 주고받으려면 호스트가 속한 네트워크의 공인 IP 주소를 사용해야 하기 때문
- 공인 IP 주소는 ISP나 공인 IP 주소 할당 기관을 통해 할당받을 수 있음

### 사설 IP 주소

- 사설 네트워크에서 사용하기 위한 IP 주소
- 외부 네트워크에 공개되지 않은 네트워크
- 일반적으로 라우터(공유기)를 통해 할당되기 때문에 공유기(라우터)를 중심으로 구성된 LAN 대부분은 사설 네트워크에 해당됨
- 사설 IP 주소로 사용하도록 특별히 예약된 IP 주소 공간이 있음
  - 10.0.0.0/8 (10.0.0.0 ~ 10.255.255.255)
  - 172.16.0.0/12 (172.16.0.0 172.31.255.255)
  - 192.168.0.0/16 (192.168.0.0 ~ 192.168.255.255)

## IP 주소의 할당(사설 IP 주소 할당)

- 호스트에 IP 주소를 할당하는 방법을 알아보자

### 정적 할당

<img width="572" alt="Image" src="https://github.com/user-attachments/assets/76559ee0-f320-4dd3-8019-21e1b46f3dd5" />

<img width="328" alt="Image" src="https://github.com/user-attachments/assets/c970149e-86f4-4b62-9287-4837dd1121fd" />

- 수작업으로 IP 주소를 부여하는 방식
- **정적 IP 주소**: 정적 할당을 통해 할당된 IP 주소
- IP 주소, 서브넷 마스크, 게이트웨이(라우터) 주소, DNS 주소 등 필요
- **게이트웨이**: 서로 다른 네트워크를 연결하는 하드웨어적/소프트웨어적 수단
- **기본 게이트웨이**: 호스트가 속한 네트워크의 외부로 나가기 위한 첫 기본 경로, 네트워크 외부와 연결된 라우터(공유기)의 주소를 의미하는 경우가 많음
- **DNS 주소**: 호스트가 도메인 네임을 토대로 IP 주소를 알아내기 위해 질의하는 서버의 주소

### 동적 할당

- 프로토콜을 통해 자동으로 IP 주소를 부여하는 방식
- **동적 IP 주소**: 동적 할당을 통해 할당된 IP 주소
- 호스트에 수동으로 직접 IP 주소를 할당하지 않고도 호스트에 IP 주소가 부여되어 있다면 IP 주소가 동적으로 할당되었기 때문임
- **DHCP(Dynamic Host Configuration Protocol)** 프로토콜: 호스트에 할당 가능한 IP 주소 목록을 관리하다가, IP 주소 할당 요청을 받았을 때 IP 주소를 할당해 주는 호스트
- 일반적으로 라우터(공유기)가 DHCP 서버 역할을 수행함
- 특징
  1. 동적 IP 주소에는 사용 가능한 기간(임대 기간)이 정해져 있음
  2. 동적 IP 주소는 할당받을 때마다 다른 주소를 받을 수 있음
- DHCP로 할당받은 IP 주소는 사용할 기간이 정해져 있고, 사용되지 않을 경우 회수됨
- 사용 기간이 끝난 IP 주소는 DHCP 서버로 반납되고, 새롭게 IP 주소를 할당받는 경우 다른 IP 주소를 할당받을 수 있음
- DHCP를 통한 IP 주소의 동적 할당은 이런 점에서 'IP 주소의 임대' 라고도 표현함
- **임대 갱신**: IP 주소의 임대 기간이 끝나기 전에 임대 기간을 연장하는 것, 기본적으로 자동으로 두 차례 수행되고, 두 번의 임대 갱신 모두 실패하면 IP 주소가 DHCP 서버로 반납됨

## IP 전송 특징의 보완: ICMP(Internet Control Message Protocol)

### IP의 전송 특징

- IP의 신뢰할 수 없는 전송과 연결을 수립하지 않는 전송은 성능 측면으로 봤을 때 반드시 나쁜 것은 아님
  - 신뢰성 높은 송수신, 연결형 송수신을 위해서는 매번 점검, 오류 제어, 연결 관리 등이 필요한데 많은 시간과 대역폭, 부하가 필요하기 때문에 성능에 불리하게 작용할 수 있음
  - 따라서 IP의 신뢰할 수 없는 비연결형 전송이라는 특징은 반드시 극복해야할 단점은 아님
- IP의 신뢰할 수 없는 비연결형 통신이라는 특징을 보완해야 할 때가 있기는 함
  - 방법 1. 신뢰할 수 있는 연결형 통신을 지원하는 상위 계층 프로토콜 사용
  - 방법 2. 네트워크 계층의 ICMP 프로토콜 사용

### ICMP

<img width="343" alt="Image" src="https://github.com/user-attachments/assets/dd37d74a-67da-4de3-9bc5-55dc437ff47f" />

- IP의 '신뢰할 수 없는 프로토콜', '비연결형 프로토콜' 이라는 특징을 보완하기 위한 프로토콜
- IP 패킷의 전송 과정에 대한 피드백 메시지(ICMP 메시지)를 얻기 위해 사용하는 프로토콜
- ICMP 메시지를 통해 패킷이 상대방에게 어떻게 전송됐는지 알려줄 수 있어 IP 전송의 결과를 알 수 있음
- 유의: ICMP가 IP의 신뢰성을 완전히 보장하지는 않음 (완전히 보장하려면 전송 계층 프로토콜 필요)
- ICMP 메시지는 1. 전송 과정에서 발생한 오류 보고, 2. 네트워크에 대한 진단 정보로 유형을 나눌 수 있음

  <img width="468" alt="Image" src="https://github.com/user-attachments/assets/1c5b952e-05c9-4899-967e-9ff3cc4139c7" />

- **네트워크 도달 불가**: 네트워크 장비 가령 라우터가 패킷을 전달받았는데, 어떤 네트워크로 전송해야할 지 알 수 없는 경우 되돌려 보내지는 ICMP 메시지
- **단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음**: 처리하기에 너무 큰 패킷을 전달받았는데, DF 플래그가 설정돼있어 단편화가 불가능한 경우 되돌려 보내지는 ICMP 메시지
- **시간 초과**: IP 헤더의 패킷의 수명을 의미하는 TTL(Time To Live) 필드가 라우터를 거치면서 0이 되면 패킷은 폐기되고, 패킷을 송신한 호스트에게 되돌려 보내지는 ICMP 메시지

  <img width="530" alt="Image" src="https://github.com/user-attachments/assets/604bf2d6-38bf-49c0-8097-a0eb3e406c27" />

  - 패킷이 하나의 라우터를 거칠 때마다 TTL이 1씩 감소함
  - **홉**: 패킷이 호스트 또는 라우터에 한 번 전달되는 것
  - 즉, 홉마다 TTL 필드의 값이 1씩 감소함
  - TTL 필드의 존재 이유: 무의미한 패킷이 네트워크상에 지속적으로 남아있는 것을 방지하기 위함

- ICMP 메시지는 네트워크상의 간단한 문제를 진단하고 테스트하기 위해 사용되기도 함
  - traceroute 또는 tracert: 네트워크 상의 경로 확인하는 명령어
  - ping: 네트워크 상태 점검하기 위한 패킷 송신 명령어

## IP 주소와 MAC 주소의 대응: ARP

- 상대의 IP 주소는 알고, MAC 주소는 모를 때 사용되는 프로토콜
- **ARP**: IP 주소와 MAC 주소를 함께 활용하는 통신 과정에서 동일 네트워크 내에 있는 송수신 대상의 IP 주소를 통해 MAC 주소를 알아내는 프로토콜
- IP 주소를 통해 MAC 주소를 알아내는 과정은 ARP 요청 메시지와 ARP 응답 메시지를 통해 이루어짐
- **ARP 요청 메시지**: 알고 싶은 MAC 주소에 대응되는 IP 주소 포함돼있음
  - 1. 브로드캐스트 메시지여서 네트워크 내에 있는 모든 호스트에게 보내짐
  - 2. 호스트들은 IP 주소를 확인하고 자신과 관련 없으면 무시, 자신의 IP 주소이면 ARP 응답 메시지 전송함
  - 3. ARP 요청 메시지를 보낸 호스트가 ARP 응답 메시지를 수신하면 IP에 대한 MAC 주소를 알게됨
  - 4. 매번 브로드캐스트(ARP 요청) 메시지 보내는 것을 피하기 위해 송신한 호스트에서는 알게된 `<IP 주소, MAC 주소>` 쌍을 기억해둠
- **ARP 테이블**: `<IP 주소, MAC 주소>` 의 항목들로 구성된 표 형태의 정보
  - 각 항목은 일정 시간이 지나면 삭제되고, 임의로 삭제할 수도 있음

> 데이터 링크 계층은 MAC 기반으로 동작하기 때문에 MAC으로 변환해줘야함

# 4. 전송 계층 - TCP와 UDP

## TCP와 UDP의 목적과 특징

### 포트를 통한 프로세스 식별

- IP 주소와 MAC 주소는 호스트를 특정할 수 있지만 패킷의 최종 송수신 대상은 '호스트가 실행하는 프로세스'임
- **포트**번호 를 통해 호스트가 실행하는 프로세스를 식별할 수 있음
- 즉 IP 주소와 포트 번호의 조합을 통해 '특정 호스트가 실행하는 특정 프로세스'를 식별할 수 있음
- `IP 주소: 포트 번호` 형태

  <img width="334" alt="Image" src="https://github.com/user-attachments/assets/0dca53dc-50b4-4082-a1a3-37a4876ed048" />

- TCP/UDP 헤더에는 송신지 포트 번호와 수신지 포트 번호를 포함함

  <img width="569" alt="Image" src="https://github.com/user-attachments/assets/5ce23d17-8213-4258-8329-34c28f2151b7" />

#### 포트 번호

- 포트 번호는 16비트를 차지하므로 2^16 = 65536개(0~65535) 표현할 수 있음
- 포트 번호는 범위에 따라 3가지 종류로 나뉨

  | 포트 종류      | 포트 번호 범위 |
  | -------------- | -------------- |
  | 잘 알려진 포트 | 0 ~ 1023       |
  | 등록된 포트    | 1024 ~ 49151   |
  | 동적 포트      | 49152 ~ 65535  |

**잘 알려진 포트**: 가장 대중적으로 사용되는 애플리케이션을 위한 포트 번호, 프로토콜이 주로 사용하는 포트 번호 목록

| 잘 알려진 포트 번호 | 설명   |
| ------------------- | ------ |
| 20, 21              | FTP    |
| 22                  | SSH    |
| 23                  | TELNET |
| 53                  | DNS    |
| 67, 68              | DHCP   |
| 80                  | HTTP   |
| 443                 | HTTPS  |

**등록된 포트**: 흔히 사용되는 애플리케이션에 주로 사용하는 포트 번호

| 등록된 포트 번호 | 설명                              |
| ---------------- | --------------------------------- |
| 1194             | OpenVPN                           |
| 1433             | Microsoft SQL Server 데이터베이스 |
| 3306             | MySQL 데이터베이스                |
| 6379             | Redis                             |
| 8080             | HTTP 대체                         |

**동적 포트**

- 사설 포트 또는 임시 포트라고도 함
- 비교적 자유롭게 사용 가능
- 보통 서버 프로그램은 잘 알려진 포트나 등록된 포트가 할당되지만 클라이언트 프로그램같은 경우 동적 포트가 할당되는 경우가 많음

**NAT(Network Address Translation)와 NAPT()**

- NAT: 공인 IP와 사설 IP 간의 변환에 사용되는 기술

  <img width="518" alt="Image" src="https://github.com/user-attachments/assets/dc9ebb9a-0302-49e4-8df4-8601f8e09074" />

  - 대부분의 라우터와 공유기는 NAT 기능을 내장하고 있음

- NAPT: IP 주소 변환 과정에서 변환할 IP 주소의 쌍과 더불어, 포트 번호도 함께 고려하는 포트 기반의 NAT

  <img width="526" alt="Image" src="https://github.com/user-attachments/assets/8d153ddd-8496-4a23-a122-6d00c44ddd61" />

  - 하나의 공유 IP에서 다수의 사설 IP가 사용되는데, 사설 IP 주소가 같은 공인 IP 주소로 변환되더라도 다른 포트 번호로 변환되면 네트워크 내부의 호스트를 특정할 수 있음
  - NAT의 한 종류

### (비)신뢰성과 (비)연결형 보장

<img width="410" alt="Image" src="https://github.com/user-attachments/assets/0c560a17-1381-4a45-a4e3-97faf8857617" />

- 신뢰할 수 있는 연결형 송수신에는 시간과 연산이 소요되기 때문에 일반적으로 TCP가 UDP에 비해 송수신 속도가 느림
- 패킷의 유실 없는 송수신을 원하면 UDP보다 TCP를 선택하는 것이 유리, 비교적 빠른 송수신을 원한다면 TCP보다 UDP를 선택하는 것이 유리

#### UDP 헤더

<img width="277" alt="Image" src="https://github.com/user-attachments/assets/6d062c86-f325-4d7b-9ec0-c3a5c150456e" />

- **송신지 포트**: 송신 프로세스가 할당된 포트 번호
- **수신지 포트**: 수신 프로세스가 할당된 포트 번호
- **길이**: 헤더를 포함함 UDP 패킷(데이터그램)의 바이트 크기
- **체크섬**: 송수신 과정에서의 데이터그램 훼손 여부를 알 수 있는 정보

#### TCP 헤더

<img width="268" alt="Image" src="https://github.com/user-attachments/assets/0aec12e5-7cd6-4b78-9c13-5aeb28bb22af" />

- **순서 번호**: TCP 패킷(세그먼트)의 올바른 송수신 순서를 보장하기 위한 번호
  - 송수신하고자 하는 데이터의 몇번째 바이트에 해당하는지 알 수 있음
- **확인 응답 번호**: 상대 호스트가 보낸 세그먼트에 대한 응답, 다음으로 수신하길 기대하는 순서 번호

  - 일반적으로 '올바르게 수신한 순서 번호에 1이 더해진 값'으로 설정됨

  <img width="308" alt="Image" src="https://github.com/user-attachments/assets/5266660b-741c-4316-b45e-db75809f8790" />

- **제어 비트**: 세그먼트에 대한 부가 정보를 나타내난 정보, 플래그 비트라고도 부름
  - 8비트로 구성되며, 각 자리의 비트가 각기 다른 의미를 가짐
  - ACK: 세그먼트의 승인을 나타내기 위한 비트
  - SYN: 연결을 수립하기 위한 비트
  - FIN: 연결을 종료하기 위한 비트

## TCP의 연결부터 종료까지

### TCP의 연결 수립

- 3way handshake를 통해 이루어짐

**단계**

<img width="357" alt="Image" src="https://github.com/user-attachments/assets/a1cbe147-3fc2-45ae-b617-add439b44acf" />

<img width="295" alt="Image" src="https://github.com/user-attachments/assets/03886f74-1d49-42b2-b5f5-c6f247086ed8" />

1. [송수신 방향 A -> B] SYN 세그먼트 전송

- 호스트 A는 SYN 비트가 1로 설정된 세그먼트를 호스트 B에게 전송
- 이때 세그먼트의 순서 번호에는 호스트 A에서 보내는 패킷에 대한 순서 번호가 포함돼있음

2. [송수신 방향 B -> A] SYN + ACK 세그먼트 전송

- 1에 대한 호스트 B의 응답
- 호스트 B는 ACK 비트와 SYN 비트가 1로 설정된 세그먼트를 호스트 A에게 전송함
- 세그먼트의 순서 번호에는 호스트 B에서 보내는 패킷에 대한 순서 번호와 1에서 보낸 세그먼트에 대한 확인 응답 번호가 포함돼 있음

3. [송수신 방향 A -> B] ACK 세그먼트 전송

- 호스트 A는 ACK 비트가 1로 설정된 세그먼트를 호스트 B에게 전송
- 세그먼트의 순서 번호에는 호스트 A의 순서 번호와 2에서 보낸 세그먼트에 대한 확인 응답 번호가 포함돼 있음

**액티브 오픈**

- 처음 연결을 시작하는 과정
- 서버 - 클라이언트에서 보통 클라이언트에 의해 액티브 오픈이 수행됨

**패시브 오픈**

- 연결 요청을 수신한 뒤 그에 대한 연결을 수립하는 과정
- 서버 - 클라이언트에서 보통 서버에 의해 수행됨

### TCP의 오류/흐름/혼잡 제어

- TCP는 송수신하는 패킷의 신뢰성을 보장하고 위해 오류 제어, 흐름 제어, 혼잡 제어 기능을 제공함
- 재전송을 기반으로 다양한 오류를 제어
- 송수신의 흐름을 제어해 처리할 수 있을 만큼의 데이터만 주고받음
- 혼잡 제어를 통해 네트워크의 혼잡 정도에 따라 데이터의 전송량 조절

#### 1. 재전송을 통한 오류 제어

- TCP는 송수신 과정에서 잘못 전송된 세그먼트가 있을 경우, 이를 재전송하여 오류를 제어함
- TCP가 잘못 전송된 세그먼트가 있음을 인지하는 상황

  1. 중복된 ACK 세그먼트가 도착했을 때

  <img width="586" alt="Image" src="https://github.com/user-attachments/assets/7cdf8426-1743-464f-b3d7-06e9bce4dae5" />

  2. 타임아웃이 발생했을 때

  <img width="332" alt="Image" src="https://github.com/user-attachments/assets/338ce844-dd69-4d05-ac8d-3e511da4bbe8" />

  - TCP 세그먼트를 송신하는 호스트는 모두 **재전송 타이머** 값을 가짐
  - 호스트 세그먼트를 전송할 때마다 이 재전송 타이머가 시작되며, 타이머가 끝난 상황을 **타임 아웃**이라고 함
  - 타임아웃 발생 시점까지 ACK 세그먼트를 받지 못하면 세그먼트 전송 과정에 문제가 발생했다고 간주해 세그먼트를 재전송함

**파이프라이닝 전송**

<img width="339" alt="Image" src="https://github.com/user-attachments/assets/b1ef6bc7-2b21-4b69-b8bf-f063508b18f8" />

- '세그먼트 전송, 확인 응답 받기, 다음 순서번호 담은 세그먼트 전송' 의 과정은 한 번에 여러 세그먼트를 보낼 수 있는 상황에서도 확인 응답을 받기 전까지는 보낼 수 없다는 단점이 있음
- **파이프라이닝**: 확인 응답을 받기 전이라도 여러 메시지를 보내는 방식으로 송신하는 것

#### 2. 흐름 제어

- **흐름 제어**: 수신 호스트가 한 번에 받아 처리할 수 있을 만큼만 전송하는 것
- 수신 호스트가 한 번에 받을 수 있는 전송량은 TCP 수신 버퍼의 크기에 의해 결정됨, 수신 버퍼는 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시 저장되는 공간으로, 커널에 정의돼 있음
- 수신 호스트가 한 번에 받아 처리할 수 있는 양 어떻게 아는가: TCP 헤더의 윈도우 필드에 수신 호스트가 한 번에 처리할 수 있는 **수신 윈도우** 크기가 명시됨

#### 3. 혼잡 제어

- **혼잡**: 많은 트래픽으로 인해 패킷의 처리 속도가 느려지거나 유실될 수 있는 상황
- **혼잡 제어**: 혼잡을 제어하기 위한 기능
- 송신 호스트에서 네트워크가 혼잡함을 인지하는 상황
  1. 중복된 ACK 세그먼트가 도착했을 때
  2. 타임아웃이 발생했을 때
- 네트워크의 혼잡 가능성을 검출한 송신 호스트는 '혼잡 없이 전송할 수 있을 정도의 양'만큼만 송신함
- **혼잡 윈도우**: 혼잡 없이 전송할 수 있을 정도의 양
- 혼잡 윈도우가 크면 한 번에 전송할 수 있는 세그먼트의 수가 많음을 의미, 작으면 네트워크가 혼잡한 상황이므로 한 번에 전송할 수 있는 세그먼트의 수가 적음을 의미

**혼잡 제어 알고리즘**

- 혼잡 윈도우의 크기는 송신 호스트가 직접 계산해서 알아내야함
- 가장 대표적인 혼잡 제어 알고리즘: AIMD
- **AIMD(Additive Increase/Multiplicative Decrease)**: 합으로 증가 곱으로 감소

  <img width="317" alt="Image" src="https://github.com/user-attachments/assets/bece221c-dd45-4c9e-9923-b08ea3445cee" />

  - 세그먼트를 보내고 나서 혼잡이 감지되지 않으면 RTT마다 혼잡 윈도우를 1씩 선형적으로 증가시키고 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨림

- **RTT(Round Trip Time)**: 패킷을 보내고 그에 대한 응답이 수신되기까지의 시간

### TCP의 종료

- 4way handshake 방식

**단계**

<img width="389" alt="Image" src="https://github.com/user-attachments/assets/a4757b34-af82-4bb9-9aa6-65f29394aef1" />

1. [송수신 방향 A -> B] FIN 세그먼트

- 호스트 A는 FIN 비트가 1로 설정된 FIN 세그먼트를 호스트 B에게 전송

2. [송수신 방향 B -> A] ACK 세그먼트

- 1에 대한 호스트 B의 응답, 호스트 B는 ACK 세그먼트를 호스트 A에게 전송

3. [송수신 방향 B -> A] FIN 세그먼트

- 호스트 B는 FIN 세그먼트를 호스트 A에게 전송

4. [송수신 방향 A -> B] ACK 세그먼트

- 3에 대한 호스트 A의 응답, 호스트 A는 ACK 세그먼트를 호스트 B에게 전송

**액티브 클로즈**

- 연결을 종료하려는 호스트에 의해 수행되는 동작

**패시브 클로즈**

- 연결 종료 요청을 받아들이는 호스트에 의해 수행되는 동작

## TCP의 상태 관리

<img width="521" alt="Image" src="https://github.com/user-attachments/assets/923e300b-3063-4c74-8940-d2812d6378b9" />

<img width="461" alt="Image" src="https://github.com/user-attachments/assets/3bd66246-bc56-4e42-abdb-690f8374b943" />

- TCP의 중요한 특징: 상태를 유지함
- TCP는 상태를 유지하고 관리하는 프로토콜이라는 점에서 **스테이트풀 프로토콜**이라고도 부름
- TCP에서의 **상태**: 현재 어떤 통신 과정에 있는지를 나타내는 정보
- TCP에는 다양한 상태가 존재하고, 호스트는 TCP를 통한 송수신 과정에서 다양한 상태를 오가게됨

### 연결이 수립되지 않았을 때 주로 활용되는 상태

| 상태   | 설명                                                                          |
| ------ | ----------------------------------------------------------------------------- |
| CLOSED | 아무런 연결이 없는 상태                                                       |
| LISTEN | 연결 대기 상태(서버 쪽에 핸드셰이크의 첫 단계인 SYN 세그먼트를 대기하는 상태) |

- 패시브 오픈 호스트는 일반적으로 항상 LISTEN 상태로써 연결 요청(SYN)을 기다림

### 연결 수립 과정에서 주로 활용되는 상태

<img width="435" alt="Image" src="https://github.com/user-attachments/assets/2ac89ff0-2d6a-4566-a6a7-67784d460c5c" />

| 상태         | 설명                                                                                                             |
| ------------ | ---------------------------------------------------------------------------------------------------------------- |
| SYN-SENT     | 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤, 그에 대한 응답인 SYN + ACK 세그먼트를 기다리는 상태(연결 요청 전송) |
| SYN-RECEIVED | 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤, 그에 대한 ACK 세그먼트를 기다리는 상태(연결 요청 수신)        |
| ESTABLISHED  | 쓰리 웨이 핸드셰이크가 끝난 뒤 데이터를 송수신할 수 있는 상태(연결 수립)                                         |

### 연결 종료 과정에서 주료 활용되는 상태

<img width="443" alt="Image" src="https://github.com/user-attachments/assets/1ce4e881-15bb-44df-8ad1-d6afbf81708d" />

| 상태       | 설명                                                                                                                    |
| ---------- | ----------------------------------------------------------------------------------------------------------------------- |
| FIN-WAIT-1 | 액티브 클로즈 호스트가 FIN 세그먼트로 연결 종료 요청을 보낸 상태(연결 종료 요청 전송)                                   |
| CLOSE-WAIT | FIN 세그먼트를 받은 패시브 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태(연결 종료 요청 승인) |
| FIN-WAIT-2 | FIN-WAIT-1 상태에서 ACK 세그먼트를 받은 상태                                                                            |
| LAST-ACK   | CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 대기하는 상태                                                              |
| TIME-WAIT  | 액티브 클로즈 호스트가 마지막 ACK 세그먼트를 전송한 뒤 잠어드는 상태                                                    |

- 액티브 클로즈 호스트가 ACK을 보낸 뒤 TIME-WAIT 상태에서 일정 시간 뒤 CLOSED 상태가 되는 이유: 마지막 ACK 세그먼트가 올바르게 전송되지 않았을 경우 재전송이 필요하기 때문

# 5. 응용 계층 - HTTP의 기초

## DNS와 URI/URL

### 도메인 네임과 DNS

#### 도메인 네임

- 네트워크 상의 호스트를 식별하기 위해 사용되는 정보는 IP 주소
- 하지만 호스트의 IP 주소는 언제든 바뀔 수 있어 IP 주소만을 사용하기에는 번거롭기 때문에 **도메인 네임**을 사용함
- 도메인 네임: 'www.example.com', 'git.kernel.org'와 같은 문자열 형태의 호스트 특저 정보, 호스트의 IP 주소와 대응됨
- 도메인 네임은 IP 주소에 비해 기억이 쉬움, IP 주소가 바뀌어도 바뀐 IP 주소에 도메인 네임을 다시 대응하면 되므로 IP 주소만을 호스트로 특정하는 것보다 간편함

#### DNS

- **네임 서버(DNS 서버)**: 도메인 네임과 그에 대응되는 IP 주소를 관리하는 서버
- **리졸빙**: 도메인 네임에 대응되는 IP 주소를 알아내는 과정
- 도메인 네임과 도메인 네임을 관리하는 네임 서버는 계층적 구조를 가짐

**도메인 네임의 계층적 구조**

<img width="293" alt="Image" src="https://github.com/user-attachments/assets/7f2d7a6f-2818-42e7-8200-8b34fae06e4b" />

- 하나의 도메인 네임은 점(.)을 기준으로 계층적으로 분류되어 있음
- **루트 도메인**: 최상단, 주소 마지막에 점(.)으로 존재, 예를 들어 'www.gabia.com.' 에서 마지막 점
- **최상위 도메인(TopLevelDmain)**: 그 다음 단계, 예를 들어 'com, net, org, kr, jp, cn, us' 등
- **2단계 도메인(세컨드 레벨 도메인)**: 최상위 도메인의 하부 도메인
- **n단계 도메인**: n-1단계 도메인의 하부 도메인, 일반적으로 도메인의 단계는 3~5단계 정도로 구성됨
- **전체 주소 도메인 네임(Fully-Qualified Domain Name)**: 도메인 네임을 모두 포함하는 도메인 네임, FQDN을 알면 호스트를 식별할 수 있음
- **서브 도메인(≈하부 도메인)**: 다른 도메인이 포함된 도메인, 예를 들어 'mail.example.com, www.example.com, developer.example.com'은 모두 'example.com'의 서브 도메인

**네임 서버의 계층적 구조**

- 네임 서버는 여러 개가 존재하며, 전셰계 여러 곳에 분산되어 위치하며, 계층적임
- **도메인 네임 시스템(Domain Name System)**: 계층적으로 분산되어 있는 도메인 네임에 대한 관리 체계
- **로컬 네임 서버**: 클라이언트와 맞닿아 있는 네임 서버로
  - 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾게 되는 네임 서버
  - 많은 경우 ISP가 로컬 네임 서버의 주소를 자동으로 할당해줌
- **공개 DNS 서버**: 대표적으로 구글의 '8.8.8.8', '8.8.4.4'와 클라우드플레어의 '1.1.1.1' 등이 있음
- **루트 네임 서버**: 도메인 네임의 루트 도메인을 관장하는 서버
- **TLD 네임 서버**: 최상위 도메인을 관장하는 서버
- **n레벨 네임 서버**: 하위 레벨의 도메인네임을 관장하는 네임 서버 (n레벨은 그냥 내가 임의로 이름지은것임, 그냥 이러한 여러개의 네임 서버들이 있다는 의미)
- **리졸빙 방법**: 로컬 네임 서버가 질의 받은 도메인 네임에 대한 IP 주소를 모르는 경우, IP 주소를 알아낼 때까지 계층적인 도메인 네임 서버들에게 질의 반복

  <img width="544" alt="Image" src="https://github.com/user-attachments/assets/118fa0e3-3d31-4425-8552-adabc7cd1f8c" />

  1. 로컬 네임 서버 또는 공개 DNS 서버에게 도메인 네임 질의, FQDN에 대응하는 IP 주소 알고 있으면 클라이언트에게 즉시 해당 IP 주소 반환
  2. 로컬 네임 서버 또는 공개 DNS 서버가 IP 주소를 모르면 루트 네임 서버(.com 위치 질의) -> TLD 네임 서버(example.com 위치 질의) -> 하위 레벨(www.example.com 위치 질의)의 네임 서버 등에 걸쳐 질의하여 최종적으로 클라이언트가 원하는 IP 주소를 반환받으면 해당 주소를 클라이언트에게 전달

- **DNS 캐시**: 질의 과정이 많이 반복되면 네트워크 트래픽이 많아지고, 시간이 오래 걸리므로 캐시를 사용하는 경우가 많음, 클라이언트가 자주 접속하는 웹사이트와 같이 자주 질의되는 도메인 네임은 대부분 로컬 네임 서버 선에서 캐시돼있음

**DNS 레코드 타입**

<img width="410" alt="Image" src="https://github.com/user-attachments/assets/16e219d0-5df2-47f5-89ef-50e87449b8b5" />

<img width="407" alt="Image" src="https://github.com/user-attachments/assets/252fa21b-14ee-42f4-a07d-213ca6e14ea0" />

- 도메인 네임 구입 후, 구입한 도네인 네임이 서버 IP 주소에 대응된다는 사실을 네임 서버에 알려야함
- **DNS 자원 레코드**: IP 주소에 도메인 네임을 대응하기 위해서 설정해야하는 도메인 네임 관련 정보
- 레코드 유형: A, AAAA, CNAME, NS, MX 등
- TTL: DNS 레코드가 캐시될 수 있는 시간

### 자원과 URI/URL

- **자원**: 네트워크 상의 메시지를 통해 주고받는 최종 대상
  - HTML 파일, 이미지나 동영상 파일, 텍스트 파일 등등
  - 즉, 두 호스트가 네트워크를 통해 서로 정보를 주고받을 때 송수신하는 대상

#### URI(Uniform Resource Identifier)

- 웹 상에서의 자원을 식별하기 위한 정보
- URL 방식과 URN 방식이 있음

#### URL(Uniform Resource Locator)

- 위치로 자원을 식별하는 방식
- 오늘날 URN 보다 자원 식별에 많이 사용됨

**URL의 구조**: shceme, authority, path, query, fragment

<img width="564" alt="Image" src="https://github.com/user-attachments/assets/8f2ef8d4-94e7-4448-b091-e831ca33e259" />

1. **scheme**

- 자원에 접근하는 방법을 나타내며 일반적으로 프로토콜이 명시됨
- 예를 들어 shceme이 'http://'일 경우 HTTP를 사용하여 자원에 접근함을 나타내고 'https://'일 경우 HTTPS를 사용하여 자원에 접근함을 나타냄

2. **authority**

- 호스트를 특정할 수 있는 IP 주소나 도메인 네임이 명시됨
- 콜론(:) 뒤에 포트 번호를 명시할 수도 있음

3. **path**

- 자원이 위치하고 있는 경로가 명시됨
- 슬래시(/)를 기준으로 계층적으로 표현됨
- 예를 들어 http 프로토콜로 접근 가능한 도네인 네임 example.com의 자원 중 /home/images/a.png에 위치한 자원은 'http://example.com/home/images/a.png'로 표현할 수 있음

4. **query**

- scheme, authority, path만으로 정보를 식별하기 어려울 때 사용
- 쿼리 문자열, 쿼리 파라미터등으로도 불림
- 예를들어 상품 목록 중에서 '특정 상품을 검색한 뒤 그 결과를 내림차순으로 정렬한 결과'에 해당하는 자원을 나타낼 때 사용
- 물음표(?)로 시작되는 <키=값> 형태의 데이터로, 앰퍼샌드(&)를 사용하여 여러 쿼리 문자열을 연결할 수 있음

```
지역: location
침실 수: rooms
면적: size
최소 가격: min_price

http://example.com/search?location=seoul&rooms=2&size=100&min_price=200000
지역은 서울, 침실 수는 2개, 면적은 100, 최소 가격은 200000

상품 카테고리: category
브랜드: brand
할인 여부: discounted
정렬 순서: sorted

http://example.com/search?category=books&brand=hanbit&discounted=true&sorted=price_desc
카테고리는 도서, 브랜드는 한빛, 할인은 진행 중인 상품, 정렬은 가격별 내림차순
```

5. **fragment**

- 자원의 일부분, 자원의 한 조각을 가리키기 위한 정보
- 일반적으로 HTML 파일과 같은 자원에서 특정 부분을 가리키는 데 사용됨

```
(a) https://datatracker.ietf.org/doc/html/rfc3986
(b) https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.2
```

- a는 HTML 파일 자원 자체를 가리켜서 HTML의 첫 부분이 나타나지만 b는 HTML 자원의 특정 부분을 가리키므로 HTML 파일의 특정 부분으로 이동하여 보임

#### URN(Uniform Resource Locator)

- 이름으로 자원을 식별하는 방식
- 자원의 위치와 무관하게 자원을 식별할 수 있음
- 예시: 도서 번호 ISBN `urn:isbn:0451450523`

## HTTP의 특징과 메시지 구조

- HTTP의 목적: 애플리케이션의 다양한 자원을 네트워크를 통해 송수신 하는 것

### HTTP의 특징

1. 요청과 응답을 기반으로 동작
2. 미디어 독립적
3. 상태를 유지하지 않음
4. 지속 연결을 지원함

#### 1. 요청 응답 기반 프로토콜

- HTTP는 요청메시지를 보내는 클라이언트와 응답 메시지를 보내는 서버가 서로 HTTP 응답 메시지를 주고받는 구조로 작동함
- HTTP 요청 메시지와 HTTP 응답 메시지의 형태는 다름

#### 2. 미디어 독립적 프로토콜

- HTTP 메시지를 통해 HTML, PNG, JPEG 등 다양한 종류의 자원을 주고받을 수 있음
- HTTP는 주고받을 자원의 특성과 무관하게 자원을 주고받는 인터페이스의 역할만 수행함
- **미디어 타입(MIME 타입)**: HTTP 에서 메시지로 주고받는 자원의 종류

  - 슬래시를 기준으로 '타입/서브타입' 으로 구성됨
  - 타입: 데이터의 유형
  - 서브타입: 주어진 타입에 대한 세부 유형
    | 타입 | 타입 설명 | 서브타입 | 서브타입 설명 |
    |------|---------|----------|------------|
    | text | 일반 텍스트 형식의 데이터 | text/plain | 평문 텍스트 문서 |
    | | | text/html | HTML 문서 |
    | | | text/css | CSS 문서 |
    | | | text/javascript | 자바스크립트 문서 |
    | image | 이미지 형식의 데이터 | image/png | PNG 이미지 |
    | | | image/jpeg | JPEG 이미지 |
    | | | image/webp | WebP 이미지 |
    | | | image/gif | GIF 이미지 |
    | video | 비디오 형식의 데이터 | video/mp4 | MP4 비디오 |
    | | | video/ogg | OGG 비디오 |
    | | | video/webm | WebM 비디오 |
    | audio | 오디오 형식의 데이터 | audio/midi | MIDI 오디오 |
    | | | audio/wav | WAV 오디오 |
    | application | 바이너리 형식의 데이터 | application/octet-stream | 알 수 없는 바이너리 데이터를 표현한 일반적인 바이너리 데이터 |
    | | | application/pdf | PDF 문서 형식 데이터 |
    | | | application/xml | XML 형식 데이터 |
    | | | application/json | JSON 형식 데이터 |
    | | | application/x-www-form-urlencoded | HTML 입력 폼 데이터(가장 형태의 입력값을 URL 인코딩한 데이터) |
    | multipart | 각기 다른 미디어 타입을 가질 수 있는 여러 요소로 구성된 데이터 | multipart/form-data | HTML 입력 폼 데이터 |
    | | | multipart/encrypted | 암호화된 데이터 |

- **미디어 독립 프로토콜**: HTTP는 주고받을 미디어 타입에 특별한 제한을 두지 않고, 독립적으로 작동이 가능한 프로토콜

#### 3. 스테이트리스 프로토콜

- HTTP는 상태를 유지하지 않는 **스테이트리스 프로토콜**임
- 서버는 HTTP 요청을 보낸 클라이언트 관련 상태를 기억하지 않기 때문에 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주됨
- 상태를 유지하지 않는 이유:
  - 상태를 유지하면 서버에 부담됨, 서버가 여러개이면 처리하기 번거로움, 그렇다고 특정 서버하고만 상호작용하게 하면 문제 발생시 처리 어려움
  - 상태를 유지하지 않으면 클라이언트가 특정 서버에 종속되지 않으므로 서버의 추가나 대체가 쉬워짐(확장성), 서버 중 하나에 문제가 생기더라도 쉽게 다른 서버로 대체할 수 있음(견고성)

#### 4. 지속 연결 프로토콜

<img width="545" alt="Image" src="https://github.com/user-attachments/assets/868c6575-d42b-418b-8b3d-88a4bf9135ec" />

- 오늘날 많이 사용되는 HTTP 1.1과 2.0은 TCP를 기반으로 동작함
- TCP는 연결형 프로토콜이지만 HTTP는 비연결형 프로토콜이기 때문에 초기 HTTP 버전(HTTP 1.0 이하)에서는 3 way handshake를 통해 TCP 연결을 수립한 후, 요청에 대한 응답을 받으면 연결을 종료하는 방식으로 동작했음 -> 비지속 연결
- HTTP 버즌 1.1 이상에서는 지속 연결 기술을 제공함, 지속 연결은 하나의 TCP 연결 상에서 여러 개의 요청-응답을 주고받을 수 있는 기술을 의미함
- 지속 연결을 통해 비지속 연결보다 빠른 속도로 여러 HTTP의 요청과 응답을 처리할 수 있음

#### HTTP 버전별 특징

1. **HTTP 1.1**

- HTTP1.1부터 지속 연결 기능이 지원됨(이전에는 비지속 연결)
- 메시지를 평문으로 주고받음
- 콘텐츠 협상 기능 등 다양한 기능들이 추가됨

2. **HTTP 2.0**

- HTTP 1.1의 단점을 보완하고 개선하기 위한 버전
- **바이너리 데이터 기반 송수신**: 바이너리 데이터를 기반으로 메시지를 주고받음
- **헤더 압축**: 헤더를 압축하여 송수신할 수 있어 네트워크 이용 효율을 높일 수 있음
- **서버 푸시**: 클라이언트가 요청하지 않아도 미래에 필요할 것 같은 자원을 예상하여 미리 전송
  - 예를 들어 클라이언트가 index.html을 요청하면 styles.css나 script.js 파일도 같이 응답
- **HTTP 멀티플렉싱**: 여러 개의 독립적인 스트림을 바탕으로 요청-응답 메시지를 병렬적으로 주고받는 기술

  - 스트림: 요청과 응답을 주고받는 단위
  - HOL(Head-Of-Line blocking) 이라는 HTTP 1.1의 고질적인 문제를 완화함
  - HOL 블로킹: 같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 때, 첫 번째 패킷의 처리 지연으로 인해 나머지 패킷들의 처리도 모두 지연되는 문제 상황

  <img width="536" alt="Image" src="https://github.com/user-attachments/assets/5a7d33ed-8598-40f4-ba2f-bbd4e3bb16a8" />

3. **HTTP 3.0**

- UDP를 기반으로 구현된 QUIC(Quick UDP Internet Connections)라는 프로토콜을 기반으로 동작함
- UDP는 TCP에 비해 송수신 속도가 빠르기 때문에 속도 측면에서 큰 개선을 이룸

> UDP를 기반으로 어떻게 만들었을까?

### HTTP 메시지 구조

<img width="431" alt="Image" src="https://github.com/user-attachments/assets/835720c4-54b8-4c9b-9269-3e72c5cd6077" />

- 시작 라인, 필드 라인, 메시지 본문으로 구성됨
- 필드 라인은 여러 개가 존재할 수 있고, 메시지 본문은 없을 수 있음
- 메시지 본문: HTTP를 통해 주고받는 자원이 명시됨

#### 시작 라인

<img width="347" alt="Image" src="https://github.com/user-attachments/assets/544d0dd6-74b3-4a6f-b3ee-57558ee78efe" />

<img width="548" alt="Image" src="https://github.com/user-attachments/assets/37e5f2d1-47a2-4502-83ff-48933ec81aad" />

- 시작 라인으로 요청 메시지인지 응답 메시지인지 구분 가능
- 요청 라인: 요청 메시지이면 요청 라인
- 상태 라인: 응답 메시지이면 상태 라인
  - 예시: `HTTP/1.1 200 OK`, `HTTP/1.1 404 Not Found`

#### 필드 라인

- HTTP 헤더가 명시됨
- HTTP 헤더: 메시지 전송과 관련한 부가 정보이자 제어 정보, 콜론(:)을 기준으로 헤더 이름과 헤더 값으로 구성됨

```
Content-Type: text/html
Content-Length: 648
```
