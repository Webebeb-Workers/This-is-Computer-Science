# 데이터베이스의 큰 그림

## 데이터베이스와 DBMS

> [!NOTE]
> 데이터베이스는 여러 사람이 공유해 사용할 목적으로 체계화해 통합, 관리하는 데이터의 집합<br>
> 원하는 **기능을 동작시키기 위해 마땅히 저장해야 하는 정보의 집합**

데이터베이스는 웹 서비스에 있어 심장과 같은 역할 수행. 저장되는 데이터와 방식에 따라 서비스의 정체성과 성능이 달라짐. 이를 관리하기 위한 수단이 바로 DBMS - Database Management System.

### DBMS의 종류

DBMS는 크게 두 유형으로 구분 가능.

1. **관계형 데이터베이스 관리 시스템(RDBMS)**
   - MySQL, Oracle, PostgreSQL, SQLite, MariaDB, Microsoft SQL Server 등
2. **NoSQL 데이터베이스 관리 시스템**
   - MongoDB, Redis 등

2023년 개발자 설문조사에 따르면, RDBMS가 여전히 높은 점유율 차지. MySQL과 그 오픈소스 버전인 MariaDB의 합산 점유율이 가장 높음.

### 서버로서의 DBMS

DBMS는 일반 응용 프로그램과 달리 사용자의 프로그램과 상호작용하며 실행되는 특성 보유. 클라이언트-서버 모델과 유사하게 동작.

#### SQL(Structured Query Language)

RDBMS에서 데이터를 조작하고 관리하기 위한 언어로, 크게 네 종류로 분류.

- **데이터 정의 언어 - DDL(Data Definition Language)**: CREATE, ALTER, DROP, TRUNCATE
- **데이터 조작 언어 - DML(Data Manipulation Language)**: SELECT, INSERT, UPDATE, DELETE
- **트랜잭션 제어 언어 - DCL(Data Control Language)**: GRANT, REVOKE
- **데이터 제어 언어 - TCL(Transaction Control Language)**: COMMIT, ROLLBACK, SAVEPOINT

## 파일 대신 데이터베이스를 이용하는 이유

> [!NOTE]
> 단순 파일 입출력 대신 데이터베이스를 사용하는 이유는 다양한 데이터 관리 기능과 안정성, 효율성 때문

1. **데이터 일관성 및 무결성 제공이 어려움**
   - 여러 사용자/프로그램이 동시에 데이터 접근 시 레이스 컨디션 발생 가능성
   - 모든 접근에 동기화 도구 사용이 번거로움
   - 개발자가 데이터 무결성을 일일이 검사하기 어려움
2. **불필요한 중복 저장이 많아짐**
   - 파일로 데이터 관리 시 같은 정보가 여러 파일에 중복 저장되는 문제 발생
   - 이로 인해 저장 공간 낭비 초래
3. **데이터 변경 시 연관 데이터 변경이 어려움**
   - 한 파일의 데이터 변경 시 다른 파일에서도 관련 데이터를 일일이 변경해야 함
4. **정교한 검색이 어려움**
   - 복합 조건을 활용한 검색은 파일 검색으로 구현하기 어려움
5. **백업 및 복구가 어려움**
   - 데이터베이스는 백업과 복구 기능을 기본 제공하나, 파일 입출력은 이런 기능 부족

## 데이터베이스의 저장 단위와 트랜잭션

### 데이터베이스의 저장 단위

> [!NOTE]
> 데이터베이스에는 다양한 속성을 가진 독립적 객체인 엔티티가 저장, 이는 데이터베이스 유형에 따라 다른 형태로 구현

#### 주요 개념

- **엔티티(Entity)**: 독립적으로 존재할 수 있는 객체, 실세계의 객체를 데이터베이스에 표현
  - 제품, 사용자, 주문과 같이 독립적으로 어떠한 특성을 가진, 식별 가능한 대상을 의미
- **속성(Attribute)**: 엔티티의 특성
  - 같은 속성을 공유하는 개별 엔티티는 같은 엔티티 집합에 속함
- **엔티티 집합**: 같은 속성을 공유하는 개별 엔티티들의 모음

<img width="600" alt="image" src="https://github.com/user-attachments/assets/dc9bd19f-d47a-4b93-8ee2-f3c4dc6c886f" />

> [!TIP]
> 엔티티의 속성이 가질 수 있는 값의 집합은 도메인(domain)이라고 함 <br>
> 가령 '구매자 성별' 속성이 가질 수 있는 도메인은 {남자, 여자}임

### RDBMS와 NoSQL의 저장 단위 비교

엔티티들은 RDBMS에서는 테이블 안에, MongoDB에서는 컬렉션 안에 저장됨.

#### RDBMS의 저장단위

- **릴레이션(테이블)**: 이차원 테이블 형태의 엔티티 집합
- **레코드(행)**: 데이터베이스에 기록된 각각의 엔티티
- **필드(열)**: 데이터베이스에 저장된 엔티티 속성

#### NoSQL(MongoDB)의 저장단위

- **컬렉션**: 엔티티의 집합
- **도큐먼트**: JSON 형태의 엔티티
- **필드**: JSON의 키

> [!NOTE]
> 필드의 수는 차수(degree)라고도 부름<br>
> 한 필드에 대한 고유 값의 수는 카디날리티(Cardinality)라고 부름<br>
> 즉, 카디날리티가 낮을수록 중복된 속성이 많음을 시사함

### 스키마

> [!NOTE]
> 스키마는 데이터베이스에 저장되는 레코드의 구조와 제약 조건을 정의한 것으로, 레코드가 지켜야 할 틀이자 청사진

- **RDBMS**: 명확한 스키마 정의 필요, 모든 레코드가 동일한 구조 준수
- **NoSQL**: 스키마-리스(schema-less) 특성으로, 유연한 데이터 구조 허용

### 트랜잭션과 ACID

> [!NOTE]
> 트랜잭션은 데이터베이스와의 논리적 상호작용 단위로, 데이터베이스가 처리하는 작업의 단위

초당 트랜잭션(TPS, Transactions Per Second)이라는 지표로 데이터베이스의 작업 성능을 나타내기도 함.

> [!TIP]
> 트랜잭션이라는 용어나 TPS라는 지표는 주로 데이터베이스에서 언급되는 용어이지만, 데이터베이스에서만 사용되는 용어는 아님<br>
> 메모리 트랜잭션이나 전자상거래의 거래 단위로도 사용됨

트랜잭션이 지켜야 하는 ACID 특성은 아래와 같다.

#### 1. 원자성(Atomicity)

- 트랜잭션 결과가 모두 성공하거나 모두 실패하는 성질
- "All or Nothing" 원칙 준수
- 반드시 커밋되거나 롤백되는 성질

> [!TIP]
> 커밋(commit): 트랜잭션을 성공적으로 수행해 트랜잭션을 종료하는 것, 트랜잭션으로 인한 변경 사항을 확정<br>
> 롤백(rollback): 이전 트랜잭션을 취소하는 작업
>
> <img width="600" alt="image" src="https://github.com/user-attachments/assets/c3a4c50a-3f47-4ea0-b826-c6bfaa57019b" />

#### 2. 일관성(Consistency)

- 트랜잭션 전후로 데이터베이스가 일관된 상태 유지
- '일관된 상태'는 데이터베이스가 지켜야 하는 규칙들을 지키는 상태

#### 3. 격리성(Isolation)

- 동시에 수행되는 여러 트랜잭션이 서로 간섭하지 않도록 보장
- 레이스 컨디션 방지를 위한 성질

#### 4. 지속성(Durability)

- 트랜잭션이 성공적으로 완료된 후 결과가 영구적으로 반영
- 시스템 장애 발생 시에도 완료된 트랜잭션 결과는 보존

---

> [!TIP]
> 데이터베이스 학습 과정에서는 RDBMS의 기본, SQL, 효율적 쿼리, 데이터베이스 설계, NoSQL까지 단계적으로 학습 필요
> ![](https://github.com/user-attachments/assets/b57a694b-6ac4-45ae-bdc3-6e38f78912bd)

# SQL

> [!NOTE]
> SQL 명령은 크게 **DDL**(데이터 정의 언어), **DML**(데이터 조작 언어), **DCL**(데이터 제어 언어), **TCL**(트랜잭션 제어 언어)로 분류됨

## DDL(데이터 정의 언어)

> [!NOTE]
> DDL은 **데이터베이스와 테이블 같은 객체의 구조를 정의하는 SQL**

### 주요 명령어

| 종류     | 설명                                                      |
| -------- | --------------------------------------------------------- |
| CREATE   | 데이터베이스 혹은 데이터베이스 객체 생성                  |
| ALTER    | 데이터베이스 객체 갱신(테이블에 필드/제약 조건 추가/삭제) |
| DROP     | 데이터베이스 객체 삭제                                    |
| TRUNCATE | 테이블 구조를 유지한 채 모든 레코드 삭제                  |

> [!NOTE]
> 데이터베이스 객체란 데이터베이스에서 정의될 수 있는 대상을 통칭하는 용어임
> 테이블, 인덱스, 뷰 등이 대표적

### CREATE

#### 데이터베이스 생성

```sql
CREATE DATABASE 데이터베이스_이름;
CREATE DATABASE mydb;
```

- SQL문의 끝에는 세미콜론(;) 필수
- 생성된 데이터베이스 조회: `SHOW DATABASES;`
- 특정 데이터베이스 사용: `USE 데이터베이스_이름;`

#### 테이블 생성

기본 구문은 아래와 같다.

```sql
CREATE TABLE 테이블_이름 (
  필드_이름1 필드_타입,
  필드_이름2 필드_타입,
  필드_이름3 필드_타입,
  ...
);
```

#### 주요 제약 조건

특징 필드에 필드 타입을 입력해 제약 조건을 세울 수 있음.

| 키워드        | 제약 조건                           |
| ------------- | ----------------------------------- |
| PRIMARY KEY   | 특정 필드를 기본 키로 지정          |
| UNIQUE        | 특정 필드가 고유한 값을 갖도록 설정 |
| FOREIGN KEY   | 특정 필드를 외래 키로 지정          |
| DEFAULT       | 기본값 지정                         |
| NULL/NOT NULL | 특정 필드에 NULL 값을 허용/불허용   |

> [!TIP]
> UNIQUE 제약 조건이 명시된 필드는 고유 키(UNIQUE KEY)라고도 부름
> 고유 키는 중복값 불가능하지만, 기본 키와 달리 테이블 내 여러 개 존재 가능하고 NULL 값 허용

#### 실제 예제

<img width="600" alt="image" src="https://github.com/user-attachments/assets/de6b0bef-3d50-42f1-9ec1-8c039833c100" />

```sql
-- users 테이블 생성
CREATE TABLE users (
  user_id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) NOT NULL,
  email VARCHAR(100) UNIQUE,
  birthdate DATE,
  registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- posts 테이블 생성 (외래 키 포함)
CREATE TABLE posts (
  post_id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT,
  title VARCHAR(50) NOT NULL,
  content VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

- **AUTO_INCREMENT**: 레코드 추가 시 자동으로 1씩 증가
- **CURRENT_TIMESTAMP**: 현재 시간 자동 입력
- **FOREIGN KEY**: users 테이블의 user_id를 참조하는 외래 키 설정

#### 제약 조건 별도 정의 방식

```sql
CREATE TABLE tests (
  post_id INT AUTO_INCREMENT,
  user_id INT,
  title VARCHAR(50) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (post_id),
  CONSTRAINT FK_user FOREIGN KEY (user_id) REFERENCES users(user_id),
  CONSTRAINT UQ_title UNIQUE (title)
);
```

- **CONSTRAINT**: 제약 조건에 이름 부여 가능
- CREATE TABLE 하단에 제약 조건 추가적으로 명시 가능

### ALTER

**테이블 구조 변경**을 위한 명령어임.

#### 필드 관련 작업

```sql
-- 새로운 필드 추가
-- ALTER TABLE 테이블_이름 ADD COLUMN 필드_이름 필드_타입 [제약 조건]
ALTER TABLE posts ADD COLUMN new_field VARCHAR(50) NOT NULL;

-- 기존 필드 수정
-- ALTER TABLE 테이블_이름 CHANGE COLUMN 기존_필드_이름 새_필드_이름 필드_타입 [제약 조건]
ALTER TABLE posts CHANGE COLUMN new_field old_field VARCHAR(30) NOT NULL;

-- 기존 필드 삭제
-- ALTER TABLE 테이블_이름 DROP COLUMN 필드_이름
ALTER TABLE posts DROP COLUMN old_field;

-- 외래 키 제약 조건 추가
-- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_ 이름]
-- ADD FOREIGN KEY (필드_ 이름) REFERENCES 참조_테이블_이름(참조_필드)
ALTER TABLE posts ADD FOREIGN KEY (user_id) REFERENCES users(user_id);

-- UNIQUE 제약 조건 추가
-- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_이름] UNIQUE (필드_ 이름)
ALTER TABLE posts ADD UNIQUE (title);

-- NOT NULL 제약 조건 추가
-- ALTER TABLE 테이블_이름 MODIFY 필드_이름 필드_타입 NOT NULL
ALTER TABLE users MODIFY email VARCHAR(100) NOT NULL;

-- 기본 키 설정(PRIMARY KEY로 사용 중인 필드가 없을 경우
-- ALTER TABLE 테이블_이름 ADD PRIMARY KEY (필드_이름)
ALTER TABLE posts ADD PRIMARY KEY (post_id);
```

> [!TIP]
> ALTER문은 테이블뿐만 아니라 뷰, 인덱스 등 다른 데이터베이스 객체에도 적용 가능함

### DROP

**데이터베이스 객체를 완전히 삭제**하는 명령어임.

```sql
-- 데이터베이스 삭제
DROP DATABASE mydb;

-- 테이블 삭제
DROP TABLE 테이블_이름;
```

- 삭제 후 복구 불가능하므로 주의 필요
- DROP문도 테이블 외에 뷰, 인덱스 등에 적용 가능

### TRUNCATE

**테이블 구조는 유지하면서 모든 레코드만 삭제**함.

```sql
TRUNCATE TABLE 테이블_이름;
TRUNCATE TABLE users;
```

- 테이블의 구조(필드, 제약조건 등)는 그대로 유지
- 모든 데이터만 삭제돼 빈 테이블 상태가 됨
- `DESC 테이블_이름` 명령으로 테이블 구조 확인 시 여전히 표시됨

> [!NOTE]
> TRUNCATE는 `DELETE FROM 테이블_이름`과 유사하지만, 더 빠르고 로그를 적게 생성함
> 단, 조건절 사용 불가하고 전체 데이터만 삭제 가능함

## DML(데이터 조작 언어)

> [!NOTE]
> SQL DDL, DML, DCL 중 **기술 면접과 실무에서 가장 자주 언급되는 명령어 집합**

| 종류   | 설명                 |
| ------ | -------------------- |
| SELECT | 테이블의 레코드 조회 |
| INSERT | 테이블에 레코드 삽입 |
| UPDATE | 테이블의 레코드 수정 |
| DELETE | 테이블의 레코드 삭제 |

### INSERT

테이블에 **새로운 레코드를 삽입**하는 명령어임.

#### 기본 구문

```sql
-- 레코드 하나 삽입
INSERT INTO 테이블_이름(필드1, 필드2) VALUES (값1, 값2);

-- 여러 레코드 삽입
INSERT INTO 테이블_이름(필드1, 필드2, 필드3) VALUES
  (값1, 값2, 값3),
  (값1, 값2, 값3),
  (값1, 값2, 값3);
```

- 삽입할 값이 지정되지 않은 필드는 기본값으로 채워짐
- 기본값이 없으면 NULL로 채워짐

#### 실제 예제

```sql
-- users 테이블에 레코드 삽입
INSERT INTO users (username, email, birthdate) VALUES
  ('kim', 'kim@example.com', '1996-05-15');

-- 여러 레코드 한 번에 삽입
INSERT INTO users (username, email, birthdate) VALUES
  ('lee', 'lee@example.com', '1994-03-22'),
  ('park', 'park@example.com', '1988-07-11'),
  ('choi', 'choi@example.com', '2000-01-30'),
  ('jung', 'jung@example.com', '1992-12-05');
```

<img width="600" alt="image" src="https://github.com/user-attachments/assets/5dd9f76a-ee0e-4cd3-a8d0-103a123d1b51" />

> [!NOTE]
> 위 이미지에서, `user_id`와 `registration_date` 필드는 삽입할 데이터를 지정하지 않아도 기본값으로 각각 '1부터 증가하는 정수'와 '현재 시간'이 삽입

#### 외래 키 참조 상황

```sql
-- posts 테이블에 레코드 삽입 (외래 키 참조)
INSERT INTO posts (user_id, title, content) VALUES
  (1, 'Hi', 'Hello');
```

- `posts` 테이블의 `user_id`는 `users` 테이블의 `user_id`를 참조하는 외래 키
- 삽입할 레코드의 `user_id`가 `users` 테이블에 존재해야 함

#### 무결성 제약 조건

레코드 삽입 시 무결성 제약 조건을 지켜야 함.

```sql
-- NOT NULL 제약 조건 위배: 실행 안 됨
INSERT INTO users (username, email) VALUES
  (NULL, 'no_name@example.com');

-- UNIQUE 제약 조건 위배: 이미 존재하는 경우 실행 안 됨
INSERT INTO users (username, email) VALUES
  ('kim', 'kim@example.com');

-- 외래 키 제약 조건 위배: 참조할 레코드가 없으면 실행 안 됨
INSERT INTO posts (user_id, title, content) VALUES
  (10, 'Hi', 'Hello');
```

### UPDATE

**레코드를 수정**하는 SQL 명령임.

#### 기본 구문

```sql
UPDATE 테이블_이름
  SET 필드1 = 값1, 필드2 = 값2, ...
  WHERE 조건식;
```

- `WHERE` 절은 생략 가능하나, 생략 시 모든 레코드가 갱신됨
- `SET`의 `=`는 대입 연산자, `WHERE`의 `=`는 비교 연산자

#### 비교/논리 연산자

| 연산자              | 설명                                             |
| ------------------- | ------------------------------------------------ |
| =                   | 같을 경우 참                                     |
| >                   | 클 경우 참                                       |
| <                   | 작을 경우 참                                     |
| >=                  | 크거나 같을 경우 참                              |
| <=                  | 작거나 같을 경우 참                              |
| <>                  | 다를 경우 참                                     |
| 조건식1 AND 조건식2 | 조건식1과 조건식2가 모두 만족할 경우 참          |
| 조건식1 OR 조건식2  | 조건식1과 조건식2 둘 중 하나만 만족할 경우 참    |
| NOT 조건식          | 조건식이 아닐 경우 참                            |
| IN                  | IN 뒤에 명시되는 값과 하나 이상이 일치할 경우 참 |

#### 실제 예제

```sql
-- username이 'kim'인 사용자의 이메일 수정
UPDATE users
  SET email = 'kim_new@example.com'
  WHERE username = 'kim';

-- post_id가 5보다 큰 모든 게시글 제목 수정
UPDATE posts
  SET title = 'Updated Title'
  WHERE post_id > 5;
```

### DELETE

**조건에 맞는 레코드를 삭제**하는 명령임. UPDATE에서 사용한 논리/비교 연산자를 사용할 수 있는 등 명령 구조가 비슷하다.

#### 기본 구문

```sql
DELETE FROM 테이블_이름
  WHERE 조건식;
```

- `WHERE`절 생략 시 모든 레코드 삭제 => 대참사!

#### 실제 예제

```sql
-- title이 'Hi'인 게시글 삭제
DELETE FROM posts
  WHERE title = 'Hi';
```

### 외래 키 제약 조건 - ON UPDATE, ON DELETE

> [!WARNING]  
> 한 테이블이 다른 테이블을 외래 키로 참조하는 상황에서 참조되는 레코드가 수정/삭제될 경우, **참조하는 레코드의 동작을 정의**해야 함

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c0b2df6f-eac4-4ff0-8274-c97e0b47fa6f" />

| 제약 조건   | 설명                                       |
| ----------- | ------------------------------------------ |
| CASCADE     | 참조하는 데이터도 함께 수정/삭제           |
| SET NULL    | 참조하는 데이터를 NULL로 변경              |
| SET DEFAULT | 참조하는 데이터를 기본값으로 변경          |
| RESTRICT    | 수정/삭제를 허용하지 않음                  |
| NO ACTION   | (MySQL의 경우) 사실상 RESTRICT와 동일 동작 |

```sql
CREATE TABLE posts (
  post_id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT,
  title VARCHAR(50) NOT NULL,
  content VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
  ON UPDATE CASCADE    -- users의 user_id 수정 시 함께 수정
  ON DELETE SET NULL   -- users의 user_id 삭제 시 NULL로 변경
);
```

### SELECT

**삽입된 레코드를 조회**하는 **가장 중요**한 SQL 명령임.

#### 기본 구문

```sql
SELECT 필드1, 필드2, ...
  FROM 테이블_이름
  WHERE 조건식
  GROUP BY 그룹화할_필드
  HAVING 필터_조건
  ORDER BY 정렬할_필드
  LIMIT 레코드_제한;
```

- 필드에 `*` 사용 시 모든 필드 조회
- **실행 순서**: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

#### 기본 조회

```sql
-- 모든 레코드 조회
SELECT * FROM students;

-- 특정 필드만 조회
SELECT first_name, last_name, major
  FROM students
  WHERE major = 'Computer Science';

-- 조건부 조회
SELECT first_name, last_name, age
  FROM students
  WHERE age >= 21;
```

#### 패턴 검색: LIKE

WHERE에서는 `=`를 썼었는데, 이는 정확히 일치하는 것만 찾음. LIKE를 사용하면 **해당되는 패턴을 가진 값**들을 가져올 수 있음.

```sql
-- 'Science'라는 단어가 포함된 전공 검색
SELECT first_name, last_name, major
  FROM students
  WHERE major LIKE '%Science%';

-- 두 번째 문자가 'a'인 전공 검색
SELECT first_name, last_name, major
  FROM students
  WHERE major LIKE '_a%';
```

- `%`: 0개 이상의 임의의 문자와 일치
- `_`: 정확히 1개의 임의의 문자와 일치

#### 집계 함수

연산/집계 함수는 이름 그대로 조회된 레코드에 대한 **특정 연산을 수행하거나 집계**하는 함수.

| 함수  | 설명                        |
| ----- | --------------------------- |
| COUNT | 조회된 레코드 개수 반환     |
| SUM   | 조회된 레코드의 총합 반환   |
| AVG   | 조회된 레코드의 평균 반환   |
| MAX   | 조회된 레코드의 최댓값 반환 |
| MIN   | 조회된 레코드의 최솟값 반환 |

<img width="600" alt="image" src="https://github.com/user-attachments/assets/08b4fffd-b2f8-4b3a-bae5-618adfa41996" />

```sql
-- 학생 수, 평균 학점, 최고/최저 학점 조회
SELECT COUNT(*), AVG(gpa), MAX(gpa), MIN(gpa)
  FROM students;
```

조회된 속성의 이름을 정해주는, AS랑 많이 쓰인다.

### GROUP BY

**특정 필드를 기준**으로 **레코드를 그룹화**할 때 사용됨.

```sql
-- 전공별 학생 수 조회
SELECT major, COUNT(*) AS student_count
  FROM students
  GROUP BY major;

-- 나이별 학생 수 조회
SELECT age, COUNT(*) AS student_count
  FROM students
  GROUP BY age;
```

<img width="600" alt="image" src="https://github.com/user-attachments/assets/d27bdd56-b84d-42dc-98dc-b798d43c078a" />

### HAVING

**그룹화된 결과에 조건을 적용**할 때 사용됨.

```sql
-- 평균 GPA가 3.6 이상인 전공 조회
SELECT major, AVG(gpa)
  FROM students
  GROUP BY major
  HAVING AVG(gpa) >= 3.6;

-- 평균 나이가 21세 이상인 전공 조회
SELECT major, AVG(age)
  FROM students
  GROUP BY major
  HAVING AVG(age) >= 21;
```

> [!TIP]
> WHERE절은 그룹화 전 개별 레코드에 대한 조건이며, HAVING절은 **그룹화된 레코드에 대한 조건**임

### ORDER BY

특정 필드를 기준으로 **레코드를 정렬**할 때 사용됨.

```sql
-- GPA 기준 내림차순 정렬
SELECT first_name, last_name, gpa
  FROM students
  ORDER BY gpa DESC;

-- 성 기준 오름차순 정렬
SELECT first_name, last_name, major
  FROM students
  ORDER BY last_name ASC;
```

- 기본값은 오름차순(ASC) 정렬
- DESC 키워드로 내림차순 정렬 가능

### LIMIT

**조회할 레코드 수를 제한**할 때 사용됨.

```sql
-- 상위 3개 레코드만 조회
SELECT * FROM students LIMIT 3;

-- 3번째 레코드부터 2개 조회 (시작점 지정)
SELECT * FROM students LIMIT 2, 2;
```

---

> [!WARNING]
> SELECT문의 실제 실행 순서는 작성 순서와 다름
> 이에 유의하지 않으면 예기치 못한 성능 저하나 의도하지 않은 결과가 발생할 수 있음
>
> 작성 순서: SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY → LIMIT
> 실행 순서: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

## TCL(트랜잭션 제어 언어)

TCL(Transaction Control Language)은 **트랜잭션을 제어**하는 SQL 명령들을 포함함.

| 종류      | 설명                      |
| --------- | ------------------------- |
| COMMIT    | 데이터베이스에 작업 반영  |
| ROLLBACK  | 작업 이전의 상태로 되돌림 |
| SAVEPOINT | 롤백의 기준점 설정        |

한 트랜잭션에는 여러 쿼리가 포함될 수 있으며, 모든 작업이 성공하거나 모두 실패하는 원자성을 보장함.

### 트랜잭션 기본 개념

#### 트랜잭션 시작

```sql
-- 트랜잭션 시작 (둘 다 같은 의미)
START TRANSACTION;
-- 또는
BEGIN;
```

- DBMS에게 트랜잭션이 시작됨을 알리는 명령
- 이후 실행되는 SQL문들은 하나의 트랜잭션으로 묶임

#### 예제: 계좌 이체

```sql
-- accounts 테이블 생성 및 데이터 삽입
CREATE TABLE accounts (
  account_id INT PRIMARY KEY,
  account_name VARCHAR(50),
  balance INT
);

INSERT INTO accounts (account_id, account_name, balance) VALUES
  (1, 'Kim', 1000),
  (2, 'Lee', 500);
```

계좌 이체는 두 개의 UPDATE문이 함께 실행돼야 하는 트랜잭션의 대표적 예시임.

```sql
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
```

### COMMIT

트랜잭션이 성공적으로 완료돼 **모든 변경 사항을 데이터베이스에 영구적으로 반영**함.

```sql
START TRANSACTION;

-- 시점 1: 2개의 레코드 확인
SELECT * FROM accounts;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- 시점 2: 두 UPDATE문이 실행되었음을 확인
SELECT * FROM accounts;

COMMIT;

-- 시점 3: accounts 테이블은 시점 2와 같음
SELECT * FROM accounts;
```

### ROLLBACK

트랜잭션에서 **수행된 변경 사항을 취소**하고, 데이터베이스를 트랜잭션 시작 **이전 상태로 되돌림**.

```sql
START TRANSACTION;

-- 시점 1: 2개의 레코드 확인
SELECT * FROM accounts;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;

-- 시점 2: account_id가 1인 레코드의 balance가 100 감소
SELECT * FROM accounts;

ROLLBACK;

-- 시점 3: accounts 테이블은 시점 1과 같음 (UPDATE 취소)
SELECT * FROM accounts;
```

### SAVEPOINT

SAVEPOINT는 ROLLBACK으로 되돌아갈 **중간 지점을 설정하는 기능**임. 트랜잭션 내 특정 시점으로 **부분적 롤백이 가능**함.

#### 기본 구문

```sql
-- 세이브포인트 생성
SAVEPOINT 세이브포인트_이름;

-- 세이브포인트로 롤백
ROLLBACK TO SAVEPOINT 세이브포인트_이름;
```

#### 예제

```sql
START TRANSACTION;

-- 세이브포인트 생성 1
SAVEPOINT sp1;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- 세이브포인트 생성 2
SAVEPOINT sp2;
UPDATE accounts SET account_name = 'new_Kim' WHERE account_id = 1;
UPDATE accounts SET account_name = 'new_Lee' WHERE account_id = 2;

-- 세이브포인트 생성 3
SAVEPOINT sp3;
SELECT * FROM accounts;

-- 특정 세이브포인트로 롤백 (최근 변경사항만 취소)
ROLLBACK TO SAVEPOINT sp2;  -- sp3의 변경사항 취소
ROLLBACK TO SAVEPOINT sp1;  -- sp2의 변경사항 취소
```

### 자동 커밋(Auto Commit)

> [!WARNING]
> MySQL에서는 기본적으로 자동 커밋이 활성화돼 있어, 매 SQL문이 자동으로 커밋됨
> DDL문은 항상 자동으로 커밋되며 롤백할 수 없음

#### 자동 커밋 제어

```sql
-- 자동 커밋 비활성화
SET autocommit = 0;

-- 자동 커밋 활성화
SET autocommit = 1;
```

- `START TRANSACTION` 또는 `BEGIN` 실행 시 자동으로 자동 커밋이 비활성화됨
- 트랜잭션 내에서는 `COMMIT`이나 `ROLLBACK`을 만나기 전까지 커밋되지 않음

> [!TIP]
> DDL(Data Definition Language) 문장들은 항상 자동으로 커밋됨
> CREATE, ALTER, DROP, TRUNCATE 등의 DDL문은 실행 즉시 현재 트랜잭션을 종료하고 변경사항을 확정함

## 데이터 제어 언어(DCL)

DCL(Data Control Language)은 데이터베이스 사용자의 권한을 관리하는 SQL 명령어 집합임.

| 종류   | 설명                   |
| ------ | ---------------------- |
| GRANT  | 사용자에게 권한 부여   |
| REVOKE | 사용자로부터 권한 회수 |

DBMS는 서버처럼 사용자 계정과 권한을 관리함.

### 사용자 관리

```sql
-- 사용자 생성
CREATE USER '사용자명'@'호스트' IDENTIFIED BY '비밀번호';

-- 사용자 삭제
DROP USER '사용자명'@'호스트';
```

### 권한 관리

```sql
-- 권한 부여
GRANT 권한목록 ON 데이터베이스.테이블 TO '사용자명'@'호스트';

-- 권한 회수
REVOKE 권한목록 ON 데이터베이스.테이블 FROM '사용자명'@'호스트';
```

DCL을 통해 각 사용자별로 사용 가능한 SQL 명령을 제한하고, 데이터베이스 보안을 관리할 수 있음.

# 효율적 쿼리

효율적으로, DB에게 질의할 수 있도록 서브 쿼리, 조인, 뷰, 인덱스를 살펴보자.

## 서브 쿼리와 조인

> [!NOTE]
>
> - 서브 쿼리(subquery): **다른 SQL문이 포함된 SQL문**
> - 조인(join): **2개의 테이블을 하나로 합치는 것**

이들은 여러 테이블에 질의하는 등 데이터베이스에 복잡한 요청을 해야 할 때 유용하게 사용됨.

### 여러 테이블에 질의하기

실제 데이터베이스를 다룰 때는 여러 테이블을 대상으로 작업하는 것이 일반적임. 특히 여러 테이블을 대상으로 SELECT문을 사용하는 경우가 많음.

하나의 SELECT문으로 여러 테이블 레코드를 조회하는 명령은 간단함.

- FROM절에 여러 테이블의 이름을 명시
- 조회하고자 하는 테이블의 필드는 `테이블_이름.필드` 형식으로 명시
- WHERE절을 통해 테이블 간 조건 설정

```sql
-- 기본 구조
SELECT 테이블1.필드1, 테이블1.필드2, 테이블2.필드3
FROM 테이블1, 테이블2
WHERE 테이블1.필드1 = 테이블2.필드2;

-- 실제 예제
SELECT users.username, users.email, posts.title
FROM users, posts
WHERE users.user_id = posts.user_id;
```

### 서브 쿼리

> [!NOTE]
> 서브 쿼리는 **내부에 다른 SQL문이 포함돼 있는 SQL문**

MySQL에서는 '다른 SQL문 안에 있는 SELECT문'으로 정의하며, 소괄호로 감싸 외부 쿼리와 구분함.

#### 참고: 기존 테이블 구조

```sql
-- db/create_insert_users_posts.sql

-- 사용자 테이블 생성
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    birthdate DATE,
    registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 게시글 테이블 생성
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    title VARCHAR(50) NOT NULL,
    content VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- 사용자 데이터 삽입
INSERT INTO users (username, email, birthdate) VALUES
    ('kim', 'kim@example.com', '1990-01-01'),
    ('lee', 'lee@example.com', '1985-05-15'),
    ('park', 'park@example.com', '1992-08-22');
    ...

-- 게시글 데이터 삽입
INSERT INTO posts (user_id, title, content) VALUES
    (1, 'One', 'This is the content of the first post.'),
    (1, 'Two', 'This is the content of the second post.'),
    (2, 'Three', 'This is a post by lee.'),
    (3, 'Four', 'This is a post by park.');
    ...
```

#### 서브 쿼리의 유형

1. **SELECT 안에 SELECT문이 포함된 서브 쿼리**

   ```sql
   SELECT
       users.username,
       (SELECT COUNT(*)
        FROM posts
        WHERE posts.user_id = users.user_id) AS post_count
   FROM users;
   ```

   사용자별로 작성한 글의 개수를 조회하는 SQL문임.

2. **DELETE 안에 SELECT문이 포함된 서브 쿼리**
   ```sql
   DELETE FROM posts
   WHERE user_id = (
       SELECT user_id
       FROM users
       WHERE email = 'kim@example.com'
   );
   ```
   특정 이메일을 가진 사용자의 모든 글을 삭제하는 SQL문임.

### 조인

> [!NOTE]
> 조인(JOIN)은 **여러 테이블을 하나로 합치는 연산**

크게 **INNER** 조인과 **OUTER** 조인(**LEFT, RIGHT, FULL**)으로 구분됨.

#### 조인의 종류

<img width="700" alt="image" src="https://github.com/user-attachments/assets/b1644853-e753-44cf-bab9-39f6ed191b36" />

#### 참고: 기존 테이블 데이터

<img width="700" alt="image" src="https://github.com/user-attachments/assets/fbecda46-7748-44be-84d0-1320023a2ec0" />

#### INNER 조인 예제

```sql
SELECT customers.name, customers.age, customers.email, orders.id, orders.product_id, orders.quantity, orders.amount
FROM customers
INNER JOIN orders ON customers.id = orders.customer_id;
```

| name | age | email            | id  | product_id | quantity | amount |
| ---- | --- | ---------------- | --- | ---------- | -------- | ------ |
| kim  | 30  | kim@example.com  | 1   | 1          | 10       | 1000   |
| lee  | 25  | lee@example.com  | 2   | 2          | 20       | 2000   |
| lee  | 25  | lee@example.com  | 3   | 3          | 30       | 3000   |
| park | 40  | park@example.com | 4   | 4          | 40       | 4000   |
| park | 40  | park@example.com | 5   | 5          | 50       | 5000   |
| kang | 20  | kang@example.com | 6   | 6          | 60       | 6000   |
| kang | 20  | kang@example.com | 7   | 7          | 70       | 7000   |
| kwon | 18  | kwon@example.com | 8   | 8          | 80       | 8000   |
| kwon | 18  | kwon@example.com | 9   | 9          | 90       | 9000   |

WHERE 등 **조건 필터링 추가**도 할 수 있다.

```sql
SELECT customers.name, customers.age, customers.email, orders.id, orders.product_id, orders.quantity, orders.amount
FROM customers
INNER JOIN orders ON customers.id = orders.customer_id
WHERE orders.amount >= 5000;
```

| name | age | email            | id  | product_id | quantity | amount |
| ---- | --- | ---------------- | --- | ---------- | -------- | ------ |
| park | 40  | park@example.com | 5   | 5          | 50       | 5000   |
| kang | 20  | kang@example.com | 6   | 6          | 60       | 6000   |
| kang | 20  | kang@example.com | 7   | 7          | 70       | 7000   |
| kwon | 18  | kwon@example.com | 8   | 8          | 80       | 8000   |
| kwon | 18  | kwon@example.com | 9   | 9          | 90       | 9000   |

#### LEFT OUTER 조인 예제

LEFT OUTER 조인은 **테이블1의 모든 레코드를 기준**으로 테이블2의 레코드를 합치되, **테이블2에 대응되는 레코드가 없다면 해당 값을 NULL로 간주**하는 조인 방식.

```sql
SELECT customers.name, orders.id AS order_id, orders.product_id, orders.quantity, orders.amount
FROM customers
LEFT OUTER JOIN orders ON customers.id = orders.customer_id;
```

| name | order_id | product_id | quantity | amount |
| ---- | -------- | ---------- | -------- | ------ |
| kim  | 1        | 1          | 10       | 1000   |
| lee  | 3        | 3          | 30       | 3000   |
| lee  | 2        | 2          | 20       | 2000   |
| park | 5        | 5          | 50       | 5000   |
| park | 4        | 4          | 40       | 4000   |
| kang | 7        | 7          | 70       | 7000   |
| kang | 6        | 6          | 60       | 6000   |
| kwon | 9        | 9          | 90       | 9000   |
| kwon | 8        | 8          | 80       | 8000   |
| gwak | NULL     | NULL       | NULL     | NULL   |
| na   | NULL     | NULL       | NULL     | NULL   |
| jo   | NULL     | NULL       | NULL     | NULL   |
| yang | NULL     | NULL       | NULL     | NULL   |

> [!TIP]
> LEFT OUTER 조인은 '기준이 되는 테이블(customers)'의 모든 레코드를 보여주므로, 주문이 없는 고객들도 NULL 값으로 표시됨
> 사담) 이는 고객 전체 목록을 유지하면서 주문 정보를 확인할 때 유용할 거 같음

#### RIGHT OUTER 조인 예제

LEFT와 정확히 반대. **테이블2의 레코드를 모두 선택하고, 이를 기준**으로 테이블1를 합치되 **대응되는 레코드가 없다면 NULL**이 되는 조인 방식.

```sql
SELECT customers.name, orders.id AS order_id, orders.product_id, orders.quantity, orders.amount
FROM customers
RIGHT OUTER JOIN orders ON customers.id = orders.customer_id;
```

| name | order_id | product_id | quantity | amount |
| ---- | -------- | ---------- | -------- | ------ |
| kim  | 1        | 1          | 10       | 1000   |
| lee  | 2        | 2          | 20       | 2000   |
| lee  | 3        | 3          | 30       | 3000   |
| park | 4        | 4          | 40       | 4000   |
| park | 5        | 5          | 50       | 5000   |
| kang | 6        | 6          | 60       | 6000   |
| kang | 7        | 7          | 70       | 7000   |
| kwon | 8        | 8          | 80       | 8000   |
| kwon | 9        | 9          | 90       | 9000   |
| NULL | 10       | 9          | 90       | 9000   |

#### FULL OUTER 조인 구현

FULL OUTER 조인은 기본적으로 **두 테이블의 모든 레코드를 선택**하되, **대응되지 않는 모든 레코드를 NULL**로 표기하는 조인 방식.

**MySQL**은 FULL OUTER 조인을 직접 지원하지 않으므로, **LEFT와 RIGHT 조인을 UNION**으로 결합해 구현함.

```sql
SELECT 필드
FROM 테이블1
  LEFT JOIN 테이블2 ON 조인 조건
  UNION
SELECT 필드
FROM 테이블1
  RIGHT JOIN 테이블2 ON 조인 조건;
```

```sql
SELECT customers.name, orders.id AS order_id, orders.product_id, orders.quantity, orders.amount
FROM customers
  LEFT OUTER JOIN orders ON customers.id = orders.customer_id
  UNION
SELECT customers.name, orders.id AS order_id, orders.product_id, orders.quantity, orders.amount
FROM customers
  RIGHT OUTER JOIN orders ON customers.id = orders.customer_id;
```

| name | order_id | product_id | quantity | amount |
| ---- | -------- | ---------- | -------- | ------ |
| kim  | 1        | 1          | 10       | 1000   |
| lee  | 3        | 3          | 30       | 3000   |
| lee  | 2        | 2          | 20       | 2000   |
| park | 5        | 5          | 50       | 5000   |
| park | 4        | 4          | 40       | 4000   |
| kang | 7        | 7          | 70       | 7000   |
| kang | 6        | 6          | 60       | 6000   |
| kwon | 9        | 9          | 90       | 9000   |
| kwon | 8        | 8          | 80       | 8000   |
| gwak | NULL     | NULL       | NULL     | NULL   |
| na   | NULL     | NULL       | NULL     | NULL   |
| jo   | NULL     | NULL       | NULL     | NULL   |
| yang | NULL     | NULL       | NULL     | NULL   |
| NULL | 10       | 9          | 90       | 9000   |

### 서브 쿼리와 조인의 상호 대체 가능

일부 서브 쿼리 연산은 조인으로 대체 가능함. 예를 들어, 사용자별 작성 글 개수를 조회하는 서브 쿼리는 다음과 같은 조인으로 대체 가능:

```sql
-- 서브 쿼리 대신 조인 사용
SELECT users.username, COUNT(posts.post_id) AS post_count
FROM users
  LEFT JOIN posts ON users.user_id = posts.user_id
  GROUP BY users.username;
```

| username | post_count |
| -------- | ---------- |
| kim      | 2          |
| lee      | 1          |
| park     | 1          |

> [!TIP]
> 사담)
> 성능상 조인이 서브 쿼리보다 효율적인 경우가 많으므로, 가능하다면 조인을 사용하는 것이 권장됨
> 특히 대용량 데이터를 다룰 때는 조인의 성능 이점이 더욱 두드러짐

## 뷰(View)

> [!NOTE]
> 뷰(View)는 **SELECT문의 결과로 만들어진 가상의 테이블**임
> SELECT문의 결과를 뷰로 생성한 뒤, 해당 뷰에 다양한 SQL문을 실행할 수 있음

뷰는 주로 **테이블에 대한 SQL문을 단순화**하기 위해 사용됨. 특히 여러 테이블을 조인하거나 복잡한 조건식을 사용한 SQL문을 하나의 뷰로 만들어 두면, 이후 복잡한 SQL문을 반복적으로 작성하는 대신 보다 단순하게 동일한 결과를 얻을 수 있음.

### 뷰 생성 및 활용

**뷰 생성 문법**은 아래와 같다. 테이블 생성 삭제와 비슷하다.

```sql
CREATE VIEW 뷰_이름 AS SELECT문; -- 생성
DROP VIEW 뷰_이름 AS SELECT문; -- 삭제
```

#### 예제: 복잡한 조인을 뷰로 단순화

```sql
-- 뷰 생성
CREATE VIEW myview AS
SELECT users.username, users.email, posts.title
FROM users, posts
WHERE users.user_id = posts.user_id;

-- 생성된 뷰 활용
SELECT username, email, title
FROM myview
WHERE username = 'kim';
```

| username | email           | title |
| -------- | --------------- | ----- |
| kim      | kim@example.com | One   |
| kim      | kim@example.com | Two   |

### 뷰의 활용 목적

<img width="600" alt="image" src="https://github.com/user-attachments/assets/f6a9806b-8a04-41cb-bb39-c501af8edf75" />

1. **쿼리 단순화 및 재사용성 향상**
   - 복잡한 조인이나 서브쿼리를 뷰로 저장해 간단하게 재사용 가능
   - 반복적인 쿼리 작성 시간 절약
2. **데이터 보안 및 접근 제어**
   - 테이블의 특정 필드만 노출하고 싶을 때 뷰 생성
   - 민감한 정보는 제외하고 필요한 데이터만 사용자에게 제공
   ```sql
   -- 예: 학생 정보에서 주소와 같은 민감한 정보 제외
   CREATE VIEW student_basic_info AS
   SELECT 이름, 나이, 학년
   FROM students;
   ```

### 뷰 사용 시 제약사항

> [!WARNING]
> 뷰에 대한 조회(SELECT)에는 제한이 없지만, 삽입(INSERT), 수정(UPDATE), 삭제(DELETE) 등이 불가능할 수도 있음

특히 여러 테이블을 조인한 결과로 만들어진 뷰의 경우, **DML 연산이 제약 조건을 어기기 쉬움**.

```sql
-- 에러 예시
mysql> INSERT INTO myview (username, email, title) VALUES ('new_user', 'new_user@example.com', 'New Post');
ERROR 1393 (HY000): Can not modify more than one base table through a join view 'mydb.myview'

mysql> DELETE FROM myview WHERE username = 'some_user';
ERROR 1395 (HY000): Can not delete from join view 'mydb.myview'
```

## 인덱스(Index)

> [!NOTE]
> 인덱스(Index)는 **검색 속도 향상을 목적으로 만드는 하나 이상의 테이블 필드에 대한 자료구조**
> 책의 '찾아보기'와 유사한 개념으로, 특정 필드를 기준으로 빠른 레코드 조회가 가능함

<img width="600" alt="image" src="https://github.com/user-attachments/assets/cfb6edfe-c9b9-4d20-87be-658c7a812042" />

실제로는 B 트리나 그 변형을 많이 사용한다.

### 인덱스의 원리

인덱스는 책의 '목차', '찾아보기'처럼 작동함.

- 찾아보기의 '용어' = 데이터베이스의 '필드'
- 찾아보기의 '페이지' = 찾고자 하는 '레코드'

인덱스가 없다면 최악의 경우 원하는 레코드를 찾기 위해 모든 레코드를 탐색해야 함. => Full Table Scan

### 인덱스의 종류

MySQL에서는 인덱스를 크게 두 가지로 구분.

1. **클러스터형 인덱스(Clustered Index)**
   - 테이블당 하나만 생성 가능
   - 기본 키(PRIMARY KEY)가 자동으로 클러스터형 인덱스가 됨
   - 만약 기본 키가 없으면 NOT NULL + UNIQUE 필드가 클러스터형 인덱스가 됨
2. **세컨더리 인덱스(Secondary Index)**
   - 논클러스터형 인덱스(Non-clustered Index)라고도 함
   - 테이블당 여러 개 생성 가능
   - 클러스터형 인덱스보다 일반적으로 느림

### 인덱스로 사용되는 자료구조

> [!NOTE]
> 인덱스로 사용되는 대표적인 자료구조는 **해시 테이블**과 **B-트리**임
> 특히 MySQL을 비롯한 많은 DBMS에서는 **B-트리**(혹은 B+ 트리와 같은 B-트리의 변형)를 사용함

#### B-트리 기반 인덱스의 동작 원리

'제품' 테이블에서 '제품 번호'를 기본 키로 하는 클러스터형 인덱스 생성한다고 가정한다.

| 제품 번호 | 제품 이름        | 제조사     |
| --------- | ---------------- | ---------- |
| 1         | 키보드           | 엘디       |
| 2         | 모니터           | 샘숭       |
| 3         | 혼공컴운         | 한빛미디어 |
| 4         | 혼공네트         | 한빛미디어 |
| 5         | 이것이컴퓨터과학 | 한빛미디어 |
| 6         | 스마트폰         | 애불       |
| 7         | 귤               | 제주도     |

**생성되는 B-트리 구조**는 아래와 같다.

```
      [3]
    /      \
[1,2]     [5,6,7]
  |         |
레코드      레코드
 위치        위치
```

### B-트리 인덱스의 특징

인덱스로 주로 사용되는 자료구조는 B-트리(또는 B+ 트리)임.

1. **각 노드의 구성**
   - 키(인덱스 값) 포함
   - 실제 데이터(레코드) 위치 정보 저장
2. **빠른 검색 가능**
   - B-트리의 특성상 다량의 노드에 대한 빠른 검색 가능
   - 정렬된 상태 유지로 범위 검색에도 효율적
3. **균형 트리 구조**
   - 모든 리프 노드까지의 거리가 동일
   - O(log n) 시간 복잡도로 검색 가능

<img width="600" alt="image" src="https://github.com/user-attachments/assets/35028d08-7271-4115-ac21-66538050733a" />

대부분의 RDBMS가 B-트리를 선택하는 이유는 범위 검색과 정렬이 중요하기 때문임.
SQL에서 WHERE 절의 범위 조건이나 ORDER BY 절을 효율적으로 처리하기 위해서는 B-트리가 더 적합함.
B-트리의 특성상 다량의 노드에 대한 빠른 검색이 가능해, 인덱스를 바탕으로 레코드 위치를 빠르게 찾을 수 있음.

> [!TIP]
> 실제 DBMS에서는 B-트리보다 **B+ 트리**를 더 많이 사용함
> B+ 트리는 B-트리의 변형으로, 리프 노드에만 실제 데이터 포인터를 저장하는 특징이 있음

### 인덱스 관리 명령어

```sql
-- 인덱스 생성
CREATE INDEX 인덱스_이름 ON 테이블_이름(필드);

-- 인덱스 조회
SHOW INDEX FROM 테이블_이름;

-- 인덱스 삭제
DROP INDEX 인덱스_이름 FROM 테이블_이름;
```

### 인덱스의 성능 개선 효과

70만 개 레코드가 있는 테이블에서의 성능 비교를 해보자.

#### 인덱스 생성 전

```sql
mysql> SELECT * FROM users WHERE nickname='User290526U';
-- 소요 시간: 0.21초

mysql> SELECT COUNT(*) FROM users WHERE age>50;
-- 소요 시간: 0.22초

mysql> SELECT COUNT(*) FROM users WHERE gender='male';
-- 소요 시간: 0.19초
```

#### nickname 필드에 인덱스 생성 후

```sql
-- 인덱스 생성
mysql> CREATE INDEX idx_user ON users(nickname);

mysql> SELECT * FROM users WHERE nickname='User290526U';
-- 소요 시간: 0.00초 (즉시 조회!)

mysql> SELECT COUNT(*) FROM users WHERE age>50;
-- 소요 시간: 0.20초 (변화 없음)

mysql> SELECT COUNT(*) FROM users WHERE gender='male';
-- 소요 시간: 0.19초 (변화 없음)
```

### 인덱스 사용 시 고려사항

인덱스는 양날의 검과 같음. 올바르게 사용하면 성능이 향상되지만, 잘못 사용하면 오히려 **성능이 저하**됨.

#### 인덱스의 장점

- SELECT 쿼리의 성능 향상
- WHERE, ORDER BY, GROUP BY 절에서 빠른 처리
- 조인 성능 개선

#### 인덱스의 단점

- 저장 공간 추가 필요
- INSERT, UPDATE, DELETE 시 성능 저하
- 인덱스 유지 및 갱신에 추가 자원 필요

### 인덱스 사용 권장 사항

#### 인덱스가 효과적인 경우

- 데이터가 충분히 많은 테이블 (최소 수천 개 이상)
- 조회(SELECT)가 빈번한 테이블
- **WHERE, ORDER BY, JOIN**에 자주 사용되는 필드
- 중복도가 낮은 필드 (unique한 값이 많은 필드)

#### 인덱스 사용을 피해야 하는 경우

- 데이터가 적은 테이블
- INSERT, UPDATE, DELETE가 빈번한 테이블
- 중복 데이터가 많은 필드
- 테이블당 인덱스 개수는 3개 이하로 제한 권장

# ER Diagram

> [!NOTE]
> ERD는 데이터베이스에 저장되는 **엔티티의 구조를 모델링**하기 위한 도구
> 데이터베이스 설계 초기 단계에서 중요한 역할 수행

## ERD의 중요성

- 데이터베이스 구조의 명확한 정의 가능
- 확장/수정 시 영향 범위 파악 용이
- 유지보수 편의성 향상
- 개발자 간 원활한 소통 지원

## ERD 표기법 종류

### 피터 첸 표기법

![image](https://github.com/user-attachments/assets/2e91f5bc-a6e7-4b1f-b86b-816c6fb5baf1)

- 개념적 모델링에 유용
- 엔티티는 사각형, 속성은 타원형으로 표현
- 관계는 마름모꼴로 표현
- 기본 키는 밑줄로 표시

### IE 표기법(새 발/까마귀 발 표기법)

![image](https://github.com/user-attachments/assets/f2a4ee08-4fac-4981-8243-e28629cb4ef5)

- RDBMS 모델링에 적합한 형태
- 테이블 형태로 직관적 표현
- 상단에 테이블명, 내부에 속성명 기재
- 기본키(PK), 외래키(FK) 명확히, 표시
- 관계 표현이 새 발 모양과 유사해 명칭 유래

<img width="600" alt="image" src="https://github.com/user-attachments/assets/0c08286e-2af8-4a93-9126-cad49311a861" />

### 관계 표현 방식

#### 관계선 끝부분 표기

| 표기                                             | 의미                                                    |
| ------------------------------------------------ | ------------------------------------------------------- |
| <kbd>&#124;</kbd>                                | 필수 관계(Mandatory) - 반드시 1개의 엔티티와 연결됨     |
| <kbd>O</kbd>                                     | 선택 관계(Optional) - 0개 또는 1개의 엔티티와 연결 가능 |
| <kbd>&#124;&#124;</kbd>                          | 필수 다수 관계 - 반드시 1개 이상의 엔티티와 연결됨      |
| <kbd>&#124;&#60;</kbd> 또는 <kbd>까마귀 발</kbd> | 선택적 다수 관계 - 0개 이상의 엔티티와 연결 가능        |

#### 관계선 타입

- **실선**: 식별 관계(Identifying Relationship) - 자식 엔티티가 부모 엔티티의 기본키를 자신의 기본키로 포함
- **점선**: 비식별 관계(Non-identifying Relationship) - 자식 엔티티가 부모 엔티티의 기본키를 일반 속성으로 포함

#### 관계 조합 예시

- **1:1 관계**: &#124;—&#124; (양쪽 모두 정확히 1개)
- **1:N 관계**: &#124;—&#60; (한쪽은 1개, 다른 쪽은 다수)
- **0:1 관계**: O—&#124; (한쪽은 0 또는 1개, 다른 쪽은 정확히 1개)
- **0:N 관계**: O—&#60; (한쪽은 0 또는 1개, 다른 쪽은 다수)

> [!TIP]
> IE 표기법은 실제 데이터베이스 구현과 매우 유사한 형태로 표현돼 개발자와 데이터베이스 관리자 간의 의사소통을 원활하게 함
> 시각적으로 테이블 구조와 관계를 명확히 파악할 수 있어 현업에서 널리 사용

## 식별/비식별 관계

> [!NOTE]
> 식별 관계는 실선으로, 비식별 관계는 점선으로 표현
> 엔티티 간 의존성을 나타내는 중요한 개념

<img width="600" alt="image" src="https://github.com/user-attachments/assets/3a268fd2-c6f1-4eaa-a518-59602f3969b7" />

#### 식별 관계

- 참조되는 엔티티가 존재해야만 참조하는 엔티티도 존재 가능
- 부모 엔티티의 기본 키가 자식 엔티티의 기본 키이자 외래 키로 사용됨

#### 비식별 관계

- 참조되는 엔티티 없이도 참조하는 엔티티 존재 가능
- 부모 엔티티의 기본 키가 자식 엔티티의 일반 외래 키로만 사용됨

# 정규화(Normalization)

> [!NOTE]
> 정규화란 **잠재적인 문제**가 발생하지 않도록 테이블의 필드를 구성하고, 필요할 경우 테이블을 나누는 작업
> 데이터 중복을 최소화하고 무결성을 유지하기 위한 데이터베이스 설계 기법

## 정규화가 필요한 이유

- 데이터 중복 최소화
- 데이터 일관성 유지
- 데이터 갱신 이상 방지
- 효율적인 검색 성능 확보

#### 참고: 정규화가 해결하는 잠재적 문제들

내가 궁금해서 책의 내용과 추가해 작성함.

1. **갱신 이상**(Update Anomaly)
   - **수정 이상**: 동일한 데이터가 여러 레코드에 중복돼 있을 때, 일부만 수정하면 일관성 깨짐
     - 예: 'CS101' 과목의 담당 교수가 변경될 경우, 모든 관련 레코드를 찾아 수정해야 함. 일부만 수정 시 데이터 불일치 발생
2. **삽입 이상**(Insertion Anomaly)
   - **추가 이상**: 특정 데이터를 추가하기 위해 불필요한 데이터까지 함께 추가해야 하는 문제
     - 예: 새로운 과목을 추가하려면 반드시 학생이 등록돼 있어야 함. 수강생 없는 신규 과목 정보만 추가 불가능
3. **삭제 이상**(Deletion Anomaly)
   - **삭제 이상**: 특정 데이터 삭제 시 의도치 않게 필요한 데이터까지 함께 삭제되는 문제
     - 예: 특정 학생의 레코드를 삭제하면 해당 학생이 수강한 과목 정보까지 함께 삭제됨. 유일한 수강생이었던 과목 정보 손실
4. **데이터 중복**(Data Redundancy)
   - **저장 공간 낭비**: 같은 정보가 여러 장소에 중복 저장돼 저장 공간 비효율 발생
   - **관리 비용 증가**: 중복 데이터 관리에 추가 자원 소모
5. **질의 처리 복잡성**(Query Complexity)
   - **비원자적 데이터 검색 어려움**: 'CS101, CS102'와 같이 복합 값 필드에서 특정 값만 검색 어려움
   - **연산 부담**: 중복 데이터로 인한 불필요한 연산 증가
6. **함수적 종속성 위반**(Functional Dependency Violation)
   - **결정자와 종속자 관계 혼란**: 하나의 테이블에 여러 종류의 관계가 섞여 데이터 일관성 위협
     - 예: '학번'이 '이름'을 결정하고, '과목코드'가 '담당교수'를 결정하는 두 가지 종속관계가 한 테이블에 공존할 때 발생하는 문제

각 정규형(1NF, 2NF, 3NF, BCNF)은 특정 유형의 데이터 이상 현상을 제거하도록 설계됨.

## 제1 정규형(1NF)

> [!NOTE]
> 모든 속성이 **원자 값**을 가져야 함
> 즉, 각 필드는 **더 이상 분해할 수 없는 단일 값만 포함**해야 함

### 제1 정규형 적용 전

| 학번 | 이름   | 수강 과목              | 담당 교수 |
| ---- | ------ | ---------------------- | --------- |
| 1    | 김철수 | 운영체제, 데이터베이스 | 강교수    |
| 2    | 이영희 | 컴퓨터구조, 운영체제   | 이교수    |
| 3    | 박민수 | 교양의이해, 자료구조   | 박교수    |

'수강 과목' 필드가 단일하지 않음.

### 제1 정규형 적용 후 (방법 A)

| 학번 | 이름   | 수강 과목    | 담당 교수 |
| ---- | ------ | ------------ | --------- |
| 1    | 김철수 | 운영체제     | 강교수    |
| 1    | 김철수 | 데이터베이스 | 강교수    |
| 2    | 이영희 | 컴퓨터구조   | 이교수    |
| 2    | 이영희 | 운영체제     | 이교수    |
| 3    | 박민수 | 교양의이해   | 박교수    |
| 3    | 박민수 | 자료구조     | 박교수    |

### 제1 정규형 적용 후 (방법 B - 테이블 분리)

#### **학생 테이블**

| 학번 | 이름   |
| ---- | ------ |
| 1    | 김철수 |
| 2    | 이영희 |
| 3    | 박민수 |

#### **수강 테이블**

| 학번 | 수강 과목    | 담당 교수 |
| ---- | ------------ | --------- |
| 1    | 운영체제     | 강교수    |
| 1    | 데이터베이스 | 강교수    |
| 2    | 컴퓨터구조   | 이교수    |
| 2    | 운영체제     | 이교수    |
| 3    | 교양의이해   | 박교수    |
| 3    | 자료구조     | 박교수    |

## 제2 정규형(2NF)

> [!NOTE]
> 제1 정규형을 만족하면서, 기본 키가 아닌 **모든 필드가 기본 키에 완전 함수 종속**(**완전 종속**)인 상태
> **부분 종속**이 없어야 함

### 완전 & 부분 함수 종속의 이해

#### 함수적 종속성 개념

- **함수적 종속성**: 특정 필드(결정자)의 값이 다른 필드(종속자)의 값을 유일하게 결정하는 관계
- **결정자 & 종속자**: 결정자 X의 값이 종속자 Y의 값을 결정할 때 "Y는 X에 함수적으로 종속된다"고 표현함
  - 표기: X → Y (X가 Y를 결정)

#### 부분 함수 종속성과 완전 함수 종속성 구분

- **완전 함수 종속성**: 복합 키의 모든 부분이 종속자를 결정하는 데 필요한 경우
- **부분 함수 종속성**: 복합 키의 일부분만으로도 종속자를 결정할 수 있는 경우

### 부분 함수 종속 예시

| **회원 ID** | 이름 | **구매 항목** | 가격  | 결제 수단 |
| ----------- | ---- | ------------- | ----- | --------- |
| 1           | Kim  | 한빛 티셔츠   | 49000 | 현금      |
| 2           | Park | 미디어 슬리퍼 | 21000 | 카드      |
| 2           | Lee  | 한빛 소주     | 13000 | 카드      |
| 3           | Jang | 한빛 맥주     | 32000 | 현금      |
| 3           | Choi | 미디어 키보드 | 12000 | 카드      |
| 4           | Kang | 한빛 책       | 28000 | 현금      |

- **기본 키**: (회원 ID, 구매 항목)
- **종속성 관계**
  - '가격'은 '구매 항목'에만 종속됨 (**부분 종속**)
  - '결제 수단'은 (회원 ID, 구매 항목) 조합에 종속됨 (완전 종속)

여기서 기본 키는 (회원 ID, 구매 항목)이지만, **'가격'**은 그 중 하나인 **'구매 항목'에만 종속되므로 부분 함수 종속이 존재**함.

이러면, '구매 항목' 당 '가격'이 여러 레코드에 반복 저장되기 때문에 공간 낭비가 일어나는 등의 문제가 생긴다. 그 외에 갱신, 삽입, 삭제 등에도 문제가 생긴다.

### 제2 정규형 위반 및 해결

#### 학생 성적 테이블 및 분할로 정규형 적용

| **학번** | 이름   | **과목** | 성적 |
| -------- | ------ | -------- | ---- |
| 1001     | 김철수 | 국어     | 90   |
| 1001     | 김철수 | 수학     | 80   |
| 1002     | 이영희 | 국어     | 75   |
| 1002     | 이영희 | 영어     | 85   |

- **기본 키**: (학번, 과목)
- **종속성 관계**
  - '이름'은 '학번'에만 종속됨 (**부분 종속**)
  - '성적'은 (학번, 과목) 조합에 종속됨 (완전 종속)

이 테이블도 기본 키 일부에만 종속된 '이름' 필드가 존재하므로 제2 정규형을 만족하지 않음.

제2 정규형 적용을 위해 분할을 적용하면 됨. 적용한 아래 테이블은 이제 제2 정규형을 만족함.

#### 학생 테이블

| 학번 | 이름   |
| ---- | ------ |
| 1001 | 김철수 |
| 1002 | 이영희 |

#### 성적 테이블

| 학번 | 과목 | 성적 |
| ---- | ---- | ---- |
| 1001 | 국어 | 90   |
| 1001 | 수학 | 80   |
| 1002 | 국어 | 75   |
| 1002 | 영어 | 85   |

- 데이터 중복 감소 (이름이 각 과목마다 반복되지 않음)
- 갱신 이상 방지 (이름이 변경될 경우 한 곳만 수정)

> [!TIP]
> 제2 정규형은 복합 키가 있는 테이블에서만 의미가 있음
> 기본 키가 단일 속성으로 구성된 테이블은 이미 제2 정규형을 만족한 것으로 간주할 수 있음
> 복합 키를 사용할 때는 항상 부분 함수 종속성의 존재 여부를 확인하는 것이 중요함

## 제3 정규형(3NF)

> [!NOTE]
> 이전 정규형을 만족하면서, 기본 키가 아닌 **모든 필드가 기본 키에 이행적 종속성**이 없는 상태
> 즉, **기본 키가 아닌 필드들 간에 종속 관계가 없어야 함**

### 이행적 종속성의 이해

- **A → B이고 B → C일 때, A → C**가 성립하는 관계
- 즉, A가 B를 결정하고 B가 C를 결정하면, A도 C를 결정함

이때 A와 C 사이에는 이행적 종속 관계가 있다고 표현한다.

#### 중요성

- 이행적 종속성은 데이터 중복과 갱신 이상의 원인이 됨
- 특히 기본 키가 아닌 모든 필드(비키 속성) 간의 종속 관계가 존재할 경우 문제 발생

### 이행적 종속 존재 예시

| 학번 | 학과       | 학과 사무실 위치 |
| ---- | ---------- | ---------------- |
| 1000 | 컴퓨터과학 | 미디어동100호    |
| 1001 | 경영학     | 한빛동200호      |

- **기본 키**: 학번
- **종속성 관계**
  - 학번 → 학과 (학번이 학과를 결정)
  - 학과 → 학과 사무실 위치 (학과가 사무실 위치를 결정)
  - 따라서 학번 → 학과 사무실 위치 (**이행적 종속**)

### 제3 정규형 적용 예시

#### 학생 테이블

| 학번 | 학과       |
| ---- | ---------- |
| 1000 | 컴퓨터과학 |
| 1001 | 경영학     |

#### 학과 테이블

| 학과       | 학과 사무실 위치 |
| ---------- | ---------------- |
| 컴퓨터과학 | 미디어동100호    |
| 경영학     | 한빛동200호      |

1. **학생 테이블**: 기본 키에 직접 종속된 속성만 포함
   - 학번 → 학과
2. **학과 테이블**: 종속 관계의 결정자를 기본 키로 하는 새 테이블 생성
   - 학과 → 학과 사무실 위치

#### 제3 정규형 이점

- **데이터 중복 감소**: 각 학과의 사무실 위치는 한 번만 저장됨
- **갱신 용이성**: 학과 사무실 위치 변경 시 한 레코드만 수정하면 됨
- **데이터 일관성**: 동일 학과 학생들의 사무실 위치 정보 일관성 유지
- **완전한 데이터**: 학생이 없는 학과 정보도 저장 가능

> [!TIP]
> 제3 정규형을 판단할 때는 '**비키 속성이 다른 비키 속성을 결정하는가?**'를 살펴보는 것이 핵심
> 만약 그렇다면 해당 결정자를 기본 키로 하는 별도 테이블을 생성해야 함
> 이행적 종속성의 제거는 데이터 일관성과 무결성 유지에 중요한 역할을 함
>
> **비키 속성**: 기본 키가 아닌 모든 필드

이는 특히 복합키가 있는 테이블에서 중요한데, 이런 구조에서는 키의 일부분에만 종속되는 속성이나 키가 아닌 결정자가 존재할 가능성이 높기 때문임.

## 보이스/코드 정규형(BCNF)

> [!NOTE]
> 제3 정규형을 만족하면서, **모든 결정자가 후보 키**인 상태
> 즉, **어떤 필드의 값을 결정할 수 있는 필드는 반드시 기본 키(또는 후보 키)**여야 함

### BCNF의 핵심 개념

#### 결정자와 후보 키

- **결정자**: 다른 필드의 값을 유일하게 결정할 수 있는 필드
- **후보 키**: 테이블의 모든 레코드를 고유하게 식별할 수 있는 최소한의 필드 집합

BCNF에서는 모든 결정자가 반드시 후보 키여야 함.

### BCNF 위반 예시

| 학번 | 과목 코드 | 담당 교수 |
| ---- | --------- | --------- |
| 1    | CS123     | 김교수    |
| 1    | CS321     | 이교수    |
| 2    | CS123     | 김교수    |
| 2    | CS234     | 박교수    |
| 2    | CS321     | 이교수    |
| 3    | CS321     | 이교수    |

- **기본 키**: (학번, 과목 코드)
- **종속성 관계**
  - (학번, 과목 코드) → 담당 교수 (기본 키가 담당 교수를 결정)
  - 담당 교수 → 과목 코드 (한 교수가 한 과목만 담당한다고 가정)
    - **한 교수가 한 과목만 담당한다고 가정**할 때, **'담당 교수'가 '과목 코드'를 결정하지만 '담당 교수'는 키가 아님**

다시 말해, '담당 교수'는 '과목 코드'를 결정하는 결정자지만, 후보 키가 아님. 아니면 '담당 교수'가 후보 키가 되려면 모든 레코드를 고유하게 식별할 수 있어야 하지만, 이 테이블에서는 그렇지 않음.

그렇다면 결정자임에도 불구하고 후보키가 아니므로 위반임.

### BCNF 적용 후

#### 수강 테이블

| 학번 | 과목 코드 |
| ---- | --------- |
| 1    | CS123     |
| 1    | CS321     |
| 2    | CS123     |
| 2    | CS234     |
| 2    | CS321     |
| 3    | CS321     |

#### 과목 테이블

| 과목 코드 | 담당 교수 |
| --------- | --------- |
| CS123     | 김교수    |
| CS321     | 이교수    |
| CS234     | 박교수    |

## 정규화의 단계

| 정규형 | 주요 조건                      |
| ------ | ------------------------------ |
| 1NF    | 모든 속성이 원자 값을 가짐     |
| 2NF    | 1NF + 부분 함수 종속성 제거    |
| 3NF    | 2NF + 이행 함수 종속성 제거    |
| BCNF   | 3NF + 후보 키 아닌 결정자 제거 |

- **수강 테이블**
  - **기본 키**: (학번, 과목 코드)
  - 모든 결정자가 후보 키임
- **과목 테이블**
  - **기본 키**: 과목 코드
  - 담당 교수 → 과목 코드 관계가 있지만, **과목 코드가 기본 키**
  - 또한 담당 교수도 후보 키가 됨 (한 교수가 한 과목만 담당한다면)

---

> [!TIP]
> 역정규화(Denormalization): **성능 향상을 위해 의도적으로 정규화된 테이블을 합치는 과정**
> 정규화를 통해 테이블 분리가 많아지면 조인 연산, 다른 테이블 참조 등의 성능 오버헤드가 발생함
> 데이터 중복을 허용하더라도 **검색 성능이 중요**한 경우(예: NoSQL)에 사용됨
> 정규화와 역정규화는 상황에 따라 적절히 선택해야 함
