# 데이터베이스의 큰 그림

## 데이터베이스와 DBMS

> [!NOTE]
> 데이터베이스는 여러 사람이 공유하여 사용할 목적으로 체계화해 통합, 관리하는 데이터의 집합<br>
> 원하는 **기능을 동작시키기 위해 마땅히 저장해야 하는 정보의 집합**

데이터베이스는 웹 서비스에 있어 심장과 같은 역할 수행. 저장되는 데이터와 방식에 따라 서비스의 정체성과 성능이 달라짐. 이를 관리하기 위한 수단이 바로 DBMS - Database Management System.

### DBMS의 종류

DBMS는 크게 두 유형으로 구분 가능.

1. **관계형 데이터베이스 관리 시스템(RDBMS)**
   - MySQL, Oracle, PostgreSQL, SQLite, MariaDB, Microsoft SQL Server 등
2. **NoSQL 데이터베이스 관리 시스템**
   - MongoDB, Redis 등

2023년 개발자 설문조사에 따르면, RDBMS가 여전히 높은 점유율 차지. MySQL과 그 오픈소스 버전인 MariaDB의 합산 점유율이 가장 높음.

### 서버로서의 DBMS

DBMS는 일반 응용 프로그램과 달리 사용자의 프로그램과 상호작용하며 실행되는 특성 보유. 클라이언트-서버 모델과 유사하게 동작.

#### SQL(Structured Query Language)

RDBMS에서 데이터를 조작하고 관리하기 위한 언어로, 크게 네 종류로 분류.

- **데이터 정의 언어 - DDL(Data Definition Language)**: CREATE, ALTER, DROP, TRUNCATE
- **데이터 조작 언어 - DML(Data Manipulation Language)**: SELECT, INSERT, UPDATE, DELETE
- **트랜잭션 제어 언어 - DCL(Data Control Language)**: GRANT, REVOKE
- **데이터 제어 언어 - TCL(Transaction Control Language)**: COMMIT, ROLLBACK, SAVEPOINT

## 파일 대신 데이터베이스를 이용하는 이유

> [!NOTE]
> 단순 파일 입출력 대신 데이터베이스를 사용하는 이유는 다양한 데이터 관리 기능과 안정성, 효율성 때문

1. **데이터 일관성 및 무결성 제공이 어려움**
   - 여러 사용자/프로그램이 동시에 데이터 접근 시 레이스 컨디션 발생 가능성
   - 모든 접근에 동기화 도구 사용이 번거로움
   - 개발자가 데이터 무결성을 일일이 검사하기 어려움
2. **불필요한 중복 저장이 많아짐**
   - 파일로 데이터 관리 시 같은 정보가 여러 파일에 중복 저장되는 문제 발생
   - 이로 인해 저장 공간 낭비 초래
3. **데이터 변경 시 연관 데이터 변경이 어려움**
   - 한 파일의 데이터 변경 시 다른 파일에서도 관련 데이터를 일일이 변경해야 함
4. **정교한 검색이 어려움**
   - 복합 조건을 활용한 검색은 파일 검색으로 구현하기 어려움
5. **백업 및 복구가 어려움**
   - 데이터베이스는 백업과 복구 기능을 기본 제공하나, 파일 입출력은 이런 기능 부족

## 데이터베이스의 저장 단위와 트랜잭션

### 데이터베이스의 저장 단위

> [!NOTE]
> 데이터베이스에는 다양한 속성을 가진 독립적 객체인 엔티티가 저장, 이는 데이터베이스 유형에 따라 다른 형태로 구현

#### 주요 개념

- **엔티티(Entity)**: 독립적으로 존재할 수 있는 객체, 실세계의 객체를 데이터베이스에 표현
  - 제품, 사용자, 주문과 같이 독립적으로 어떠한 특성을 가진, 식별 가능한 대상을 의미
- **속성(Attribute)**: 엔티티의 특성
  - 같은 속성을 공유하는 개별 엔티티는 같은 엔티티 집합에 속함
- **엔티티 집합**: 같은 속성을 공유하는 개별 엔티티들의 모음

<img width="600" alt="image" src="https://github.com/user-attachments/assets/dc9bd19f-d47a-4b93-8ee2-f3c4dc6c886f" />

> [!TIP]
> 엔티티의 속성이 가질 수 있는 값의 집합은 도메인(domain)이라고 함 <br>
> 가령 '구매자 성별' 속성이 가질 수 있는 도메인은 {남자, 여자}임

### RDBMS와 NoSQL의 저장 단위 비교

엔티티들은 RDBMS에서는 테이블 안에, MongoDB에서는 컬렉션 안에 저장됨.

#### RDBMS의 저장단위

- **릴레이션(테이블)**: 이차원 테이블 형태의 엔티티 집합
- **레코드(행)**: 데이터베이스에 기록된 각각의 엔티티
- **필드(열)**: 데이터베이스에 저장된 엔티티 속성

#### NoSQL(MongoDB)의 저장단위

- **컬렉션**: 엔티티의 집합
- **도큐먼트**: JSON 형태의 엔티티
- **필드**: JSON의 키

> [!NOTE]
> 필드의 수는 차수(degree)라고도 부름<br>
> 한 필드에 대한 고유 값의 수는 카디날리티(Cardinality)라고 부름<br>
> 즉, 카디날리티가 낮을수록 중복된 속성이 많음을 시사함

### 스키마

> [!NOTE]
> 스키마는 데이터베이스에 저장되는 레코드의 구조와 제약 조건을 정의한 것으로, 레코드가 지켜야 할 틀이자 청사진

- **RDBMS**: 명확한 스키마 정의 필요, 모든 레코드가 동일한 구조 준수
- **NoSQL**: 스키마-리스(schema-less) 특성으로, 유연한 데이터 구조 허용

### 트랜잭션과 ACID

> [!NOTE]
> 트랜잭션은 데이터베이스와의 논리적 상호작용 단위로, 데이터베이스가 처리하는 작업의 단위

초당 트랜잭션(TPS, Transactions Per Second)이라는 지표로 데이터베이스의 작업 성능을 나타내기도 함.

> [!TIP]
> 트랜잭션이라는 용어나 TPS라는 지표는 주로 데이터베이스에서 언급되는 용어이지만, 데이터베이스에서만 사용되는 용어는 아님<br>
> 메모리 트랜잭션이나 전자상거래의 거래 단위로도 사용됨

트랜잭션이 지켜야 하는 ACID 특성은 아래와 같다.

#### 1. 원자성(Atomicity)

- 트랜잭션 결과가 모두 성공하거나 모두 실패하는 성질
- "All or Nothing" 원칙 준수
- 반드시 커밋되거나 롤백되는 성질

> [!TIP]
> 커밋(commit): 트랜잭션을 성공적으로 수행하여 트랜잭션을 종료하는 것, 트랜잭션으로 인한 변경 사항을 확정<br>
> 롤백(rollback): 이전 트랜잭션을 취소하는 작업
>
> <img width="600" alt="image" src="https://github.com/user-attachments/assets/c3a4c50a-3f47-4ea0-b826-c6bfaa57019b" />

#### 2. 일관성(Consistency)

- 트랜잭션 전후로 데이터베이스가 일관된 상태 유지
- '일관된 상태'는 데이터베이스가 지켜야 하는 규칙들을 지키는 상태

#### 3. 격리성(Isolation)

- 동시에 수행되는 여러 트랜잭션이 서로 간섭하지 않도록 보장
- 레이스 컨디션 방지를 위한 성질

#### 4. 지속성(Durability)

- 트랜잭션이 성공적으로 완료된 후 결과가 영구적으로 반영
- 시스템 장애 발생 시에도 완료된 트랜잭션 결과는 보존

---

> [!TIP]
> 데이터베이스 학습 과정에서는 RDBMS의 기본, SQL, 효율적 쿼리, 데이터베이스 설계, NoSQL까지 단계적으로 학습 필요
> ![](https://github.com/user-attachments/assets/b57a694b-6ac4-45ae-bdc3-6e38f78912bd)

# SQL

> [!NOTE]
> SQL 명령은 크게 **DDL**(데이터 정의 언어), **DML**(데이터 조작 언어), **DCL**(데이터 제어 언어), **TCL**(트랜잭션 제어 언어)로 분류됨

## DDL(데이터 정의 언어)

> [!NOTE]
> DDL은 **데이터베이스와 테이블 같은 객체의 구조를 정의하는 SQL**

### 주요 명령어

| 종류     | 설명                                                      |
| -------- | --------------------------------------------------------- |
| CREATE   | 데이터베이스 혹은 데이터베이스 객체 생성                  |
| ALTER    | 데이터베이스 객체 갱신(테이블에 필드/제약 조건 추가/삭제) |
| DROP     | 데이터베이스 객체 삭제                                    |
| TRUNCATE | 테이블 구조를 유지한 채 모든 레코드 삭제                  |

> [!NOTE]
> 데이터베이스 객체란 데이터베이스에서 정의될 수 있는 대상을 통칭하는 용어임
> 테이블, 인덱스, 뷰 등이 대표적

### CREATE

#### 데이터베이스 생성

```sql
CREATE DATABASE 데이터베이스_이름;
CREATE DATABASE mydb;
```

- SQL문의 끝에는 세미콜론(;) 필수
- 생성된 데이터베이스 조회: `SHOW DATABASES;`
- 특정 데이터베이스 사용: `USE 데이터베이스_이름;`

#### 테이블 생성

기본 구문은 아래와 같다.

```sql
CREATE TABLE 테이블_이름 (
  필드_이름1 필드_타입,
  필드_이름2 필드_타입,
  필드_이름3 필드_타입,
  ...
);
```

#### 주요 제약 조건

특징 필드에 필드 타입을 입력해 제약 조건을 세울 수 있음.

| 키워드        | 제약 조건                           |
| ------------- | ----------------------------------- |
| PRIMARY KEY   | 특정 필드를 기본 키로 지정          |
| UNIQUE        | 특정 필드가 고유한 값을 갖도록 설정 |
| FOREIGN KEY   | 특정 필드를 외래 키로 지정          |
| DEFAULT       | 기본값 지정                         |
| NULL/NOT NULL | 특정 필드에 NULL 값을 허용/불허용   |

> [!TIP]
> UNIQUE 제약 조건이 명시된 필드는 고유 키(UNIQUE KEY)라고도 부름
> 고유 키는 중복값 불가능하지만, 기본 키와 달리 테이블 내 여러 개 존재 가능하고 NULL 값 허용

#### 실제 예제

<img width="600" alt="image" src="https://github.com/user-attachments/assets/de6b0bef-3d50-42f1-9ec1-8c039833c100" />

```sql
-- users 테이블 생성
CREATE TABLE users (
  user_id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) NOT NULL,
  email VARCHAR(100) UNIQUE,
  birthdate DATE,
  registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- posts 테이블 생성 (외래 키 포함)
CREATE TABLE posts (
  post_id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT,
  title VARCHAR(50) NOT NULL,
  content VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

- **AUTO_INCREMENT**: 레코드 추가 시 자동으로 1씩 증가
- **CURRENT_TIMESTAMP**: 현재 시간 자동 입력
- **FOREIGN KEY**: users 테이블의 user_id를 참조하는 외래 키 설정

#### 제약 조건 별도 정의 방식

```sql
CREATE TABLE tests (
  post_id INT AUTO_INCREMENT,
  user_id INT,
  title VARCHAR(50) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (post_id),
  CONSTRAINT FK_user FOREIGN KEY (user_id) REFERENCES users(user_id),
  CONSTRAINT UQ_title UNIQUE (title)
);
```

- **CONSTRAINT**: 제약 조건에 이름 부여 가능
- CREATE TABLE 하단에 제약 조건 추가적으로 명시 가능

### ALTER

**테이블 구조 변경**을 위한 명령어임.

#### 필드 관련 작업

```sql
-- 새로운 필드 추가
-- ALTER TABLE 테이블_이름 ADD COLUMN 필드_이름 필드_타입 [제약 조건]
ALTER TABLE posts ADD COLUMN new_field VARCHAR(50) NOT NULL;

-- 기존 필드 수정
-- ALTER TABLE 테이블_이름 CHANGE COLUMN 기존_필드_이름 새_필드_이름 필드_타입 [제약 조건]
ALTER TABLE posts CHANGE COLUMN new_field old_field VARCHAR(30) NOT NULL;

-- 기존 필드 삭제
-- ALTER TABLE 테이블_이름 DROP COLUMN 필드_이름
ALTER TABLE posts DROP COLUMN old_field;

-- 외래 키 제약 조건 추가
-- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_ 이름]
-- ADD FOREIGN KEY (필드_ 이름) REFERENCES 참조_테이블_이름(참조_필드)
ALTER TABLE posts ADD FOREIGN KEY (user_id) REFERENCES users(user_id);

-- UNIQUE 제약 조건 추가
-- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_이름] UNIQUE (필드_ 이름)
ALTER TABLE posts ADD UNIQUE (title);

-- NOT NULL 제약 조건 추가
-- ALTER TABLE 테이블_이름 MODIFY 필드_이름 필드_타입 NOT NULL
ALTER TABLE users MODIFY email VARCHAR(100) NOT NULL;

-- 기본 키 설정(PRIMARY KEY로 사용 중인 필드가 없을 경우
-- ALTER TABLE 테이블_이름 ADD PRIMARY KEY (필드_이름)
ALTER TABLE posts ADD PRIMARY KEY (post_id);
```

> [!TIP]
> ALTER문은 테이블뿐만 아니라 뷰, 인덱스 등 다른 데이터베이스 객체에도 적용 가능함

### DROP

**데이터베이스 객체를 완전히 삭제**하는 명령어임.

```sql
-- 데이터베이스 삭제
DROP DATABASE mydb;

-- 테이블 삭제
DROP TABLE 테이블_이름;
```

- 삭제 후 복구 불가능하므로 주의 필요
- DROP문도 테이블 외에 뷰, 인덱스 등에 적용 가능

### TRUNCATE

**테이블 구조는 유지하면서 모든 레코드만 삭제**함.

```sql
TRUNCATE TABLE 테이블_이름;
TRUNCATE TABLE users;
```

- 테이블의 구조(필드, 제약조건 등)는 그대로 유지
- 모든 데이터만 삭제되어 빈 테이블 상태가 됨
- `DESC 테이블_이름` 명령으로 테이블 구조 확인 시 여전히 표시됨

> [!NOTE]
> TRUNCATE는 `DELETE FROM 테이블_이름`과 유사하지만, 더 빠르고 로그를 적게 생성함
> 단, 조건절 사용 불가하고 전체 데이터만 삭제 가능함

## DML(데이터 조작 언어)

> [!NOTE]
> SQL DDL, DML, DCL 중 **기술 면접과 실무에서 가장 자주 언급되는 명령어 집합**

| 종류   | 설명                 |
| ------ | -------------------- |
| SELECT | 테이블의 레코드 조회 |
| INSERT | 테이블에 레코드 삽입 |
| UPDATE | 테이블의 레코드 수정 |
| DELETE | 테이블의 레코드 삭제 |

### INSERT

테이블에 **새로운 레코드를 삽입**하는 명령어임.

#### 기본 구문

```sql
-- 레코드 하나 삽입
INSERT INTO 테이블_이름(필드1, 필드2) VALUES (값1, 값2);

-- 여러 레코드 삽입
INSERT INTO 테이블_이름(필드1, 필드2, 필드3) VALUES
  (값1, 값2, 값3),
  (값1, 값2, 값3),
  (값1, 값2, 값3);
```

- 삽입할 값이 지정되지 않은 필드는 기본값으로 채워짐
- 기본값이 없으면 NULL로 채워짐

#### 실제 예제

```sql
-- users 테이블에 레코드 삽입
INSERT INTO users (username, email, birthdate) VALUES
  ('kim', 'kim@example.com', '1996-05-15');

-- 여러 레코드 한 번에 삽입
INSERT INTO users (username, email, birthdate) VALUES
  ('lee', 'lee@example.com', '1994-03-22'),
  ('park', 'park@example.com', '1988-07-11'),
  ('choi', 'choi@example.com', '2000-01-30'),
  ('jung', 'jung@example.com', '1992-12-05');
```

<img width="600" alt="image" src="https://github.com/user-attachments/assets/5dd9f76a-ee0e-4cd3-a8d0-103a123d1b51" />

> [!NOTE]
> 위 이미지에서, `user_id`와 `registration_date` 필드는 삽입할 데이터를 지정하지 않아도 기본값으로 각각 '1부터 증가하는 정수'와 '현재 시간'이 삽입

#### 외래 키 참조 상황

```sql
-- posts 테이블에 레코드 삽입 (외래 키 참조)
INSERT INTO posts (user_id, title, content) VALUES
  (1, 'Hi', 'Hello');
```

- `posts` 테이블의 `user_id`는 `users` 테이블의 `user_id`를 참조하는 외래 키
- 삽입할 레코드의 `user_id`가 `users` 테이블에 존재해야 함

#### 무결성 제약 조건

레코드 삽입 시 무결성 제약 조건을 지켜야 함.

```sql
-- NOT NULL 제약 조건 위배: 실행 안 됨
INSERT INTO users (username, email) VALUES
  (NULL, 'no_name@example.com');

-- UNIQUE 제약 조건 위배: 이미 존재하는 경우 실행 안 됨
INSERT INTO users (username, email) VALUES
  ('kim', 'kim@example.com');

-- 외래 키 제약 조건 위배: 참조할 레코드가 없으면 실행 안 됨
INSERT INTO posts (user_id, title, content) VALUES
  (10, 'Hi', 'Hello');
```

### UPDATE

**레코드를 수정**하는 SQL 명령임.

#### 기본 구문

```sql
UPDATE 테이블_이름
  SET 필드1 = 값1, 필드2 = 값2, ...
  WHERE 조건식;
```

- `WHERE` 절은 생략 가능하나, 생략 시 모든 레코드가 갱신됨
- `SET`의 `=`는 대입 연산자, `WHERE`의 `=`는 비교 연산자

#### 비교/논리 연산자

| 연산자              | 설명                                             |
| ------------------- | ------------------------------------------------ |
| =                   | 같을 경우 참                                     |
| >                   | 클 경우 참                                       |
| <                   | 작을 경우 참                                     |
| >=                  | 크거나 같을 경우 참                              |
| <=                  | 작거나 같을 경우 참                              |
| <>                  | 다를 경우 참                                     |
| 조건식1 AND 조건식2 | 조건식1과 조건식2가 모두 만족할 경우 참          |
| 조건식1 OR 조건식2  | 조건식1과 조건식2 둘 중 하나만 만족할 경우 참    |
| NOT 조건식          | 조건식이 아닐 경우 참                            |
| IN                  | IN 뒤에 명시되는 값과 하나 이상이 일치할 경우 참 |

#### 실제 예제

```sql
-- username이 'kim'인 사용자의 이메일 수정
UPDATE users
  SET email = 'kim_new@example.com'
  WHERE username = 'kim';

-- post_id가 5보다 큰 모든 게시글 제목 수정
UPDATE posts
  SET title = 'Updated Title'
  WHERE post_id > 5;
```

### DELETE

**조건에 맞는 레코드를 삭제**하는 명령임. UPDATE에서 사용한 논리/비교 연산자를 사용할 수 있는 등 명령 구조가 비슷하다.

#### 기본 구문

```sql
DELETE FROM 테이블_이름
  WHERE 조건식;
```

- `WHERE`절 생략 시 모든 레코드 삭제 => 대참사!

#### 실제 예제

```sql
-- title이 'Hi'인 게시글 삭제
DELETE FROM posts
  WHERE title = 'Hi';
```

### 외래 키 제약 조건 - ON UPDATE, ON DELETE

> [!WARNING]  
> 한 테이블이 다른 테이블을 외래 키로 참조하는 상황에서 참조되는 레코드가 수정/삭제될 경우, **참조하는 레코드의 동작을 정의**해야 함

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c0b2df6f-eac4-4ff0-8274-c97e0b47fa6f" />

| 제약 조건   | 설명                                       |
| ----------- | ------------------------------------------ |
| CASCADE     | 참조하는 데이터도 함께 수정/삭제           |
| SET NULL    | 참조하는 데이터를 NULL로 변경              |
| SET DEFAULT | 참조하는 데이터를 기본값으로 변경          |
| RESTRICT    | 수정/삭제를 허용하지 않음                  |
| NO ACTION   | (MySQL의 경우) 사실상 RESTRICT와 동일 동작 |

```sql
CREATE TABLE posts (
  post_id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT,
  title VARCHAR(50) NOT NULL,
  content VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
  ON UPDATE CASCADE    -- users의 user_id 수정 시 함께 수정
  ON DELETE SET NULL   -- users의 user_id 삭제 시 NULL로 변경
);
```

### SELECT

**삽입된 레코드를 조회**하는 **가장 중요**한 SQL 명령임.

#### 기본 구문

```sql
SELECT 필드1, 필드2, ...
  FROM 테이블_이름
  WHERE 조건식
  GROUP BY 그룹화할_필드
  HAVING 필터_조건
  ORDER BY 정렬할_필드
  LIMIT 레코드_제한;
```

- 필드에 `*` 사용 시 모든 필드 조회
- **실행 순서**: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

#### 기본 조회

```sql
-- 모든 레코드 조회
SELECT * FROM students;

-- 특정 필드만 조회
SELECT first_name, last_name, major
  FROM students
  WHERE major = 'Computer Science';

-- 조건부 조회
SELECT first_name, last_name, age
  FROM students
  WHERE age >= 21;
```

#### 패턴 검색: LIKE

WHERE에서는 `=`를 썼었는데, 이는 정확히 일치하는 것만 찾음. LIKE를 사용하면 **해당되는 패턴을 가진 값**들을 가져올 수 있음.

```sql
-- 'Science'라는 단어가 포함된 전공 검색
SELECT first_name, last_name, major
  FROM students
  WHERE major LIKE '%Science%';

-- 두 번째 문자가 'a'인 전공 검색
SELECT first_name, last_name, major
  FROM students
  WHERE major LIKE '_a%';
```

- `%`: 0개 이상의 임의의 문자와 일치
- `_`: 정확히 1개의 임의의 문자와 일치

#### 집계 함수

연산/집계 함수는 이름 그대로 조회된 레코드에 대한 **특정 연산을 수행하거나 집계**하는 함수.

| 함수  | 설명                        |
| ----- | --------------------------- |
| COUNT | 조회된 레코드 개수 반환     |
| SUM   | 조회된 레코드의 총합 반환   |
| AVG   | 조회된 레코드의 평균 반환   |
| MAX   | 조회된 레코드의 최댓값 반환 |
| MIN   | 조회된 레코드의 최솟값 반환 |

<img width="600" alt="image" src="https://github.com/user-attachments/assets/08b4fffd-b2f8-4b3a-bae5-618adfa41996" />

```sql
-- 학생 수, 평균 학점, 최고/최저 학점 조회
SELECT COUNT(*), AVG(gpa), MAX(gpa), MIN(gpa)
  FROM students;
```

조회된 속성의 이름을 정해주는, AS랑 많이 쓰인다.

### GROUP BY

**특정 필드를 기준**으로 **레코드를 그룹화**할 때 사용됨.

```sql
-- 전공별 학생 수 조회
SELECT major, COUNT(*) AS student_count
  FROM students
  GROUP BY major;

-- 나이별 학생 수 조회
SELECT age, COUNT(*) AS student_count
  FROM students
  GROUP BY age;
```

<img width="600" alt="image" src="https://github.com/user-attachments/assets/d27bdd56-b84d-42dc-98dc-b798d43c078a" />

### HAVING

**그룹화된 결과에 조건을 적용**할 때 사용됨.

```sql
-- 평균 GPA가 3.6 이상인 전공 조회
SELECT major, AVG(gpa)
  FROM students
  GROUP BY major
  HAVING AVG(gpa) >= 3.6;

-- 평균 나이가 21세 이상인 전공 조회
SELECT major, AVG(age)
  FROM students
  GROUP BY major
  HAVING AVG(age) >= 21;
```

> [!TIP]
> WHERE절은 그룹화 전 개별 레코드에 대한 조건이며, HAVING절은 **그룹화된 레코드에 대한 조건**임

### ORDER BY

특정 필드를 기준으로 **레코드를 정렬**할 때 사용됨.

```sql
-- GPA 기준 내림차순 정렬
SELECT first_name, last_name, gpa
  FROM students
  ORDER BY gpa DESC;

-- 성 기준 오름차순 정렬
SELECT first_name, last_name, major
  FROM students
  ORDER BY last_name ASC;
```

- 기본값은 오름차순(ASC) 정렬
- DESC 키워드로 내림차순 정렬 가능

### LIMIT

**조회할 레코드 수를 제한**할 때 사용됨.

```sql
-- 상위 3개 레코드만 조회
SELECT * FROM students LIMIT 3;

-- 3번째 레코드부터 2개 조회 (시작점 지정)
SELECT * FROM students LIMIT 2, 2;
```

---

> [!WARNING]
> SELECT문의 실제 실행 순서는 작성 순서와 다름
> 이에 유의하지 않으면 예기치 못한 성능 저하나 의도하지 않은 결과가 발생할 수 있음
>
> 작성 순서: SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY → LIMIT
> 실행 순서: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

## TCL(트랜잭션 제어 언어)

TCL(Transaction Control Language)은 **트랜잭션을 제어**하는 SQL 명령들을 포함함.

| 종류      | 설명                      |
| --------- | ------------------------- |
| COMMIT    | 데이터베이스에 작업 반영  |
| ROLLBACK  | 작업 이전의 상태로 되돌림 |
| SAVEPOINT | 롤백의 기준점 설정        |

한 트랜잭션에는 여러 쿼리가 포함될 수 있으며, 모든 작업이 성공하거나 모두 실패하는 원자성을 보장함.

### 트랜잭션 기본 개념

#### 트랜잭션 시작

```sql
-- 트랜잭션 시작 (둘 다 같은 의미)
START TRANSACTION;
-- 또는
BEGIN;
```

- DBMS에게 트랜잭션이 시작됨을 알리는 명령
- 이후 실행되는 SQL문들은 하나의 트랜잭션으로 묶임

#### 예제: 계좌 이체

```sql
-- accounts 테이블 생성 및 데이터 삽입
CREATE TABLE accounts (
  account_id INT PRIMARY KEY,
  account_name VARCHAR(50),
  balance INT
);

INSERT INTO accounts (account_id, account_name, balance) VALUES
  (1, 'Kim', 1000),
  (2, 'Lee', 500);
```

계좌 이체는 두 개의 UPDATE문이 함께 실행되어야 하는 트랜잭션의 대표적 예시임.

```sql
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
```

### COMMIT

트랜잭션이 성공적으로 완료돼 **모든 변경 사항을 데이터베이스에 영구적으로 반영**함.

```sql
START TRANSACTION;

-- 시점 1: 2개의 레코드 확인
SELECT * FROM accounts;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- 시점 2: 두 UPDATE문이 실행되었음을 확인
SELECT * FROM accounts;

COMMIT;

-- 시점 3: accounts 테이블은 시점 2와 같음
SELECT * FROM accounts;
```

### ROLLBACK

트랜잭션에서 **수행된 변경 사항을 취소**하고, 데이터베이스를 트랜잭션 시작 **이전 상태로 되돌림**.

```sql
START TRANSACTION;

-- 시점 1: 2개의 레코드 확인
SELECT * FROM accounts;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;

-- 시점 2: account_id가 1인 레코드의 balance가 100 감소
SELECT * FROM accounts;

ROLLBACK;

-- 시점 3: accounts 테이블은 시점 1과 같음 (UPDATE 취소)
SELECT * FROM accounts;
```

### SAVEPOINT

SAVEPOINT는 ROLLBACK으로 되돌아갈 **중간 지점을 설정하는 기능**임. 트랜잭션 내 특정 시점으로 **부분적 롤백이 가능**함.

#### 기본 구문

```sql
-- 세이브포인트 생성
SAVEPOINT 세이브포인트_이름;

-- 세이브포인트로 롤백
ROLLBACK TO SAVEPOINT 세이브포인트_이름;
```

#### 예제

```sql
START TRANSACTION;

-- 세이브포인트 생성 1
SAVEPOINT sp1;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- 세이브포인트 생성 2
SAVEPOINT sp2;
UPDATE accounts SET account_name = 'new_Kim' WHERE account_id = 1;
UPDATE accounts SET account_name = 'new_Lee' WHERE account_id = 2;

-- 세이브포인트 생성 3
SAVEPOINT sp3;
SELECT * FROM accounts;

-- 특정 세이브포인트로 롤백 (최근 변경사항만 취소)
ROLLBACK TO SAVEPOINT sp2;  -- sp3의 변경사항 취소
ROLLBACK TO SAVEPOINT sp1;  -- sp2의 변경사항 취소
```

### 자동 커밋(Auto Commit)

> [!WARNING]
> MySQL에서는 기본적으로 자동 커밋이 활성화돼 있어, 매 SQL문이 자동으로 커밋됨
> DDL문은 항상 자동으로 커밋되며 롤백할 수 없음

#### 자동 커밋 제어

```sql
-- 자동 커밋 비활성화
SET autocommit = 0;

-- 자동 커밋 활성화
SET autocommit = 1;
```

- `START TRANSACTION` 또는 `BEGIN` 실행 시 자동으로 자동 커밋이 비활성화됨
- 트랜잭션 내에서는 `COMMIT`이나 `ROLLBACK`을 만나기 전까지 커밋되지 않음

> [!TIP]
> DDL(Data Definition Language) 문장들은 항상 자동으로 커밋됨
> CREATE, ALTER, DROP, TRUNCATE 등의 DDL문은 실행 즉시 현재 트랜잭션을 종료하고 변경사항을 확정함

## 데이터 제어 언어(DCL)

DCL(Data Control Language)은 데이터베이스 사용자의 권한을 관리하는 SQL 명령어 집합임.

| 종류   | 설명                   |
| ------ | ---------------------- |
| GRANT  | 사용자에게 권한 부여   |
| REVOKE | 사용자로부터 권한 회수 |

DBMS는 서버처럼 사용자 계정과 권한을 관리함.

### 사용자 관리

```sql
-- 사용자 생성
CREATE USER '사용자명'@'호스트' IDENTIFIED BY '비밀번호';

-- 사용자 삭제
DROP USER '사용자명'@'호스트';
```

### 권한 관리

```sql
-- 권한 부여
GRANT 권한목록 ON 데이터베이스.테이블 TO '사용자명'@'호스트';

-- 권한 회수
REVOKE 권한목록 ON 데이터베이스.테이블 FROM '사용자명'@'호스트';
```

DCL을 통해 각 사용자별로 사용 가능한 SQL 명령을 제한하고, 데이터베이스 보안을 관리할 수 있음.

# 효율적 쿼리

효율적으로, DB에게 질의할 수 있도록 서브 쿼리, 조인, 뷰, 인덱스를 살펴보자.

## 서브 쿼리와 조인

> [!NOTE]
>
> - 서브 쿼리(subquery): **다른 SQL문이 포함된 SQL문**
> - 조인(join): **2개의 테이블을 하나로 합치는 것**

이들은 여러 테이블에 질의하는 등 데이터베이스에 복잡한 요청을 해야 할 때 유용하게 사용됨.

### 여러 테이블에 질의하기

실제 데이터베이스를 다룰 때는 여러 테이블을 대상으로 작업하는 것이 일반적임. 특히 여러 테이블을 대상으로 SELECT문을 사용하는 경우가 많음.

하나의 SELECT문으로 여러 테이블 레코드를 조회하는 명령은 간단함.

- FROM절에 여러 테이블의 이름을 명시
- 조회하고자 하는 테이블의 필드는 `테이블_이름.필드` 형식으로 명시
- WHERE절을 통해 테이블 간 조건 설정

```sql
-- 기본 구조
SELECT 테이블1.필드1, 테이블1.필드2, 테이블2.필드3
FROM 테이블1, 테이블2
WHERE 테이블1.필드1 = 테이블2.필드2;

-- 실제 예제
SELECT users.username, users.email, posts.title
FROM users, posts
WHERE users.user_id = posts.user_id;
```

#### 참고: 기존 테이블 구조

```sql
-- db/create_insert_users_posts.sql

-- 사용자 테이블 생성
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    birthdate DATE,
    registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- 게시글 테이블 생성
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    title VARCHAR(50) NOT NULL,
    content VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
-- 사용자 데이터 삽입
INSERT INTO users (username, email, birthdate) VALUES
    ('kim', 'kim@example.com', '1990-01-01'),
    ('lee', 'lee@example.com', '1985-05-15'),
    ('park', 'park@example.com', '1992-08-22');
-- 게시글 데이터 삽입
INSERT INTO posts (user_id, title, content) VALUES
    (1, 'One', 'This is the content of the first post.'),
    (1, 'Two', 'This is the content of the second post.'),
    (2, 'Three', 'This is a post by lee.'),
    (3, 'Four', 'This is a post by park.');

```

### 서브 쿼리

> [!NOTE]
> 서브 쿼리는 **내부에 다른 SQL문이 포함되어 있는 SQL문**

MySQL에서는 '다른 SQL문 안에 있는 SELECT문'으로 정의하며, 소괄호로 감싸 외부 쿼리와 구분함.

#### 서브 쿼리의 유형

1. **SELECT 안에 SELECT문이 포함된 서브 쿼리**

   ```sql
   SELECT
       users.username,
       (SELECT COUNT(*)
        FROM posts
        WHERE posts.user_id = users.user_id) AS post_count
   FROM users;
   ```

   사용자별로 작성한 글의 개수를 조회하는 SQL문임.

2. **DELETE 안에 SELECT문이 포함된 서브 쿼리**
   ```sql
   DELETE FROM posts
   WHERE user_id = (
       SELECT user_id
       FROM users
       WHERE email = 'kim@example.com'
   );
   ```
   특정 이메일을 가진 사용자의 모든 글을 삭제하는 SQL문임.

### 조인

> [!NOTE]
> 조인(JOIN)은 **여러 테이블을 하나로 합치는 연산**

크게 **INNER** 조인과 **OUTER** 조인(**LEFT, RIGHT, FULL**)으로 구분됨.

#### 조인의 종류

<img width="700" alt="image" src="https://github.com/user-attachments/assets/b1644853-e753-44cf-bab9-39f6ed191b36" />

#### INNER 조인 예제

```sql
SELECT customers.name, customers.age, customers.email, orders.id, orders.product_id, orders.quantity, orders.amount
FROM customers
INNER JOIN orders ON customers.id = orders.customer_id;
```

| name | age | email            | id  | product_id | quantity | amount |
| ---- | --- | ---------------- | --- | ---------- | -------- | ------ |
| kim  | 30  | kim@example.com  | 1   | 1          | 10       | 1000   |
| lee  | 25  | lee@example.com  | 2   | 2          | 20       | 2000   |
| lee  | 25  | lee@example.com  | 3   | 3          | 30       | 3000   |
| park | 40  | park@example.com | 4   | 4          | 40       | 4000   |
| park | 40  | park@example.com | 5   | 5          | 50       | 5000   |
| kang | 20  | kang@example.com | 6   | 6          | 60       | 6000   |
| kang | 20  | kang@example.com | 7   | 7          | 70       | 7000   |
| kwon | 18  | kwon@example.com | 8   | 8          | 80       | 8000   |
| kwon | 18  | kwon@example.com | 9   | 9          | 90       | 9000   |

WHERE 등 **조건 필터링 추가**도 할 수 있다.

```sql
SELECT customers.name, customers.age, customers.email, orders.id, orders.product_id, orders.quantity, orders.amount
FROM customers
INNER JOIN orders ON customers.id = orders.customer_id
WHERE orders.amount >= 5000;
```

| name | age | email            | id  | product_id | quantity | amount |
| ---- | --- | ---------------- | --- | ---------- | -------- | ------ |
| park | 40  | park@example.com | 5   | 5          | 50       | 5000   |
| kang | 20  | kang@example.com | 6   | 6          | 60       | 6000   |
| kang | 20  | kang@example.com | 7   | 7          | 70       | 7000   |
| kwon | 18  | kwon@example.com | 8   | 8          | 80       | 8000   |
| kwon | 18  | kwon@example.com | 9   | 9          | 90       | 9000   |

#### LEFT OUTER 조인 예제

LEFT OUTER 조인은 **테이블1의 모든 레코드를 기준**으로 테이블2의 레코드를 합치되, **테이블2에 대응되는 레코드가 없다면 해당 값을 NULL로 간주**하는 조인 방식.

```sql
SELECT customers.name, orders.id AS order_id, orders.product_id, orders.quantity, orders.amount
FROM customers
LEFT OUTER JOIN orders ON customers.id = orders.customer_id;
```

| name | order_id | product_id | quantity | amount |
| ---- | -------- | ---------- | -------- | ------ |
| kim  | 1        | 1          | 10       | 1000   |
| lee  | 3        | 3          | 30       | 3000   |
| lee  | 2        | 2          | 20       | 2000   |
| park | 5        | 5          | 50       | 5000   |
| park | 4        | 4          | 40       | 4000   |
| kang | 7        | 7          | 70       | 7000   |
| kang | 6        | 6          | 60       | 6000   |
| kwon | 9        | 9          | 90       | 9000   |
| kwon | 8        | 8          | 80       | 8000   |
| gwak | NULL     | NULL       | NULL     | NULL   |
| na   | NULL     | NULL       | NULL     | NULL   |
| jo   | NULL     | NULL       | NULL     | NULL   |
| yang | NULL     | NULL       | NULL     | NULL   |

> [!TIP]
> LEFT OUTER 조인은 '기준이 되는 테이블(customers)'의 모든 레코드를 보여주므로, 주문이 없는 고객들도 NULL 값으로 표시됨
> 사담) 이는 고객 전체 목록을 유지하면서 주문 정보를 확인할 때 유용할 거 같음

#### RIGHT OUTER 조인 예제

LEFT와 정확히 반대. **테이블2의 레코드를 모두 선택하고, 이를 기준**으로 테이블1를 합치되 **대응되는 레코드가 없다면 NULL**이 되는 조인 방식.

```sql
SELECT customers.name, orders.id AS order_id, orders.product_id, orders.quantity, orders.amount
FROM customers
RIGHT OUTER JOIN orders ON customers.id = orders.customer_id;
```

| name | order_id | product_id | quantity | amount |
| ---- | -------- | ---------- | -------- | ------ |
| kim  | 1        | 1          | 10       | 1000   |
| lee  | 2        | 2          | 20       | 2000   |
| lee  | 3        | 3          | 30       | 3000   |
| park | 4        | 4          | 40       | 4000   |
| park | 5        | 5          | 50       | 5000   |
| kang | 6        | 6          | 60       | 6000   |
| kang | 7        | 7          | 70       | 7000   |
| kwon | 8        | 8          | 80       | 8000   |
| kwon | 9        | 9          | 90       | 9000   |
| NULL | 10       | 9          | 90       | 9000   |

#### FULL OUTER 조인 구현

FULL OUTER 조인은 기본적으로 **두 테이블의 모든 레코드를 선택**하되, **대응되지 않는 모든 레코드를 NULL**로 표기하는 조인 방식.

**MySQL**은 FULL OUTER 조인을 직접 지원하지 않으므로, **LEFT와 RIGHT 조인을 UNION**으로 결합해 구현함.

```sql
SELECT 필드
FROM 테이블1
  LEFT JOIN 테이블2 ON 조인 조건
  UNION
SELECT 필드
FROM 테이블1
  RIGHT JOIN 테이블2 ON 조인 조건;
```

```sql
SELECT customers.name, orders.id AS order_id, orders.product_id, orders.quantity, orders.amount
FROM customers
  LEFT OUTER JOIN orders ON customers.id = orders.customer_id
  UNION
SELECT customers.name, orders.id AS order_id, orders.product_id, orders.quantity, orders.amount
FROM customers
  RIGHT OUTER JOIN orders ON customers.id = orders.customer_id;
```

| name | order_id | product_id | quantity | amount |
| ---- | -------- | ---------- | -------- | ------ |
| kim  | 1        | 1          | 10       | 1000   |
| lee  | 3        | 3          | 30       | 3000   |
| lee  | 2        | 2          | 20       | 2000   |
| park | 5        | 5          | 50       | 5000   |
| park | 4        | 4          | 40       | 4000   |
| kang | 7        | 7          | 70       | 7000   |
| kang | 6        | 6          | 60       | 6000   |
| kwon | 9        | 9          | 90       | 9000   |
| kwon | 8        | 8          | 80       | 8000   |
| gwak | NULL     | NULL       | NULL     | NULL   |
| na   | NULL     | NULL       | NULL     | NULL   |
| jo   | NULL     | NULL       | NULL     | NULL   |
| yang | NULL     | NULL       | NULL     | NULL   |
| NULL | 10       | 9          | 90       | 9000   |

### 서브 쿼리와 조인의 상호 대체 가능

일부 서브 쿼리 연산은 조인으로 대체 가능함. 예를 들어, 사용자별 작성 글 개수를 조회하는 서브 쿼리는 다음과 같은 조인으로 대체 가능:

```sql
-- 서브 쿼리 대신 조인 사용
SELECT users.username, COUNT(posts.post_id) AS post_count
FROM users
  LEFT JOIN posts ON users.user_id = posts.user_id
  GROUP BY users.username;
```

| username | post_count |
| -------- | ---------- |
| kim      | 2          |
| lee      | 1          |
| park     | 1          |

> [!TIP]
> 사담)
> 성능상 조인이 서브 쿼리보다 효율적인 경우가 많으므로, 가능하다면 조인을 사용하는 것이 권장됨
> 특히 대용량 데이터를 다룰 때는 조인의 성능 이점이 더욱 두드러짐

## 뷰(View)

> [!NOTE]
> 뷰(View)는 **SELECT문의 결과로 만들어진 가상의 테이블**임
> SELECT문의 결과를 뷰로 생성한 뒤, 해당 뷰에 다양한 SQL문을 실행할 수 있음

뷰는 주로 **테이블에 대한 SQL문을 단순화**하기 위해 사용됨. 특히 여러 테이블을 조인하거나 복잡한 조건식을 사용한 SQL문을 하나의 뷰로 만들어 두면, 이후 복잡한 SQL문을 반복적으로 작성하는 대신 보다 단순하게 동일한 결과를 얻을 수 있음.

### 뷰 생성 및 활용

**뷰 생성 문법**은 아래와 같다. 테이블 생성 삭제와 비슷하다.

```sql
CREATE VIEW 뷰_이름 AS SELECT문; -- 생성
DROP VIEW 뷰_이름 AS SELECT문; -- 삭제
```

#### 예제: 복잡한 조인을 뷰로 단순화

```sql
-- 뷰 생성
CREATE VIEW myview AS
SELECT users.username, users.email, posts.title
FROM users, posts
WHERE users.user_id = posts.user_id;

-- 생성된 뷰 활용
SELECT username, email, title
FROM myview
WHERE username = 'kim';
```

| username | email           | title |
| -------- | --------------- | ----- |
| kim      | kim@example.com | One   |
| kim      | kim@example.com | Two   |

### **뷰의 활용 목적**

<img width="600" alt="image" src="https://github.com/user-attachments/assets/f6a9806b-8a04-41cb-bb39-c501af8edf75" />

1. **쿼리 단순화 및 재사용성 향상**
   - 복잡한 조인이나 서브쿼리를 뷰로 저장하여 간단하게 재사용 가능
   - 반복적인 쿼리 작성 시간 절약
2. **데이터 보안 및 접근 제어**
   - 테이블의 특정 필드만 노출하고 싶을 때 뷰 생성
   - 민감한 정보는 제외하고 필요한 데이터만 사용자에게 제공
   ```sql
   -- 예: 학생 정보에서 주소와 같은 민감한 정보 제외
   CREATE VIEW student_basic_info AS
   SELECT 이름, 나이, 학년
   FROM students;
   ```

### **뷰 사용 시 제약사항**

> [!WARNING]
> 뷰에 대한 조회(SELECT)에는 제한이 없지만, 삽입(INSERT), 수정(UPDATE), 삭제(DELETE) 등이 불가능할 수도 있음

특히 여러 테이블을 조인한 결과로 만들어진 뷰의 경우, **DML 연산이 제약 조건을 어기기 쉬움**.

```sql
-- 에러 예시
mysql> INSERT INTO myview (username, email, title) VALUES ('new_user', 'new_user@example.com', 'New Post');
ERROR 1393 (HY000): Can not modify more than one base table through a join view 'mydb.myview'

mysql> DELETE FROM myview WHERE username = 'some_user';
ERROR 1395 (HY000): Can not delete from join view 'mydb.myview'
```

## **인덱스(Index)**

> [!NOTE]
> 인덱스(Index)는 **검색 속도 향상을 목적으로 만드는 하나 이상의 테이블 필드에 대한 자료구조**
> 책의 '찾아보기'와 유사한 개념으로, 특정 필드를 기준으로 빠른 레코드 조회가 가능함

<img width="600" alt="image" src="https://github.com/user-attachments/assets/cfb6edfe-c9b9-4d20-87be-658c7a812042" />

실제로는 B 트리나 그 변형을 많이 사용한다.

### **인덱스의 원리**

인덱스는 책의 '목차', '찾아보기'처럼 작동함.

- 찾아보기의 '용어' = 데이터베이스의 '필드'
- 찾아보기의 '페이지' = 찾고자 하는 '레코드'

인덱스가 없다면 최악의 경우 원하는 레코드를 찾기 위해 모든 레코드를 탐색해야 함. => Full Table Scan

### **인덱스의 종류**

MySQL에서는 인덱스를 크게 두 가지로 구분.

1. **클러스터형 인덱스(Clustered Index)**
   - 테이블당 하나만 생성 가능
   - 기본 키(PRIMARY KEY)가 자동으로 클러스터형 인덱스가 됨
   - 만약 기본 키가 없으면 NOT NULL + UNIQUE 필드가 클러스터형 인덱스가 됨
2. **세컨더리 인덱스(Secondary Index)**
   - 논클러스터형 인덱스(Non-clustered Index)라고도 함
   - 테이블당 여러 개 생성 가능
   - 클러스터형 인덱스보다 일반적으로 느림

### 인덱스로 사용되는 자료구조

> [!NOTE]
> 인덱스로 사용되는 대표적인 자료구조는 **해시 테이블**과 **B-트리**임
> 특히 MySQL을 비롯한 많은 DBMS에서는 **B-트리**(혹은 B+ 트리와 같은 B-트리의 변형)를 사용함

#### **B-트리 기반 인덱스의 동작 원리**

'제품' 테이블에서 '제품 번호'를 기본 키로 하는 클러스터형 인덱스 생성한다고 가정한다.

| 제품 번호 | 제품 이름        | 제조사     |
| --------- | ---------------- | ---------- |
| 1         | 키보드           | 엘디       |
| 2         | 모니터           | 샘숭       |
| 3         | 혼공컴운         | 한빛미디어 |
| 4         | 혼공네트         | 한빛미디어 |
| 5         | 이것이컴퓨터과학 | 한빛미디어 |
| 6         | 스마트폰         | 애불       |
| 7         | 귤               | 제주도     |

**생성되는 B-트리 구조**는 아래와 같다.

```
      [3]
    /      \
[1,2]     [5,6,7]
  |         |
레코드      레코드
 위치        위치
```

### **B-트리 인덱스의 특징**

인덱스로 주로 사용되는 자료구조는 B-트리(또는 B+ 트리)임.

1. **각 노드의 구성**
   - 키(인덱스 값) 포함
   - 실제 데이터(레코드) 위치 정보 저장
2. **빠른 검색 가능**
   - B-트리의 특성상 다량의 노드에 대한 빠른 검색 가능
   - 정렬된 상태 유지로 범위 검색에도 효율적
3. **균형 트리 구조**
   - 모든 리프 노드까지의 거리가 동일
   - O(log n) 시간 복잡도로 검색 가능

<img width="600" alt="image" src="https://github.com/user-attachments/assets/35028d08-7271-4115-ac21-66538050733a" />

대부분의 RDBMS가 B-트리를 선택하는 이유는 범위 검색과 정렬이 중요하기 때문임.
SQL에서 WHERE 절의 범위 조건이나 ORDER BY 절을 효율적으로 처리하기 위해서는 B-트리가 더 적합함.
B-트리의 특성상 다량의 노드에 대한 빠른 검색이 가능하여, 인덱스를 바탕으로 레코드 위치를 빠르게 찾을 수 있음.

> [!TIP]
> 실제 DBMS에서는 B-트리보다 **B+ 트리**를 더 많이 사용함
> B+ 트리는 B-트리의 변형으로, 리프 노드에만 실제 데이터 포인터를 저장하는 특징이 있음

### **인덱스 관리 명령어**

```sql
-- 인덱스 생성
CREATE INDEX 인덱스_이름 ON 테이블_이름(필드);

-- 인덱스 조회
SHOW INDEX FROM 테이블_이름;

-- 인덱스 삭제
DROP INDEX 인덱스_이름 FROM 테이블_이름;
```

### **인덱스의 성능 개선 효과**

70만 개 레코드가 있는 테이블에서의 성능 비교를 해보자.

#### 인덱스 생성 전

```sql
mysql> SELECT * FROM users WHERE nickname='User290526U';
-- 소요 시간: 0.21초

mysql> SELECT COUNT(*) FROM users WHERE age>50;
-- 소요 시간: 0.22초

mysql> SELECT COUNT(*) FROM users WHERE gender='male';
-- 소요 시간: 0.19초
```

#### nickname 필드에 인덱스 생성 후

```sql
-- 인덱스 생성
mysql> CREATE INDEX idx_user ON users(nickname);

mysql> SELECT * FROM users WHERE nickname='User290526U';
-- 소요 시간: 0.00초 (즉시 조회!)

mysql> SELECT COUNT(*) FROM users WHERE age>50;
-- 소요 시간: 0.20초 (변화 없음)

mysql> SELECT COUNT(*) FROM users WHERE gender='male';
-- 소요 시간: 0.19초 (변화 없음)
```

### **인덱스 사용 시 고려사항**

인덱스는 양날의 검과 같음. 올바르게 사용하면 성능이 향상되지만, 잘못 사용하면 오히려 **성능이 저하**됨.

#### **인덱스의 장점**

- SELECT 쿼리의 성능 향상
- WHERE, ORDER BY, GROUP BY 절에서 빠른 처리
- 조인 성능 개선

#### **인덱스의 단점**

- 저장 공간 추가 필요
- INSERT, UPDATE, DELETE 시 성능 저하
- 인덱스 유지 및 갱신에 추가 자원 필요

### **인덱스 사용 권장 사항**

#### 인덱스가 효과적인 경우

- 데이터가 충분히 많은 테이블 (최소 수천 개 이상)
- 조회(SELECT)가 빈번한 테이블
- **WHERE, ORDER BY, JOIN**에 자주 사용되는 필드
- 중복도가 낮은 필드 (unique한 값이 많은 필드)

#### 인덱스 사용을 피해야 하는 경우

- 데이터가 적은 테이블
- INSERT, UPDATE, DELETE가 빈번한 테이블
- 중복 데이터가 많은 필드
- 테이블당 인덱스 개수는 3개 이하로 제한 권장
