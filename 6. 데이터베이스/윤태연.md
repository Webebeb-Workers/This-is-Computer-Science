# 데이터베이스의 큰 그림

## 데이터베이스와 DBMS

> [!NOTE]
> 데이터베이스는 여러 사람이 공유하여 사용할 목적으로 체계화해 통합, 관리하는 데이터의 집합<br>
> 원하는 **기능을 동작시키기 위해 마땅히 저장해야 하는 정보의 집합**

데이터베이스는 웹 서비스에 있어 심장과 같은 역할 수행. 저장되는 데이터와 방식에 따라 서비스의 정체성과 성능이 달라짐. 이를 관리하기 위한 수단이 바로 DBMS - Database Management System.

### DBMS의 종류

DBMS는 크게 두 유형으로 구분 가능.

1. **관계형 데이터베이스 관리 시스템(RDBMS)**
   - MySQL, Oracle, PostgreSQL, SQLite, MariaDB, Microsoft SQL Server 등
2. **NoSQL 데이터베이스 관리 시스템**
   - MongoDB, Redis 등

2023년 개발자 설문조사에 따르면, RDBMS가 여전히 높은 점유율 차지. MySQL과 그 오픈소스 버전인 MariaDB의 합산 점유율이 가장 높음.

### 서버로서의 DBMS

DBMS는 일반 응용 프로그램과 달리 사용자의 프로그램과 상호작용하며 실행되는 특성 보유. 클라이언트-서버 모델과 유사하게 동작.

#### SQL(Structured Query Language)

RDBMS에서 데이터를 조작하고 관리하기 위한 언어로, 크게 네 종류로 분류.

- **데이터 정의 언어 - DDL(Data Definition Language)**: CREATE, ALTER, DROP, TRUNCATE
- **데이터 조작 언어 - DML(Data Manipulation Language)**: SELECT, INSERT, UPDATE, DELETE
- **트랜잭션 제어 언어 - DCL(Data Control Language)**: GRANT, REVOKE
- **데이터 제어 언어 - TCL(Transaction Control Language)**: COMMIT, ROLLBACK, SAVEPOINT

## 파일 대신 데이터베이스를 이용하는 이유

> [!NOTE]
> 단순 파일 입출력 대신 데이터베이스를 사용하는 이유는 다양한 데이터 관리 기능과 안정성, 효율성 때문

1. **데이터 일관성 및 무결성 제공이 어려움**
   - 여러 사용자/프로그램이 동시에 데이터 접근 시 레이스 컨디션 발생 가능성
   - 모든 접근에 동기화 도구 사용이 번거로움
   - 개발자가 데이터 무결성을 일일이 검사하기 어려움
2. **불필요한 중복 저장이 많아짐**
   - 파일로 데이터 관리 시 같은 정보가 여러 파일에 중복 저장되는 문제 발생
   - 이로 인해 저장 공간 낭비 초래
3. **데이터 변경 시 연관 데이터 변경이 어려움**
   - 한 파일의 데이터 변경 시 다른 파일에서도 관련 데이터를 일일이 변경해야 함
4. **정교한 검색이 어려움**
   - 복합 조건을 활용한 검색은 파일 검색으로 구현하기 어려움
5. **백업 및 복구가 어려움**
   - 데이터베이스는 백업과 복구 기능을 기본 제공하나, 파일 입출력은 이런 기능 부족

## 데이터베이스의 저장 단위와 트랜잭션

### 데이터베이스의 저장 단위

> [!NOTE]
> 데이터베이스에는 다양한 속성을 가진 독립적 객체인 엔티티가 저장, 이는 데이터베이스 유형에 따라 다른 형태로 구현

#### 주요 개념

- **엔티티(Entity)**: 독립적으로 존재할 수 있는 객체, 실세계의 객체를 데이터베이스에 표현
  - 제품, 사용자, 주문과 같이 독립적으로 어떠한 특성을 가진, 식별 가능한 대상을 의미
- **속성(Attribute)**: 엔티티의 특성
  - 같은 속성을 공유하는 개별 엔티티는 같은 엔티티 집합에 속함
- **엔티티 집합**: 같은 속성을 공유하는 개별 엔티티들의 모음

<img width="600" alt="image" src="https://github.com/user-attachments/assets/dc9bd19f-d47a-4b93-8ee2-f3c4dc6c886f" />

> [!TIP]
> 엔티티의 속성이 가질 수 있는 값의 집합은 도메인(domain)이라고 함 <br>
> 가령 '구매자 성별' 속성이 가질 수 있는 도메인은 {남자, 여자}임

### RDBMS와 NoSQL의 저장 단위 비교

엔티티들은 RDBMS에서는 테이블 안에, MongoDB에서는 컬렉션 안에 저장됨.

#### RDBMS의 저장단위

- **릴레이션(테이블)**: 이차원 테이블 형태의 엔티티 집합
- **레코드(행)**: 데이터베이스에 기록된 각각의 엔티티
- **필드(열)**: 데이터베이스에 저장된 엔티티 속성

#### NoSQL(MongoDB)의 저장단위

- **컬렉션**: 엔티티의 집합
- **도큐먼트**: JSON 형태의 엔티티
- **필드**: JSON의 키

> [!NOTE]
> 필드의 수는 차수(degree)라고도 부름<br>
> 한 필드에 대한 고유 값의 수는 카디날리티(Cardinality)라고 부름<br>
> 즉, 카디날리티가 낮을수록 중복된 속성이 많음을 시사함

### 스키마

> [!NOTE]
> 스키마는 데이터베이스에 저장되는 레코드의 구조와 제약 조건을 정의한 것으로, 레코드가 지켜야 할 틀이자 청사진

- **RDBMS**: 명확한 스키마 정의 필요, 모든 레코드가 동일한 구조 준수
- **NoSQL**: 스키마-리스(schema-less) 특성으로, 유연한 데이터 구조 허용

### 트랜잭션과 ACID

> [!NOTE]
> 트랜잭션은 데이터베이스와의 논리적 상호작용 단위로, 데이터베이스가 처리하는 작업의 단위

초당 트랜잭션(TPS, Transactions Per Second)이라는 지표로 데이터베이스의 작업 성능을 나타내기도 함.

> [!TIP]
> 트랜잭션이라는 용어나 TPS라는 지표는 주로 데이터베이스에서 언급되는 용어이지만, 데이터베이스에서만 사용되는 용어는 아님<br>
> 메모리 트랜잭션이나 전자상거래의 거래 단위로도 사용됨

트랜잭션이 지켜야 하는 ACID 특성은 아래와 같다.

#### 1. 원자성(Atomicity)

- 트랜잭션 결과가 모두 성공하거나 모두 실패하는 성질
- "All or Nothing" 원칙 준수
- 반드시 커밋되거나 롤백되는 성질

> [!TIP]
> 커밋(commit): 트랜잭션을 성공적으로 수행하여 트랜잭션을 종료하는 것, 트랜잭션으로 인한 변경 사항을 확정<br>
> 롤백(rollback): 이전 트랜잭션을 취소하는 작업
>
> <img width="600" alt="image" src="https://github.com/user-attachments/assets/c3a4c50a-3f47-4ea0-b826-c6bfaa57019b" />

#### 2. 일관성(Consistency)

- 트랜잭션 전후로 데이터베이스가 일관된 상태 유지
- '일관된 상태'는 데이터베이스가 지켜야 하는 규칙들을 지키는 상태

#### 3. 격리성(Isolation)

- 동시에 수행되는 여러 트랜잭션이 서로 간섭하지 않도록 보장
- 레이스 컨디션 방지를 위한 성질

#### 4. 지속성(Durability)

- 트랜잭션이 성공적으로 완료된 후 결과가 영구적으로 반영
- 시스템 장애 발생 시에도 완료된 트랜잭션 결과는 보존

---

> [!TIP]
> 데이터베이스 학습 과정에서는 RDBMS의 기본, SQL, 효율적 쿼리, 데이터베이스 설계, NoSQL까지 단계적으로 학습 필요
> ![](https://github.com/user-attachments/assets/b57a694b-6ac4-45ae-bdc3-6e38f78912bd)

# SQL

> [!NOTE]
> SQL 명령은 크게 **DDL**(데이터 정의 언어), **DML**(데이터 조작 언어), **DCL**(데이터 제어 언어), **TCL**(트랜잭션 제어 언어)로 분류됨

## DDL(데이터 정의 언어)

> [!NOTE]
> DDL은 **데이터베이스와 테이블 같은 객체의 구조를 정의하는 SQL**

### 주요 명령어

| 종류     | 설명                                                      |
| -------- | --------------------------------------------------------- |
| CREATE   | 데이터베이스 혹은 데이터베이스 객체 생성                  |
| ALTER    | 데이터베이스 객체 갱신(테이블에 필드/제약 조건 추가/삭제) |
| DROP     | 데이터베이스 객체 삭제                                    |
| TRUNCATE | 테이블 구조를 유지한 채 모든 레코드 삭제                  |

> [!NOTE]
> 데이터베이스 객체란 데이터베이스에서 정의될 수 있는 대상을 통칭하는 용어임
> 테이블, 인덱스, 뷰 등이 대표적

### CREATE

#### 데이터베이스 생성

```sql
CREATE DATABASE 데이터베이스_이름;
CREATE DATABASE mydb;
```

- SQL문의 끝에는 세미콜론(;) 필수
- 생성된 데이터베이스 조회: `SHOW DATABASES;`
- 특정 데이터베이스 사용: `USE 데이터베이스_이름;`

#### 테이블 생성

기본 구문은 아래와 같다.

```sql
CREATE TABLE 테이블_이름 (
  필드_이름1 필드_타입,
  필드_이름2 필드_타입,
  필드_이름3 필드_타입,
  ...
);
```

#### 주요 제약 조건

특징 필드에 필드 타입을 입력해 제약 조건을 세울 수 있음.

| 키워드        | 제약 조건                           |
| ------------- | ----------------------------------- |
| PRIMARY KEY   | 특정 필드를 기본 키로 지정          |
| UNIQUE        | 특정 필드가 고유한 값을 갖도록 설정 |
| FOREIGN KEY   | 특정 필드를 외래 키로 지정          |
| DEFAULT       | 기본값 지정                         |
| NULL/NOT NULL | 특정 필드에 NULL 값을 허용/불허용   |

> [!TIP]
> UNIQUE 제약 조건이 명시된 필드는 고유 키(UNIQUE KEY)라고도 부름
> 고유 키는 중복값 불가능하지만, 기본 키와 달리 테이블 내 여러 개 존재 가능하고 NULL 값 허용

#### 실제 예제

<img width="600" alt="image" src="https://github.com/user-attachments/assets/de6b0bef-3d50-42f1-9ec1-8c039833c100" />

```sql
-- users 테이블 생성
CREATE TABLE users (
  user_id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(50) NOT NULL,
  email VARCHAR(100) UNIQUE,
  birthdate DATE,
  registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- posts 테이블 생성 (외래 키 포함)
CREATE TABLE posts (
  post_id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT,
  title VARCHAR(50) NOT NULL,
  content VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

- **AUTO_INCREMENT**: 레코드 추가 시 자동으로 1씩 증가
- **CURRENT_TIMESTAMP**: 현재 시간 자동 입력
- **FOREIGN KEY**: users 테이블의 user_id를 참조하는 외래 키 설정

#### 제약 조건 별도 정의 방식

```sql
CREATE TABLE tests (
  post_id INT AUTO_INCREMENT,
  user_id INT,
  title VARCHAR(50) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (post_id),
  CONSTRAINT FK_user FOREIGN KEY (user_id) REFERENCES users(user_id),
  CONSTRAINT UQ_title UNIQUE (title)
);
```

- **CONSTRAINT**: 제약 조건에 이름 부여 가능
- CREATE TABLE 하단에 제약 조건 추가적으로 명시 가능

### ALTER

**테이블 구조 변경**을 위한 명령어임.

#### 필드 관련 작업

```sql
-- 새로운 필드 추가
-- ALTER TABLE 테이블_이름 ADD COLUMN 필드_이름 필드_타입 [제약 조건]
ALTER TABLE posts ADD COLUMN new_field VARCHAR(50) NOT NULL;

-- 기존 필드 수정
-- ALTER TABLE 테이블_이름 CHANGE COLUMN 기존_필드_이름 새_필드_이름 필드_타입 [제약 조건]
ALTER TABLE posts CHANGE COLUMN new_field old_field VARCHAR(30) NOT NULL;

-- 기존 필드 삭제
-- ALTER TABLE 테이블_이름 DROP COLUMN 필드_이름
ALTER TABLE posts DROP COLUMN old_field;

-- 외래 키 제약 조건 추가
-- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_ 이름]
-- ADD FOREIGN KEY (필드_ 이름) REFERENCES 참조_테이블_이름(참조_필드)
ALTER TABLE posts ADD FOREIGN KEY (user_id) REFERENCES users(user_id);

-- UNIQUE 제약 조건 추가
-- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_이름] UNIQUE (필드_ 이름)
ALTER TABLE posts ADD UNIQUE (title);

-- NOT NULL 제약 조건 추가
-- ALTER TABLE 테이블_이름 MODIFY 필드_이름 필드_타입 NOT NULL
ALTER TABLE users MODIFY email VARCHAR(100) NOT NULL;

-- 기본 키 설정(PRIMARY KEY로 사용 중인 필드가 없을 경우
-- ALTER TABLE 테이블_이름 ADD PRIMARY KEY (필드_이름)
ALTER TABLE posts ADD PRIMARY KEY (post_id);
```

> [!TIP]
> ALTER문은 테이블뿐만 아니라 뷰, 인덱스 등 다른 데이터베이스 객체에도 적용 가능함

### DROP

**데이터베이스 객체를 완전히 삭제**하는 명령어임.

```sql
-- 데이터베이스 삭제
DROP DATABASE mydb;

-- 테이블 삭제
DROP TABLE 테이블_이름;
```

- 삭제 후 복구 불가능하므로 주의 필요
- DROP문도 테이블 외에 뷰, 인덱스 등에 적용 가능

### TRUNCATE

**테이블 구조는 유지하면서 모든 레코드만 삭제**함.

```sql
TRUNCATE TABLE 테이블_이름;
TRUNCATE TABLE users;
```

- 테이블의 구조(필드, 제약조건 등)는 그대로 유지
- 모든 데이터만 삭제되어 빈 테이블 상태가 됨
- `DESC 테이블_이름` 명령으로 테이블 구조 확인 시 여전히 표시됨

> [!NOTE]
> TRUNCATE는 `DELETE FROM 테이블_이름`과 유사하지만, 더 빠르고 로그를 적게 생성함
> 단, 조건절 사용 불가하고 전체 데이터만 삭제 가능함

## DML(데이터 조작 언어)

> [!NOTE]
> SQL DDL, DML, DCL 중 **기술 면접과 실무에서 가장 자주 언급되는 명령어 집합**

| 종류   | 설명                 |
| ------ | -------------------- |
| SELECT | 테이블의 레코드 조회 |
| INSERT | 테이블에 레코드 삽입 |
| UPDATE | 테이블의 레코드 수정 |
| DELETE | 테이블의 레코드 삭제 |

### INSERT

테이블에 **새로운 레코드를 삽입**하는 명령어임.

#### 기본 구문

```sql
-- 레코드 하나 삽입
INSERT INTO 테이블_이름(필드1, 필드2) VALUES (값1, 값2);

-- 여러 레코드 삽입
INSERT INTO 테이블_이름(필드1, 필드2, 필드3) VALUES
  (값1, 값2, 값3),
  (값1, 값2, 값3),
  (값1, 값2, 값3);
```

- 삽입할 값이 지정되지 않은 필드는 기본값으로 채워짐
- 기본값이 없으면 NULL로 채워짐

#### 실제 예제

```sql
-- users 테이블에 레코드 삽입
INSERT INTO users (username, email, birthdate) VALUES
  ('kim', 'kim@example.com', '1996-05-15');

-- 여러 레코드 한 번에 삽입
INSERT INTO users (username, email, birthdate) VALUES
  ('lee', 'lee@example.com', '1994-03-22'),
  ('park', 'park@example.com', '1988-07-11'),
  ('choi', 'choi@example.com', '2000-01-30'),
  ('jung', 'jung@example.com', '1992-12-05');
```

<img width="600" alt="image" src="https://github.com/user-attachments/assets/5dd9f76a-ee0e-4cd3-a8d0-103a123d1b51" />

> [!NOTE]
> 위 이미지에서, `user_id`와 `registration_date` 필드는 삽입할 데이터를 지정하지 않아도 기본값으로 각각 '1부터 증가하는 정수'와 '현재 시간'이 삽입

#### 외래 키 참조 상황

```sql
-- posts 테이블에 레코드 삽입 (외래 키 참조)
INSERT INTO posts (user_id, title, content) VALUES
  (1, 'Hi', 'Hello');
```

- `posts` 테이블의 `user_id`는 `users` 테이블의 `user_id`를 참조하는 외래 키
- 삽입할 레코드의 `user_id`가 `users` 테이블에 존재해야 함

#### 무결성 제약 조건

레코드 삽입 시 무결성 제약 조건을 지켜야 함.

```sql
-- NOT NULL 제약 조건 위배: 실행 안 됨
INSERT INTO users (username, email) VALUES
  (NULL, 'no_name@example.com');

-- UNIQUE 제약 조건 위배: 이미 존재하는 경우 실행 안 됨
INSERT INTO users (username, email) VALUES
  ('kim', 'kim@example.com');

-- 외래 키 제약 조건 위배: 참조할 레코드가 없으면 실행 안 됨
INSERT INTO posts (user_id, title, content) VALUES
  (10, 'Hi', 'Hello');
```

### UPDATE

**레코드를 수정**하는 SQL 명령임.

#### 기본 구문

```sql
UPDATE 테이블_이름
  SET 필드1 = 값1, 필드2 = 값2, ...
  WHERE 조건식;
```

- `WHERE` 절은 생략 가능하나, 생략 시 모든 레코드가 갱신됨
- `SET`의 `=`는 대입 연산자, `WHERE`의 `=`는 비교 연산자

#### 비교/논리 연산자

| 연산자              | 설명                                             |
| ------------------- | ------------------------------------------------ |
| =                   | 같을 경우 참                                     |
| >                   | 클 경우 참                                       |
| <                   | 작을 경우 참                                     |
| >=                  | 크거나 같을 경우 참                              |
| <=                  | 작거나 같을 경우 참                              |
| <>                  | 다를 경우 참                                     |
| 조건식1 AND 조건식2 | 조건식1과 조건식2가 모두 만족할 경우 참          |
| 조건식1 OR 조건식2  | 조건식1과 조건식2 둘 중 하나만 만족할 경우 참    |
| NOT 조건식          | 조건식이 아닐 경우 참                            |
| IN                  | IN 뒤에 명시되는 값과 하나 이상이 일치할 경우 참 |

#### 실제 예제

```sql
-- username이 'kim'인 사용자의 이메일 수정
UPDATE users
  SET email = 'kim_new@example.com'
  WHERE username = 'kim';

-- post_id가 5보다 큰 모든 게시글 제목 수정
UPDATE posts
  SET title = 'Updated Title'
  WHERE post_id > 5;
```

### DELETE

**조건에 맞는 레코드를 삭제**하는 명령임. UPDATE에서 사용한 논리/비교 연산자를 사용할 수 있는 등 명령 구조가 비슷하다.

#### 기본 구문

```sql
DELETE FROM 테이블_이름
  WHERE 조건식;
```

- `WHERE`절 생략 시 모든 레코드 삭제 => 대참사!

#### 실제 예제

```sql
-- title이 'Hi'인 게시글 삭제
DELETE FROM posts
  WHERE title = 'Hi';
```

### 외래 키 제약 조건 - ON UPDATE, ON DELETE

> [!WARNING]  
> 한 테이블이 다른 테이블을 외래 키로 참조하는 상황에서 참조되는 레코드가 수정/삭제될 경우, **참조하는 레코드의 동작을 정의**해야 함

<img width="600" alt="image" src="https://github.com/user-attachments/assets/c0b2df6f-eac4-4ff0-8274-c97e0b47fa6f" />

| 제약 조건   | 설명                                       |
| ----------- | ------------------------------------------ |
| CASCADE     | 참조하는 데이터도 함께 수정/삭제           |
| SET NULL    | 참조하는 데이터를 NULL로 변경              |
| SET DEFAULT | 참조하는 데이터를 기본값으로 변경          |
| RESTRICT    | 수정/삭제를 허용하지 않음                  |
| NO ACTION   | (MySQL의 경우) 사실상 RESTRICT와 동일 동작 |

```sql
CREATE TABLE posts (
  post_id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT,
  title VARCHAR(50) NOT NULL,
  content VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(user_id)
  ON UPDATE CASCADE    -- users의 user_id 수정 시 함께 수정
  ON DELETE SET NULL   -- users의 user_id 삭제 시 NULL로 변경
);
```

### SELECT

**삽입된 레코드를 조회**하는 **가장 중요**한 SQL 명령임.

#### 기본 구문

```sql
SELECT 필드1, 필드2, ...
  FROM 테이블_이름
  WHERE 조건식
  GROUP BY 그룹화할_필드
  HAVING 필터_조건
  ORDER BY 정렬할_필드
  LIMIT 레코드_제한;
```

- 필드에 `*` 사용 시 모든 필드 조회
- **실행 순서**: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

#### 기본 조회

```sql
-- 모든 레코드 조회
SELECT * FROM students;

-- 특정 필드만 조회
SELECT first_name, last_name, major
  FROM students
  WHERE major = 'Computer Science';

-- 조건부 조회
SELECT first_name, last_name, age
  FROM students
  WHERE age >= 21;
```

#### 패턴 검색: LIKE

WHERE에서는 `=`를 썼었는데, 이는 정확히 일치하는 것만 찾음. LIKE를 사용하면 **해당되는 패턴을 가진 값**들을 가져올 수 있음.

```sql
-- 'Science'라는 단어가 포함된 전공 검색
SELECT first_name, last_name, major
  FROM students
  WHERE major LIKE '%Science%';

-- 두 번째 문자가 'a'인 전공 검색
SELECT first_name, last_name, major
  FROM students
  WHERE major LIKE '_a%';
```

- `%`: 0개 이상의 임의의 문자와 일치
- `_`: 정확히 1개의 임의의 문자와 일치

#### 집계 함수

연산/집계 함수는 이름 그대로 조회된 레코드에 대한 **특정 연산을 수행하거나 집계**하는 함수.

| 함수  | 설명                        |
| ----- | --------------------------- |
| COUNT | 조회된 레코드 개수 반환     |
| SUM   | 조회된 레코드의 총합 반환   |
| AVG   | 조회된 레코드의 평균 반환   |
| MAX   | 조회된 레코드의 최댓값 반환 |
| MIN   | 조회된 레코드의 최솟값 반환 |

<img width="600" alt="image" src="https://github.com/user-attachments/assets/08b4fffd-b2f8-4b3a-bae5-618adfa41996" />

```sql
-- 학생 수, 평균 학점, 최고/최저 학점 조회
SELECT COUNT(*), AVG(gpa), MAX(gpa), MIN(gpa)
  FROM students;
```

조회된 속성의 이름을 정해주는, AS랑 많이 쓰인다.

### GROUP BY

**특정 필드를 기준**으로 **레코드를 그룹화**할 때 사용됨.

```sql
-- 전공별 학생 수 조회
SELECT major, COUNT(*) AS student_count
  FROM students
  GROUP BY major;

-- 나이별 학생 수 조회
SELECT age, COUNT(*) AS student_count
  FROM students
  GROUP BY age;
```

<img width="600" alt="image" src="https://github.com/user-attachments/assets/d27bdd56-b84d-42dc-98dc-b798d43c078a" />

### HAVING

**그룹화된 결과에 조건을 적용**할 때 사용됨.

```sql
-- 평균 GPA가 3.6 이상인 전공 조회
SELECT major, AVG(gpa)
  FROM students
  GROUP BY major
  HAVING AVG(gpa) >= 3.6;

-- 평균 나이가 21세 이상인 전공 조회
SELECT major, AVG(age)
  FROM students
  GROUP BY major
  HAVING AVG(age) >= 21;
```

> [!TIP]
> WHERE절은 그룹화 전 개별 레코드에 대한 조건이며, HAVING절은 **그룹화된 레코드에 대한 조건**임

### ORDER BY

특정 필드를 기준으로 **레코드를 정렬**할 때 사용됨.

```sql
-- GPA 기준 내림차순 정렬
SELECT first_name, last_name, gpa
  FROM students
  ORDER BY gpa DESC;

-- 성 기준 오름차순 정렬
SELECT first_name, last_name, major
  FROM students
  ORDER BY last_name ASC;
```

- 기본값은 오름차순(ASC) 정렬
- DESC 키워드로 내림차순 정렬 가능

### LIMIT

**조회할 레코드 수를 제한**할 때 사용됨.

```sql
-- 상위 3개 레코드만 조회
SELECT * FROM students LIMIT 3;

-- 3번째 레코드부터 2개 조회 (시작점 지정)
SELECT * FROM students LIMIT 2, 2;
```

---

> [!WARNING]
> SELECT문의 실제 실행 순서는 작성 순서와 다름
> 이에 유의하지 않으면 예기치 못한 성능 저하나 의도하지 않은 결과가 발생할 수 있음
>
> 작성 순서: SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY → LIMIT
> 실행 순서: FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

## TCL(트랜잭션 제어 언어)

TCL(Transaction Control Language)은 **트랜잭션을 제어**하는 SQL 명령들을 포함함.

| 종류      | 설명                      |
| --------- | ------------------------- |
| COMMIT    | 데이터베이스에 작업 반영  |
| ROLLBACK  | 작업 이전의 상태로 되돌림 |
| SAVEPOINT | 롤백의 기준점 설정        |

한 트랜잭션에는 여러 쿼리가 포함될 수 있으며, 모든 작업이 성공하거나 모두 실패하는 원자성을 보장함.

### 트랜잭션 기본 개념

#### 트랜잭션 시작

```sql
-- 트랜잭션 시작 (둘 다 같은 의미)
START TRANSACTION;
-- 또는
BEGIN;
```

- DBMS에게 트랜잭션이 시작됨을 알리는 명령
- 이후 실행되는 SQL문들은 하나의 트랜잭션으로 묶임

#### 예제: 계좌 이체

```sql
-- accounts 테이블 생성 및 데이터 삽입
CREATE TABLE accounts (
  account_id INT PRIMARY KEY,
  account_name VARCHAR(50),
  balance INT
);

INSERT INTO accounts (account_id, account_name, balance) VALUES
  (1, 'Kim', 1000),
  (2, 'Lee', 500);
```

계좌 이체는 두 개의 UPDATE문이 함께 실행되어야 하는 트랜잭션의 대표적 예시임.

```sql
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
```

### COMMIT

트랜잭션이 성공적으로 완료돼 **모든 변경 사항을 데이터베이스에 영구적으로 반영**함.

```sql
START TRANSACTION;

-- 시점 1: 2개의 레코드 확인
SELECT * FROM accounts;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- 시점 2: 두 UPDATE문이 실행되었음을 확인
SELECT * FROM accounts;

COMMIT;

-- 시점 3: accounts 테이블은 시점 2와 같음
SELECT * FROM accounts;
```

### ROLLBACK

트랜잭션에서 **수행된 변경 사항을 취소**하고, 데이터베이스를 트랜잭션 시작 **이전 상태로 되돌림**.

```sql
START TRANSACTION;

-- 시점 1: 2개의 레코드 확인
SELECT * FROM accounts;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;

-- 시점 2: account_id가 1인 레코드의 balance가 100 감소
SELECT * FROM accounts;

ROLLBACK;

-- 시점 3: accounts 테이블은 시점 1과 같음 (UPDATE 취소)
SELECT * FROM accounts;
```

### SAVEPOINT

SAVEPOINT는 ROLLBACK으로 되돌아갈 **중간 지점을 설정하는 기능**임. 트랜잭션 내 특정 시점으로 **부분적 롤백이 가능**함.

#### 기본 구문

```sql
-- 세이브포인트 생성
SAVEPOINT 세이브포인트_이름;

-- 세이브포인트로 롤백
ROLLBACK TO SAVEPOINT 세이브포인트_이름;
```

#### 예제

```sql
START TRANSACTION;

-- 세이브포인트 생성 1
SAVEPOINT sp1;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- 세이브포인트 생성 2
SAVEPOINT sp2;
UPDATE accounts SET account_name = 'new_Kim' WHERE account_id = 1;
UPDATE accounts SET account_name = 'new_Lee' WHERE account_id = 2;

-- 세이브포인트 생성 3
SAVEPOINT sp3;
SELECT * FROM accounts;

-- 특정 세이브포인트로 롤백 (최근 변경사항만 취소)
ROLLBACK TO SAVEPOINT sp2;  -- sp3의 변경사항 취소
ROLLBACK TO SAVEPOINT sp1;  -- sp2의 변경사항 취소
```

### 자동 커밋(Auto Commit)

> [!WARNING]
> MySQL에서는 기본적으로 자동 커밋이 활성화돼 있어, 매 SQL문이 자동으로 커밋됨
> DDL문은 항상 자동으로 커밋되며 롤백할 수 없음

#### 자동 커밋 제어

```sql
-- 자동 커밋 비활성화
SET autocommit = 0;

-- 자동 커밋 활성화
SET autocommit = 1;
```

- `START TRANSACTION` 또는 `BEGIN` 실행 시 자동으로 자동 커밋이 비활성화됨
- 트랜잭션 내에서는 `COMMIT`이나 `ROLLBACK`을 만나기 전까지 커밋되지 않음

> [!TIP]
> DDL(Data Definition Language) 문장들은 항상 자동으로 커밋됨
> CREATE, ALTER, DROP, TRUNCATE 등의 DDL문은 실행 즉시 현재 트랜잭션을 종료하고 변경사항을 확정함

## 데이터 제어 언어(DCL)

DCL(Data Control Language)은 데이터베이스 사용자의 권한을 관리하는 SQL 명령어 집합임.

| 종류   | 설명                   |
| ------ | ---------------------- |
| GRANT  | 사용자에게 권한 부여   |
| REVOKE | 사용자로부터 권한 회수 |

DBMS는 서버처럼 사용자 계정과 권한을 관리함.

### 사용자 관리

```sql
-- 사용자 생성
CREATE USER '사용자명'@'호스트' IDENTIFIED BY '비밀번호';

-- 사용자 삭제
DROP USER '사용자명'@'호스트';
```

### 권한 관리

```sql
-- 권한 부여
GRANT 권한목록 ON 데이터베이스.테이블 TO '사용자명'@'호스트';

-- 권한 회수
REVOKE 권한목록 ON 데이터베이스.테이블 FROM '사용자명'@'호스트';
```

DCL을 통해 각 사용자별로 사용 가능한 SQL 명령을 제한하고, 데이터베이스 보안을 관리할 수 있음.
