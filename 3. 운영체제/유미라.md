# 2. 프로세스와 스레드
- **포그라운드 프로세스** : 사용자가 보는 공간에서 사용자와 상호작용하며 실행되는 프로세스
- **백그라운드 프로세스** : 사용자가 보지 못하는 곳에서 실행되는 프로세스
    - **데몬** : 사용자와 별 다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스

### 사용자 영역
![image](https://github.com/user-attachments/assets/597703a2-3fd6-4d3a-9b05-f7132cf8bafd)

#### 코드 영역 (텍스트 영역)
- 실행 가능한 명령어가 저장되는 공간 (read-only)

#### 데이터 영역
- 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
- 정적 변수나 전역 변수

#### 힙 영역 
- 프로그램을 만드는 사용자가 직접 할당 가능한 저장공간
- **메모리 누수** : 메모리 공간을 반환하지 않으면 할당한 공간이 계속 메모리에 남아 메모리를 낭비한다.
- **가비지 컬렉션** : 프로그래밍 언어에서 자체적으로 사용되지 않는 힙 메모리를 해제하는 기능

#### 스택 영역
- 데이터 영역에 담기는 값과는 달리 일시적으로 사용할 값들이 저장되는 공간
- 매개변수, 지역 변수, 함수 복귀 주소
- **스택 트레이스** : 특정 시점에 스택에 저장된 함수 호출 정보

### PCB와 문맥 교환
#### 프로세스 제어 블록(PCB)
![image](https://github.com/user-attachments/assets/ba9298f4-fc49-4290-99ee-57b11f504b6c)

- 프로세스를 식별할 수 있는 커널 영역 내의 정보
- 프로세스 ID, 실행 과정에서 사용한 레지스터 값, 프로세스 상태, CPU 스케줄링 정보, 메모리 관련 정보, 파일 및 입출력장치 관련 정보 등
- 여러 PCB는 프로세스 테이블의 형태로 관리된다.

#### 문맥 교환
![image](https://github.com/user-attachments/assets/7d5ac65b-a376-4004-bb36-956b8bae6fa2)

- 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다린다.
- **문맥(Context)** : 프로세스의 수행을 재개하기 위해 기억해야 할 정보
- **문맥 교환** : 기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 새로운 프로세스를 실행하는 것

### 프로세스의 상태
![image](https://github.com/user-attachments/assets/2956d378-abdc-49e4-87f2-54f7c9ef989f)

- **생성 상태** : 프로세스를 생성 중인 상태로, 메모리에 적재되어 PCB를 할당받은 상태
- **준비 상태** : CPU를 할당받아 실행할 수 있지만, 차례가 아니기 때문에 기다리고 있는 상태
- **실행 상태** : CPU를 할당받아 실행 중인 상태
- **대기 상태** : 곧장 실행이 불가능한 조건에 놓이는 경우, 입출력 작업을 요청하는 경우가 대표적이다.
- **종료 상태** : 프로세스가 종료된 상태

## 멀티프로세스와 멀티스레드
#### 멀티프로세스
![image](https://github.com/user-attachments/assets/3419f68e-802f-4144-8fde-ff97c1893b85)

- 동시에 여러 프로세스가 실행되는 것
- 자원을 공유하지 않고, 독립적으로 실행된다.

#### 멀티스레드
![image](https://github.com/user-attachments/assets/eda6b360-37ba-40f5-9858-d755620456f9)

- 한 프로세스를 구성하는 코드를 동시에 실행하는 것
- 스레드 ID, 프로그램 카운터, 레지스터 값, 스택 등
- 여러 스레드는 코드, 데이터, 힙 영역이나 열린 파일과 같은 프로세스의 자원을 공유한다.

## 프로세스 간 통신
![image](https://github.com/user-attachments/assets/0b8566dd-9434-4802-8236-1eff073445ba)

- **프로세스 간 통신 (IPC)** : 프로세스 간 자원을 공유하고 데이터를 주고 받는 방법
- 공유 메모리, 메시지 전달

### 공유 메모리
- 공유하는 메모리 영역(사용자 영역)을 토대로 데이터를 주고받는 통신 방식
- 각 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것처럼 통신한다.
- 프로세스가 공유하는 메모리 영역을 확보하는 시스템 콜을 기반으로 수행될 수도 있고, 간단하게 프로세스가 공유하는 변수나 파일을 활용할 수도 있다.

#### 장점
- 커널의 개입이 거의 없다. 
- 메모리 영역을 읽고 쓰는 것뿐이므로 메시지 전달 방식보다 통신 속도가 빠르다.

#### 단점
- 각각의 프로세스가 서로의 공유 메모리 영역을 동시에 읽고 쓸 경우, 데이터의 일관성이 훼손될 수 있다.

### 메시지 전달
- 데이터가 커널을 거쳐 송수신되는 통신 방식
- 메시지를 보내는 수단과 받는 수단이 명확하게 구분되어 있다.
- 파이프, 시그널, 소켓, 웬격 프로시저 호출 (RPC)

#### 장점
- 커널의 도움을 적극적으로 받을 수 있기 때문에 상대적으로 동기화 문제를 고려할 일이 적다.

#### 단점
- 데이터가 커널을 통해 송수신되므로 공유 메모리 기반 IPC보다 통신 속도는 느리다.

#### 파이프
![image](https://github.com/user-attachments/assets/c427a542-3fc0-49b8-bd2e-c0a83988bbe0)

- 프로세스 간의 단방향 통신 도구
- 한 쪽 방향에서 데이터를 쓰면 파이프 반대쪽으로 그 데이터를 읽을 수 있다.
- 읽기용 파이프와 쓰기용 파이프 2개를 이용해 양방향으로 통신할 수 있다.

#### 시그널
![image](https://github.com/user-attachments/assets/f268ec90-76e8-4c82-86f2-f18830d91be3)

- 이벤트가 발생했음을 알리는 비동기적인 신호
- 프로세스는 시그널이 발생하면 하던 일을 잠시 중단하고 시그널 처리를 위한 시그널 핸들러를 실행한 뒤 실행을 재개한다.
- 프로세스는 직접 특정 시그널을 발생시킬 수 있고, 직접 일부 시그널 핸들러를 정의할 수 있다.
- 시그널이 발생했을 때의 동작을 정의하여 프로세스에게 해당 시그널을 보냄으로써 프로세스 간 통신을 수행할 수 있다. 

#### 원격 프로시저 호출 (RPC)
- 다른 프로세스의 원격 코드 실행
- 언어나 플랫폼이 달라도 작동하고, 성능 저하를 최소화하면서 메시지 주고받을 수 있어서 서버 간 통신에서 많이 사용된다.
