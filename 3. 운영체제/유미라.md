# 2. 프로세스와 스레드
- **포그라운드 프로세스** : 사용자가 보는 공간에서 사용자와 상호작용하며 실행되는 프로세스
- **백그라운드 프로세스** : 사용자가 보지 못하는 곳에서 실행되는 프로세스
    - **데몬** : 사용자와 별 다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스

### 사용자 영역
![image](https://github.com/user-attachments/assets/597703a2-3fd6-4d3a-9b05-f7132cf8bafd)

#### 코드 영역 (텍스트 영역)
- 실행 가능한 명령어가 저장되는 공간 (read-only)

#### 데이터 영역
- 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
- 정적 변수나 전역 변수

#### 힙 영역 
- 프로그램을 만드는 사용자가 직접 할당 가능한 저장공간
- **메모리 누수** : 메모리 공간을 반환하지 않으면 할당한 공간이 계속 메모리에 남아 메모리를 낭비한다.
- **가비지 컬렉션** : 프로그래밍 언어에서 자체적으로 사용되지 않는 힙 메모리를 해제하는 기능

#### 스택 영역
- 데이터 영역에 담기는 값과는 달리 일시적으로 사용할 값들이 저장되는 공간
- 매개변수, 지역 변수, 함수 복귀 주소
- **스택 트레이스** : 특정 시점에 스택에 저장된 함수 호출 정보

### PCB와 문맥 교환
#### 프로세스 제어 블록(PCB)
![image](https://github.com/user-attachments/assets/ba9298f4-fc49-4290-99ee-57b11f504b6c)

- 프로세스를 식별할 수 있는 커널 영역 내의 정보
- 프로세스 ID, 실행 과정에서 사용한 레지스터 값, 프로세스 상태, CPU 스케줄링 정보, 메모리 관련 정보, 파일 및 입출력장치 관련 정보 등
- 여러 PCB는 프로세스 테이블의 형태로 관리된다.

#### 문맥 교환
![image](https://github.com/user-attachments/assets/7d5ac65b-a376-4004-bb36-956b8bae6fa2)

- 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다린다.
- **문맥(Context)** : 프로세스의 수행을 재개하기 위해 기억해야 할 정보
- **문맥 교환** : 기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 새로운 프로세스를 실행하는 것

### 프로세스의 상태
![image](https://github.com/user-attachments/assets/2956d378-abdc-49e4-87f2-54f7c9ef989f)

- **생성 상태** : 프로세스를 생성 중인 상태로, 메모리에 적재되어 PCB를 할당받은 상태
- **준비 상태** : CPU를 할당받아 실행할 수 있지만, 차례가 아니기 때문에 기다리고 있는 상태
- **실행 상태** : CPU를 할당받아 실행 중인 상태
- **대기 상태** : 곧장 실행이 불가능한 조건에 놓이는 경우, 입출력 작업을 요청하는 경우가 대표적이다.
- **종료 상태** : 프로세스가 종료된 상태

## 멀티프로세스와 멀티스레드
#### 멀티프로세스
![image](https://github.com/user-attachments/assets/3419f68e-802f-4144-8fde-ff97c1893b85)

- 동시에 여러 프로세스가 실행되는 것
- 자원을 공유하지 않고, 독립적으로 실행된다.

#### 멀티스레드
![image](https://github.com/user-attachments/assets/eda6b360-37ba-40f5-9858-d755620456f9)

- 한 프로세스를 구성하는 코드를 동시에 실행하는 것
- 스레드 ID, 프로그램 카운터, 레지스터 값, 스택 등
- 여러 스레드는 코드, 데이터, 힙 영역이나 열린 파일과 같은 프로세스의 자원을 공유한다.

## 프로세스 간 통신
![image](https://github.com/user-attachments/assets/0b8566dd-9434-4802-8236-1eff073445ba)

- **프로세스 간 통신 (IPC)** : 프로세스 간 자원을 공유하고 데이터를 주고 받는 방법
- 공유 메모리, 메시지 전달

### 공유 메모리
- 공유하는 메모리 영역(사용자 영역)을 토대로 데이터를 주고받는 통신 방식
- 각 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것처럼 통신한다.
- 프로세스가 공유하는 메모리 영역을 확보하는 시스템 콜을 기반으로 수행될 수도 있고, 간단하게 프로세스가 공유하는 변수나 파일을 활용할 수도 있다.

#### 장점
- 커널의 개입이 거의 없다. 
- 메모리 영역을 읽고 쓰는 것뿐이므로 메시지 전달 방식보다 통신 속도가 빠르다.

#### 단점
- 각각의 프로세스가 서로의 공유 메모리 영역을 동시에 읽고 쓸 경우, 데이터의 일관성이 훼손될 수 있다.

### 메시지 전달
- 데이터가 커널을 거쳐 송수신되는 통신 방식
- 메시지를 보내는 수단과 받는 수단이 명확하게 구분되어 있다.
- 파이프, 시그널, 소켓, 웬격 프로시저 호출 (RPC)

#### 장점
- 커널의 도움을 적극적으로 받을 수 있기 때문에 상대적으로 동기화 문제를 고려할 일이 적다.

#### 단점
- 데이터가 커널을 통해 송수신되므로 공유 메모리 기반 IPC보다 통신 속도는 느리다.

#### 파이프
![image](https://github.com/user-attachments/assets/c427a542-3fc0-49b8-bd2e-c0a83988bbe0)

- 프로세스 간의 단방향 통신 도구
- 한 쪽 방향에서 데이터를 쓰면 파이프 반대쪽으로 그 데이터를 읽을 수 있다.
- 읽기용 파이프와 쓰기용 파이프 2개를 이용해 양방향으로 통신할 수 있다.

#### 시그널
![image](https://github.com/user-attachments/assets/f268ec90-76e8-4c82-86f2-f18830d91be3)

- 이벤트가 발생했음을 알리는 비동기적인 신호
- 프로세스는 시그널이 발생하면 하던 일을 잠시 중단하고 시그널 처리를 위한 시그널 핸들러를 실행한 뒤 실행을 재개한다.
- 프로세스는 직접 특정 시그널을 발생시킬 수 있고, 직접 일부 시그널 핸들러를 정의할 수 있다.
- 시그널이 발생했을 때의 동작을 정의하여 프로세스에게 해당 시그널을 보냄으로써 프로세스 간 통신을 수행할 수 있다. 

#### 원격 프로시저 호출 (RPC)
- 다른 프로세스의 원격 코드 실행
- 언어나 플랫폼이 달라도 작동하고, 성능 저하를 최소화하면서 메시지 주고받을 수 있어서 서버 간 통신에서 많이 사용된다.

# 3. 동기화와 교착 상태
- **공유 자원** : 프로세스 혹은 스레드가 공유하는 자원
- **임계 구역** : 동시에 실행 했을 때 문제가 발생할 수 있는 코드
- **레이스 컨디션** : 프로세스 혹은 스레드가 동시에 임계 구역의 코드를 실행하여 문제가 발생하는 상황
- **동기화**
  - **실행 순서 제어** : 프로세스 및 스레드를 옯바른 순서로 실행하기
  - **상호 배제** : 동시에 접근해서는 안 되는 자원에 하나의 프로세스 및 스레드만 접근하기

## 동기화 기법
### 뮤텍스 락
- 자원에 동시 접근이 불가능하도록 상호 배제를 보장하는 동기화 도구
- 즉, 상호 배제를 위한 락

![image](https://github.com/user-attachments/assets/f7cd9fad-5c4b-432e-9dc4-9694630fd148)

- 임계 구역에 접근하고자 한다면 반드시 락을 획득해야하고, 임계 구역에서의 작업이 끝났다면 락을 해제해야 한다.

### 세마포
![image](https://github.com/user-attachments/assets/0a048124-e39e-4098-8311-25bb72e4dbeb)

- **변수 S** : 사용 가능한 공유 자원의 개수를 나타내는 변수
- **wait() 함수** : 임계 구역 진입 전 호출하는 함수
- **signal() 함수** : 임계 구역 진입 후 호출하는 함수

### 조견 변수와 모니터
#### 조건 변수
![image](https://github.com/user-attachments/assets/21bb5997-b837-49fb-9f4c-761e19d5edc8)

- 실행 순서 제어를 위한 동기화 도구로, 특정 조건 하에 프로세스를 실행/일시 중단함으로써 프로세스나 실행 순서를 제어할 수 있다.
- wait() 함수 : 프로세스 및 스레드의 상태를 대기 상태로 전환하는 함수
- signal() 함수 : wait()으로 중지된 프로세스 및 스레드의 실행을 재개하는 함수

#### 모니터
![image](https://github.com/user-attachments/assets/6d3e374f-7d15-4df5-9c2e-68fe8e9e3e5f)

- 공유 자원과 그 공유 자원을 다루는 함수(인터페이스)로 구성된 동기화 도구, 상호 배제와 실행 순서 제어를 위한 동기화가 가능하다.
- **상호 배제**
  - 프로세스 및 스레드는 공유 자원에 접근하기 위해 반드시 정해진 공유 자원 연산(인터페이스)를 통해 모니터 내로 진입해야 한다.
  - 모니터 안에 진입하여 실행되는 프로세스 및 스레드는 항상 하나여야 한다. 실행 중인 프로세스나 스레드가 있다면 큐에서 대기한다.

- **실행 순서 제어**
    - 모니터 내에서 실행되기에 앞서 먼저 실행되어야 하는 프로세스의 실행이 끝났는지 검사한다.
    - 먼저 모니터 내로 진입했을 경우, 특정 조건 변수에 대해 cv.wait()을 호출하여 대기한다.
    - 선행 프로세스의 실행 이후, cv.signal()을 호출하여 대기 상태에 있던 프로세스를 모니터 안으로 재진입시킨다.

### 스레드 안전
- 멀티스레드 환경에서 어떤 변수나 함수, 객체에 동시 접근이 이루어져도 실행에 문제가 없는 상태
  - 자바의 Vector 클래스의 add 메서드는 스레드 안전성이 보장된다.
  - 자바의 ArrayList 클래스의 add 메서드는 스레드 안전성이 보장되지 않는다.

## 교착 상태
![image](https://github.com/user-attachments/assets/387e58ce-36fa-443d-91f1-5d0b3d3f6f3e)

- 일어나지 않을 사건을 기다리며 프로세스의 진행이 멈춰 버리는 현상

### 교착 상태의 발생 조건
- 4개의 조건이 모두 만족할 때, 교착 상태가 발생할 가능성이 생긴다.
  
#### 상호 배제
- 교착 상태가 발생하는 근본적인 원인은 한 번에 하나의 프로세스만 해당 자원을 이용 가능했기 때문이다.

#### 점유와 대기
- 한 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 할당 받길 기다린다면 교착 상태가 발생할 수 있다.

#### 비선점
- 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못하는 경우 교착 상태가 발생할 수 있다.

#### 원형 대기
- 각각의 프로세스가 서로 점유한 자원을 할당받기 위해 원의 형태로 대기할 경우 교착 상태가 발생할 수 있다.

### 교착 상태의 해결 방법
#### 교착 상태 예방
- 교착 상태를 발생시키는 4가지 필요 조건 중 하나를 충족하지 못하게 하는 방법
- **점유와 대기 조건 비만족** : 한 프로세스에 필요한 자원을 몰아주고, 그 다음에 다른 프로세스에 몰아 준다.
- **원형 대기 조건 비만족** : 모든 자원에 번호를 매기고 오름차순으로 자원을 할당받도록 제한한다.

![image](https://github.com/user-attachments/assets/1586a5b5-f98b-4765-b6cc-3f830ecc932a)

#### 교착 상태 회피
- 교착 상태가 발생하지 않을 정도로만 조심하면서 자원을 할당하는 방법
- 교착 상태는 한정된 자원의 무분별한 할당으로 인해 발생한다. 모든 프로세스들이 한 번에 많은 자원을 요구한다면 교착 상태가 발생할 위험이 증가하게 된다.

#### 교착 상태 검출 후 회복
- 교착 상태를 발견하고 처리하는 사후 조치
- 주기적으로 교착 상태의 발생 여부를 검사한다.
  - 자원 선점을 통한 회복
      - 교착 상태가 해결될 때까지 다른 프로세스로부터 강제로 자원을 빼앗아 한 프로세스에 몰아서 할당한다.
  - 교착 상태에 놓인 프로세스 강제 종료
