![image](https://github.com/user-attachments/assets/2f07ba95-5084-40ef-96b6-27e0dea610c1)# 2. 프로세스와 스레드
- **포그라운드 프로세스** : 사용자가 보는 공간에서 사용자와 상호작용하며 실행되는 프로세스
- **백그라운드 프로세스** : 사용자가 보지 못하는 곳에서 실행되는 프로세스
    - **데몬** : 사용자와 별 다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스

### 사용자 영역
![image](https://github.com/user-attachments/assets/597703a2-3fd6-4d3a-9b05-f7132cf8bafd)

#### 코드 영역 (텍스트 영역)
- 실행 가능한 명령어가 저장되는 공간 (read-only)

#### 데이터 영역
- 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
- 정적 변수나 전역 변수

#### 힙 영역 
- 프로그램을 만드는 사용자가 직접 할당 가능한 저장공간
- **메모리 누수** : 메모리 공간을 반환하지 않으면 할당한 공간이 계속 메모리에 남아 메모리를 낭비한다.
- **가비지 컬렉션** : 프로그래밍 언어에서 자체적으로 사용되지 않는 힙 메모리를 해제하는 기능

#### 스택 영역
- 데이터 영역에 담기는 값과는 달리 일시적으로 사용할 값들이 저장되는 공간
- 매개변수, 지역 변수, 함수 복귀 주소
- **스택 트레이스** : 특정 시점에 스택에 저장된 함수 호출 정보

### PCB와 문맥 교환
#### 프로세스 제어 블록(PCB)
![image](https://github.com/user-attachments/assets/ba9298f4-fc49-4290-99ee-57b11f504b6c)

- 프로세스를 식별할 수 있는 커널 영역 내의 정보
- 프로세스 ID, 실행 과정에서 사용한 레지스터 값, 프로세스 상태, CPU 스케줄링 정보, 메모리 관련 정보, 파일 및 입출력장치 관련 정보 등
- 여러 PCB는 프로세스 테이블의 형태로 관리된다.

#### 문맥 교환
![image](https://github.com/user-attachments/assets/7d5ac65b-a376-4004-bb36-956b8bae6fa2)

- 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다린다.
- **문맥(Context)** : 프로세스의 수행을 재개하기 위해 기억해야 할 정보
- **문맥 교환** : 기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 새로운 프로세스를 실행하는 것

### 프로세스의 상태
![image](https://github.com/user-attachments/assets/2956d378-abdc-49e4-87f2-54f7c9ef989f)

- **생성 상태** : 프로세스를 생성 중인 상태로, 메모리에 적재되어 PCB를 할당받은 상태
- **준비 상태** : CPU를 할당받아 실행할 수 있지만, 차례가 아니기 때문에 기다리고 있는 상태
- **실행 상태** : CPU를 할당받아 실행 중인 상태
- **대기 상태** : 곧장 실행이 불가능한 조건에 놓이는 경우, 입출력 작업을 요청하는 경우가 대표적이다.
- **종료 상태** : 프로세스가 종료된 상태

## 멀티프로세스와 멀티스레드
#### 멀티프로세스
![image](https://github.com/user-attachments/assets/3419f68e-802f-4144-8fde-ff97c1893b85)

- 동시에 여러 프로세스가 실행되는 것
- 자원을 공유하지 않고, 독립적으로 실행된다.

#### 멀티스레드
![image](https://github.com/user-attachments/assets/eda6b360-37ba-40f5-9858-d755620456f9)

- 한 프로세스를 구성하는 코드를 동시에 실행하는 것
- 스레드 ID, 프로그램 카운터, 레지스터 값, 스택 등
- 여러 스레드는 코드, 데이터, 힙 영역이나 열린 파일과 같은 프로세스의 자원을 공유한다.

## 프로세스 간 통신
![image](https://github.com/user-attachments/assets/0b8566dd-9434-4802-8236-1eff073445ba)

- **프로세스 간 통신 (IPC)** : 프로세스 간 자원을 공유하고 데이터를 주고 받는 방법
- 공유 메모리, 메시지 전달

### 공유 메모리
- 공유하는 메모리 영역(사용자 영역)을 토대로 데이터를 주고받는 통신 방식
- 각 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것처럼 통신한다.
- 프로세스가 공유하는 메모리 영역을 확보하는 시스템 콜을 기반으로 수행될 수도 있고, 간단하게 프로세스가 공유하는 변수나 파일을 활용할 수도 있다.

#### 장점
- 커널의 개입이 거의 없다. 
- 메모리 영역을 읽고 쓰는 것뿐이므로 메시지 전달 방식보다 통신 속도가 빠르다.

#### 단점
- 각각의 프로세스가 서로의 공유 메모리 영역을 동시에 읽고 쓸 경우, 데이터의 일관성이 훼손될 수 있다.

### 메시지 전달
- 데이터가 커널을 거쳐 송수신되는 통신 방식
- 메시지를 보내는 수단과 받는 수단이 명확하게 구분되어 있다.
- 파이프, 시그널, 소켓, 웬격 프로시저 호출 (RPC)

#### 장점
- 커널의 도움을 적극적으로 받을 수 있기 때문에 상대적으로 동기화 문제를 고려할 일이 적다.

#### 단점
- 데이터가 커널을 통해 송수신되므로 공유 메모리 기반 IPC보다 통신 속도는 느리다.

#### 파이프
![image](https://github.com/user-attachments/assets/c427a542-3fc0-49b8-bd2e-c0a83988bbe0)

- 프로세스 간의 단방향 통신 도구
- 한 쪽 방향에서 데이터를 쓰면 파이프 반대쪽으로 그 데이터를 읽을 수 있다.
- 읽기용 파이프와 쓰기용 파이프 2개를 이용해 양방향으로 통신할 수 있다.

#### 시그널
![image](https://github.com/user-attachments/assets/f268ec90-76e8-4c82-86f2-f18830d91be3)

- 이벤트가 발생했음을 알리는 비동기적인 신호
- 프로세스는 시그널이 발생하면 하던 일을 잠시 중단하고 시그널 처리를 위한 시그널 핸들러를 실행한 뒤 실행을 재개한다.
- 프로세스는 직접 특정 시그널을 발생시킬 수 있고, 직접 일부 시그널 핸들러를 정의할 수 있다.
- 시그널이 발생했을 때의 동작을 정의하여 프로세스에게 해당 시그널을 보냄으로써 프로세스 간 통신을 수행할 수 있다. 

#### 원격 프로시저 호출 (RPC)
- 다른 프로세스의 원격 코드 실행
- 언어나 플랫폼이 달라도 작동하고, 성능 저하를 최소화하면서 메시지 주고받을 수 있어서 서버 간 통신에서 많이 사용된다.

# 3. 동기화와 교착 상태
- **공유 자원** : 프로세스 혹은 스레드가 공유하는 자원
- **임계 구역** : 동시에 실행 했을 때 문제가 발생할 수 있는 코드
- **레이스 컨디션** : 프로세스 혹은 스레드가 동시에 임계 구역의 코드를 실행하여 문제가 발생하는 상황
- **동기화**
  - **실행 순서 제어** : 프로세스 및 스레드를 옯바른 순서로 실행하기
  - **상호 배제** : 동시에 접근해서는 안 되는 자원에 하나의 프로세스 및 스레드만 접근하기

## 동기화 기법
### 뮤텍스 락
- 자원에 동시 접근이 불가능하도록 상호 배제를 보장하는 동기화 도구
- 즉, 상호 배제를 위한 락

![image](https://github.com/user-attachments/assets/f7cd9fad-5c4b-432e-9dc4-9694630fd148)

- 임계 구역에 접근하고자 한다면 반드시 락을 획득해야하고, 임계 구역에서의 작업이 끝났다면 락을 해제해야 한다.

### 세마포
![image](https://github.com/user-attachments/assets/0a048124-e39e-4098-8311-25bb72e4dbeb)

- **변수 S** : 사용 가능한 공유 자원의 개수를 나타내는 변수
- **wait() 함수** : 임계 구역 진입 전 호출하는 함수
- **signal() 함수** : 임계 구역 진입 후 호출하는 함수

### 조견 변수와 모니터
#### 조건 변수
![image](https://github.com/user-attachments/assets/21bb5997-b837-49fb-9f4c-761e19d5edc8)

- 실행 순서 제어를 위한 동기화 도구로, 특정 조건 하에 프로세스를 실행/일시 중단함으로써 프로세스나 실행 순서를 제어할 수 있다.
- wait() 함수 : 프로세스 및 스레드의 상태를 대기 상태로 전환하는 함수
- signal() 함수 : wait()으로 중지된 프로세스 및 스레드의 실행을 재개하는 함수

#### 모니터
![image](https://github.com/user-attachments/assets/6d3e374f-7d15-4df5-9c2e-68fe8e9e3e5f)

- 공유 자원과 그 공유 자원을 다루는 함수(인터페이스)로 구성된 동기화 도구, 상호 배제와 실행 순서 제어를 위한 동기화가 가능하다.
- **상호 배제**
  - 프로세스 및 스레드는 공유 자원에 접근하기 위해 반드시 정해진 공유 자원 연산(인터페이스)를 통해 모니터 내로 진입해야 한다.
  - 모니터 안에 진입하여 실행되는 프로세스 및 스레드는 항상 하나여야 한다. 실행 중인 프로세스나 스레드가 있다면 큐에서 대기한다.

- **실행 순서 제어**
    - 모니터 내에서 실행되기에 앞서 먼저 실행되어야 하는 프로세스의 실행이 끝났는지 검사한다.
    - 먼저 모니터 내로 진입했을 경우, 특정 조건 변수에 대해 cv.wait()을 호출하여 대기한다.
    - 선행 프로세스의 실행 이후, cv.signal()을 호출하여 대기 상태에 있던 프로세스를 모니터 안으로 재진입시킨다.

### 스레드 안전
- 멀티스레드 환경에서 어떤 변수나 함수, 객체에 동시 접근이 이루어져도 실행에 문제가 없는 상태
  - 자바의 Vector 클래스의 add 메서드는 스레드 안전성이 보장된다.
  - 자바의 ArrayList 클래스의 add 메서드는 스레드 안전성이 보장되지 않는다.

## 교착 상태
![image](https://github.com/user-attachments/assets/387e58ce-36fa-443d-91f1-5d0b3d3f6f3e)

- 일어나지 않을 사건을 기다리며 프로세스의 진행이 멈춰 버리는 현상

### 교착 상태의 발생 조건
- 4개의 조건이 모두 만족할 때, 교착 상태가 발생할 가능성이 생긴다.
  
#### 상호 배제
- 교착 상태가 발생하는 근본적인 원인은 한 번에 하나의 프로세스만 해당 자원을 이용 가능했기 때문이다.

#### 점유와 대기
- 한 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 할당 받길 기다린다면 교착 상태가 발생할 수 있다.

#### 비선점
- 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못하는 경우 교착 상태가 발생할 수 있다.

#### 원형 대기
- 각각의 프로세스가 서로 점유한 자원을 할당받기 위해 원의 형태로 대기할 경우 교착 상태가 발생할 수 있다.

### 교착 상태의 해결 방법
#### 교착 상태 예방
- 교착 상태를 발생시키는 4가지 필요 조건 중 하나를 충족하지 못하게 하는 방법
- **점유와 대기 조건 비만족** : 한 프로세스에 필요한 자원을 몰아주고, 그 다음에 다른 프로세스에 몰아 준다.
- **원형 대기 조건 비만족** : 모든 자원에 번호를 매기고 오름차순으로 자원을 할당받도록 제한한다.

![image](https://github.com/user-attachments/assets/1586a5b5-f98b-4765-b6cc-3f830ecc932a)

#### 교착 상태 회피
- 교착 상태가 발생하지 않을 정도로만 조심하면서 자원을 할당하는 방법
- 교착 상태는 한정된 자원의 무분별한 할당으로 인해 발생한다. 모든 프로세스들이 한 번에 많은 자원을 요구한다면 교착 상태가 발생할 위험이 증가하게 된다.

#### 교착 상태 검출 후 회복
- 교착 상태를 발견하고 처리하는 사후 조치
- 주기적으로 교착 상태의 발생 여부를 검사한다.
  - 자원 선점을 통한 회복
      - 교착 상태가 해결될 때까지 다른 프로세스로부터 강제로 자원을 빼앗아 한 프로세스에 몰아서 할당한다.
  - 교착 상태에 놓인 프로세스 강제 종료

# 4. CPU 스케줄링
- 운영체제의 CPU 배분 방법
- **CPU 스케줄링 알고리즘** : CPU 스케줄링 절차
- **CPU 스커줄러** : CPU 스케줄링 알고리즘을 결정하고 수행하는 운영체제의 일부분

### 우선순위
- 운영체제는 프로세스별 우선순위를 판단하여 PCB에 명시하고, 우선순위가 높은 프로세스에는 CPU의 자원을 더 빨리, 더 많이 할당한다.
- **CPU 활용률** : 전체 CPU의 가동 시간 중 작업을 처리하는 시간의 비율
- 운영체제는 높은 CPU 활용률을 유지하기 위해 기본적으로 입출력 작업이 많은 프로세스의 우선순위를 높게 유지한다.

#### CPU 집중 프로세스와 입출력 집중 프로세스
![image](https://github.com/user-attachments/assets/7931271c-3bdb-41a9-b2ac-78eff64c9d03)

- **CPU 버스트** : 프로세스가 CPU를 이용하는 작업
- **입출력 버스트** : 입출력 작업을 기다리는 작업
- **CPU 집중 프로세스** : 복잡한 수학 연산이나 그래픽 처리 작업을 담당하는 프로세스 처럼 CPU 작업이 많은 프로세스로, 실행 상태에 더 머무른다.
- **입출력 집중 프로세스** : 비디오 재생이나 디스크 백업 작업을 담당하는 프로세스처럼 입출력 작업이 많은 프로세스로, 대기 상태에 더 머무른다.

#### 입출력 집중 프로세스가 CPU 집중 프로세스보다 우선순위가 높은 이유
- 입출력 집중 프로세스를 가능한 빨리 실행시켜 끊임없이 입출력장치를 작동시킨 다음, CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 합리적이다.
- CPU 집중 프로세스의 우선순위가 더 높을 때를 상상해보자.

### 스케줄링 큐
![image](https://github.com/user-attachments/assets/1fc54291-571c-4ce3-9dcf-c169663a1ac4)

- 특정 자원을 이용하고 싶은 프로세스의 PCB를 큐에 삽입하여 줄을 세운다.
- **준비 큐** : CPU를 이용하고 싶은 프로세스의 PCB가 서는 줄
- **대기 큐** : 대기 상태에 접어든 프로세스의 PCB가 서는 줄

![image](https://github.com/user-attachments/assets/4e9bf695-6bda-4e1f-904f-7b98a39d69cc)

### 선점형 스케줄링과 비선점형 스케줄링
#### 선점형 스케줄링
- 현재 어떤 프로세스가 CPU를 할당받아 사용하고 있더라도 운영체제가 프로세스로부터 CPU 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식
- **장점** : 한 프로세스의 CPU 독접을 막고 여러 프로세스에 골고루 CPU 자원을 배분할 수 있다.
- **단점** : 컨텍스트 스위칭 과정에서 오버헤드가 발생할 수 있다.

#### 비선점형 스케줄링
- 어떤 프로세스가 CPU를 사용하고 있을 떄 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지는 다른 프로세스가 끼어들 수 없는 스케줄링 방식
- **장점** : 컨텍스트 스위칭 횟수가 적기 때문에 상대적으로 오버헤드의 발생은 적다.
- **단점** : 어떤 프로세스가 CPU를 사용 중이라면 당장 CPU를 사용해야 하는 프로세스라도 무작정 기다려야 한다.

## CPU 스케줄링 알고리즘
- 운영체제가 CPU를 배분하는 방법

### 1. 선입 선처리 스케줄링
![image](https://github.com/user-attachments/assets/7ae1e065-657e-4e40-99c4-2841e7c46ec7)

- 단순히 준비 큐에 삽입된 순서대로 먼저 CPU를 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식
- **호위 효과** : 먼저 삽입된 프로세스의 오랜 실행시간으로 인해 나중에 삽입된 프로세스의 실행이 지연되는 문제 

### 2. 최단 작업 우선 스케줄링
- 준비 큐에 삽입된 프로세스 중 CPU를 이용하는 시간이 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식

### 3. 라운드 로빈 스케줄링
- 큐에 삽입된 프로세스들이 삽입된 순서대로 CPU를 이용하되, 정해진 타임 슬라이스만큼만 CPU를 이용하는 선점형 스케줄링
- **타임 슬라이스** : 프로세스가 CPU를 사용하도록 정해진 시간

### 4. 최소 잔여 시간 우선 스케줄링
- 프로세스로 하여금 정해진 타임 슬라이스만큼 CPU를 이용하되, 남아 있는 작업시간이 가장 적은 프로세스를 다음으로 CPU를 이용할 프로세스로 선택한다.

### 5. 우선순위 스케줄링
- 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식
- **아사 현상** : 우선 순위가 낮은 프로세스는 우선순위가 높은 프로세스로 인해 계속해서 실행이 연기될 수 있다.
- **에이징** : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
 
### 6. 다단계 큐 스케줄링
![image](https://github.com/user-attachments/assets/c60147e1-d90a-41eb-9017-12a21aac654e)

- 우선순위 스케줄링의 발전된 형태로, 우선순위별로 여러 개의 준비 큐를 사용하는 스케줄링 방식
- 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리하고, 우선순위가 가장 높은 큐가 비어있게 되면, 그 다음으로 우선순위가 높은 큐에 있는 프로세스를 처리한다.
- 프로세스들이 큐 사이를 이동할 수 없기 때문에 우선순위가 낮은 프로세스의 작업이 계속해서 연기될 수 있다.

### 7. 다단계 피드백 큐 스케줄링
![image](https://github.com/user-attachments/assets/e7d11424-463c-4c99-a5d8-24805631c410)

- 다단계 큐 스케줄링과 비슷하게 동작하지만, 프로세스들이 큐 사이를 이동할 수 있다.
- 새롭게 진입하는 프로세스는 먼저 우선순위가 가장 높은 우선순위 큐에 삽입되고, 해당 큐에서 프로세스의 실행이 끝나지 않으면 다음 우선순위 큐에 삽입되어 실행된다.
- 자연스럽게 CPU를 오래 사용해야하는 CPU 집중 프로세스들의 우선순위는 낮아지고, 입출력 집중 프로세스들은 우선순위가 높은 큐에서 실행이 끝난다.
- 아사 현상을 예방하기 위해 낮은 우선순위 큐에서 오래 기다리고 있는 프로세스들을 높은 우선순위 큐로 이동시키는 에이징 기법을 적용할 수 있다.

## 리눅스 CPU 스케줄링
- **스케줄링 정책** : 새로운 프로세스를 언제 어떻게 선택하여 실행할 지르 ㄹ결정하기 위한 규칙의 집합

![image](https://github.com/user-attachments/assets/0608a0ec-8525-4873-8a0a-3775bfb4c01a)

### SCHED_FIFO, SCHED_RR
- RT 스케줄러에 의해 이뤄지는 스케줄링
- 실시간성이 강조된 프로세스에 적용되는 스케줄링 정책

### SCHED_NORMAL
- CFS에 의해 이뤄지는 스케줄링
#### CFS
- 완전히 공평한 CPU 시간 배분을 지향하는 CPU 스케줄러
- CFS는 vruntime이 가장 작은 프로세스부터 스케줄링한다.

#### vruntime
![image](https://github.com/user-attachments/assets/b2f3caba-7b67-4152-b568-857d4e38bba8)

- 프로세스의 가중치를 고려한 가상의 실행 시간
- 우선순위가 높을수록, 즉 프로세스의 가중치가 높을수록 먼저 스케줄링될 확률이 높아진다.

#### 타임 슬라이스
![image](https://github.com/user-attachments/assets/3c7a6b80-782e-4a5c-9033-d7002e584f99)

- CFS로 스케줄링되는 프로세스들의 타임 슬라이스는 프로세스의 가중치에 따라 결정된다.
- 우선순위가 높을수록, 즉 프로세스의 가중치가 높을수록 타임 슬라이스를 크게 할당받을 수 있다.

# 5. 가상 메모리
## 물리 주소와 논리 주소
![image](https://github.com/user-attachments/assets/443f9fa6-fa5f-441b-9522-d7e14f8becbd)


- **물리 주소** : 하드웨어 상 실제 주소
- **논리 주소** : 프로세스마다 부여되는 0번지부터 시작하는 주소 체계

#### MMU
![image](https://github.com/user-attachments/assets/dee542cd-fe7f-4495-ada8-1745cefc6853)

- CPU와 메모리 사이에 위치하며, CPU가 이해하느 논리 주소를 메모리가 이해하는 물리 주소로 면환하는 역할을 한다.

## 스와핑과 연속 메모리 할당
### 스와핑
- 오랫동안 사용되지 않은 프로세스를 임시로 스왑 영역이라는 보조기억장치의 일부인 영역으로 쫓아내고, 쫓아낸 자리에 생긴 빈 공간에 다른 프로세스를 적재하여 실행하는 메모리 관리 방식

#### 스왑 아웃과 스왑 인
![image](https://github.com/user-attachments/assets/b97cbb5f-343a-46b0-a332-7e6f55b905c0)

- 스왑 아웃 : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인 : 스왑 영역에 있는 프로세스가 다시 메모리로 옮겨오는 것

### 연속 메모리 할당과 외부 단편화
#### 연속 메모리 할당
![image](https://github.com/user-attachments/assets/8ab693c5-4cb1-4a16-aedd-5c06dd57b505)

- 프로세스에 연속적인 메모리 공간을 할당하는 방식

#### 외부 단편화
![image](https://github.com/user-attachments/assets/aee2aeb3-9d55-49f8-bf15-140fa109f608)

- 프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스의 실행과 종료를 반복하며 메모리 사이사이에 빈 공간이 생긴다.
- 빈 공간의 총합이 프로세스의 크기보다 크더라도 각 공간이 프로세스의 크기보다 작다면 적재되지 못하고 메모리 낭비로 이어진다.

## 페이징을 통한 가상 메모리 관리
- 스와핑과 연속 메모리 할당만 사용할 경우, 메모리보다 큰 프로그램은 적재할 수 없다.

#### 가상 메모리
- 실행하고자 하는 프로그램의 일부만 메모리에 적재해, 실제 메모리보다 더 큰 프로세스를 실행할 수 있도록 만드는 메모리 관리 기법
- 보조기억장치의 일부를 메모리처럼 사용하거나 프로세스의 일부만 메모리에 적재함으로써 메모리를 실제 크기보다 더 크게 보이게 하는 기술
- **가상 메모리 관리 기법** : 페이징, 세그멘테이션 등

### 페이징
![image](https://github.com/user-attachments/assets/cf60b1f3-a8f2-4a73-bc58-8ea8bf8682b4)

- 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 나누고, 무리 주소 공간을 페이지와 동일한 크기의 프레임이라는 일정한 단위로 나눈 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 프로세스를 구성하는 페이지는 물리 메모리 내에 불연속적으로 배치될 수 있기 때문에 외부 단편화가 발생하지 않는다.

#### 페이징 기법에서의 스와핑
![image](https://github.com/user-attachments/assets/616d90ec-b88e-42db-a763-8afceb34f10b)

- **페이지 아웃** : 페이지 단위로 스왑 아웃
- **페이지 인** : 페이지 단위로 스왑 인
- 프로세스를 실행하기 위해 전체 프로세스가 메모리에 적재될 필요는 없으며, CPU 입장에서 바라본 논리 메모리의 크기가 실제 메모리보다 클 수 있다.

### 페이지 테이블
![image](https://github.com/user-attachments/assets/9b463c17-fc24-4abe-b03c-9743a65884c2)

- **페이지 테이블** : 프로세스의 페이지와 실제로 적재된 프레임을 짝지어 주는 정보
- 프로세스마다 페이지 테이블이 할당된다.

#### 테이블 엔트리
![image](https://github.com/user-attachments/assets/07b766f2-f029-482e-8824-eda896c8950e)

- 페이지 테이블을 구성하고 있는 각각의 행
- **유효 비트**
  - 해당 페이지가 메모리에 적재되어있다면 1, 페이지가 메모리에 적재되어 있지 않다면 0
  - 유효 비트가 0인 페이지에 접근하려고 하면 페이지 폴드라는 예외가 발생한다.
  - 페이지 폴트 처리과정
  - ![image](https://github.com/user-attachments/assets/2988562b-4299-4076-98f2-3dcddfdbc709)
- **보호 비트**
  - rwx 조합으로 페이지에 접근할 권한을 제한함으로써 페이지를 보호할 수 있다.
- **참조 비트**
  - 페이지에 적재한 이후에 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 설정되고, 한 번도 읽거나 쓴 적이 없는 페이지는 0으로 유지된다. 
- **수정 비트(더티 비트)**
  - 수정 비트가 1이면 변경된 적이 있는 페이지이고, 0이면 변경된 적이 없는 페이지이다.
  - 한 번이라도 페이지에 쓰기 작업을 한 경우에는 페이지를 메모리에서 삭제할 때 페이지의 수정 내역을 보조기억 장치에도 반영해야 한다.
 
#### 내부 단편화
![image](https://github.com/user-attachments/assets/e7441c75-3374-4c1b-8e91-8c820e3aaf84)

- 모든 프로세스가 페이지 크기에 딱 맞게 잘리지 않으므로, 페이지 하나의 크기보다 작은 크기로 메모리 낭비가 발생한다.

#### 페이지 테이블의 위치
- **페이지 테이블 베이스 레지스터(PTBR)**
  - 특정 프로세스의 페이지 테이블이 적재된 메모리 상의 위치를 가리키는 특별한 레지스터

- **메모리 접근 횟수**
  - 모든 프로세스의 페이지 테이블이 메모리에 적재되어 있을 경우, CPU는 페이지 테이블에 접근하기 위해 한 번, 실제 프레임에 접근하기 위해 한 번, 총 두 번 메모리에 접근해야 한다.
  - **TLB**
    - ![image](https://github.com/user-attachments/assets/58be60c5-d148-4322-8692-d4d54eda68c3) 
    - 페이지 테이블의 캐시 메모리
    - 참조 지역성 원리에 근거해 자주 사용할 법한 페이지 위주로 페이지 테이블의 일부 내용을 저장한다.
    - **TLB 히트** : CPU가 접근하려는 논리 주소의 페이지 번호가 TLB에 있는 경우
    - **TLB 미스** : 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근해야 하는 경우

- **메모리 용량**
  - 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비이다.
  - **계층적 페이징(다단계 페이지 테이블)** : 페이지 테이블을 페이징 하는 방식
    - ![image](https://github.com/user-attachments/assets/0e267ade-263c-4513-b5df-0e4b027af784)
    - Outer 페이지 테이블만 메모리에 유지하면 잘린 페이지 테이블의 일부가 보조기억장치에 있더라도 접근할 수 있다.


### 페이징 주소 체계
![image](https://github.com/user-attachments/assets/a44fd760-fbf6-48f3-a538-219fc34c3c1d)

- <페이지 번호, 변위>로 이루어진 논리 주소는 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위>로 변환된다.
- **페이지 번호** : 몇 번째 페이지 번호에 접근할지를 나타낸다.
- **변위** : 접근하려는 주소가 페이지(프레임) 시작 번지로부터 얼만큼 떨어져 있는지를 나타내는 정보

## 페이지 교체 알고리즘
- **요구 페이징** : 처음부터 모든 페이지를 적재하지 않고, 메모리에 필요한 페이지만 적재하는 기법
  - 요구 페이징의 기본적인 양상
  - ![image](https://github.com/user-attachments/assets/604b81ec-960e-4171-b578-820ced73a5bd) 
- **순수 요구 페이징** : 아무런 페이지도 메모리에 적재하지 않은 채 무작정 프로세스를 실행하는 기법

### 페이지 교체 알고리즘
- 메모리에 적재된 페이지 중 보조기억장치로 내보낼 페이지를 선택하는 방법

#### FIFO 페이지 교체 알고리즘
- 메모리에 가장 먼저 적재된 페이지부터 스왑 아웃하는 페이지 교체 알고리즘

#### 최적 페이지 교체 알고리즘
- 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
- 앞으로 가장 적게 사용할 페이지를 미리 예측하기가 어렵기 때문에 실제 구현이 어려운 알고리즘이다.

#### LRU 페이지 교체 알고리즘
- 가장 적게 사용한 페이지를 교체하는 알고리즘
- 보편적으로 사용되는 페이지 교체 알고리즘

Q. 가장 오랫동안 사용되지 않은 페이지를 우선적으로 제거하는 알고리즘이 맞지 않나?
