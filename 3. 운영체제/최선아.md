# 2. 프로세스와 스레드

- 메모리에는 컴퓨터가 실행되는 순간 다양한 프로세스들이 적재되어 실행됨

## 프로세스의 유형

- 프그라운드 프로세스: 사용자가 보는 공간에서 사용자와 상호작용하며 실행되는 프로세스
- 백그라운드 프로세스:사용자가 보지 못하는 곳에서 실행되는 프로세스
  - 데몬(서비스): 사용자와 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스

## 메모리 정보

![Image](https://github.com/user-attachments/assets/b6352048-f7cd-4a03-b4e3-bd2dfaa8406c)

- 프로세스 유형을 막론하고 하나의 프로세스를 구성하는 메모리 내의 정보는 크게 다르지 않음
- 커널 영역: 프로세스 제어 블록(PCB) 정보가 저장
- 사용자 영역: 코드 영역, 데이터 영역, 힙 영역, 스택 영역 저장

### 1. 코드 영역

- 실행 가능한 명령어가 저장되는 공간
- 텍스트 영역이라고도 부름
- 쓰기 금지 공간(read-only)
- 정적 할당 영역: 프로그램 실행 도중 크기가 변하지 않음

### 2. 데이터 영역

- 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
- 정적 변수, 전역 변수가 저장됨
- BSS: 초기값이 있는 데이터는 데이터 영역에 저장, 초기값이 없는 데이터는 BSS 영역에 저장됨
- 정적 할당 영역: 프로그램 실행 도중 크기가 변하지 않음

### 3. 힙 영역

- 프로그램을 만드는 사용자(개발자)가 직접 할당 가능한 저장 공간
- 프로그램 실행 도중 비교적 자유롭게 할당하여 사용 가능한 메모리 공간
- 메모리 공간을 할당한 후 반환하지 않으면 메모리 낭비인 메모리 누수 문제 초래
- 가비지 컬렉션: 프로그래밍 언어에서 자체적으로 메모리를 해제하는 기능을 제공하기도 함

### 4. 스택 영역

- 일시적으로 사용할 값들이 저장되는 공간
- 함수의 실행이 끝나면 사라지는 매개변수, 지역변수, 함수 복귀 주소 등이 저장됨
- 스택 트레이스: 특정 시점에 스택 영역에 저장된 함수 호출 정보가 저장됨
  - 문제의 발생 지점을 추적할 수 있어, 디버깅에 유용함
    ![Image](https://github.com/user-attachments/assets/8ead8b0b-66b3-4d37-94fd-7b84f768b813)

## PCB와 문맥 교환

### PCB란

- PCB(Process Control Block): 운영체제가 메모리에 적재된 다수의 프로세스를 관리하기 위한, 프로세스를 식별할 수 있는 커널 영역 내의 정보
- 프로세스와 관련한 다양한 정보를 내포하는 구초제로, 새로운 프로세스가 메모리에 적재됐을 때 커널 영역에 만들어지고, 프로세스의 실행이 끝나면 폐기됨
- PCB에 담기는 정보
  - PID: 프로세스 식별 번호
  - 프로세스가 실행과정에서 사용한 레지스터 값
  - 프로세스 상태
  - CPU 스케줄링 정보: 어떤 순서로 CPU를 할당받을지
  - 메모리 관련 정보: 프로세스의 메모리상 적재 위치
  - 프로세스가 사용한 파일 및 입출력장치 관련 정보
- 예시(리눅스 운영체제의 PCB인 task_struct 구조체)
  ![Image](https://github.com/user-attachments/assets/02362b8d-1d11-41b3-9dfc-fdd459a25f42)

### 프로세스 테이블

![Image](https://github.com/user-attachments/assets/1835f447-879f-452f-8c04-18f584eb4b49)

- 프로세스 테이블: 여러 PCB들이 관리되는 형태, 실행중인 PCB들의 모음
- 새롭게 실행되는 프로세스가 있으면 해당 프로세스의 PCB를 프로세스 테이블에 추가하고, 필요한 자원을 할당함
- 종료되는 프로세스가 있다면 사용중이던 자원을 해제하고 PCB에도 프로세스 테이블에서 삭제됨
- 좀비 프로세스: 프로세스가 비정상 종료되어 사용한 자원이 회수되었음에도 프로세스 테이블에 종료된 프로세스의 PCB가 남아있는 프로세스

### 문맥

- 메모리에 적재된 프로세스들은 한정된 시간 동안 번갈아 가며 실행됨
- 프로세스가 실행된다: 운영체제에 의해 CPU의 자원을 할당받았다는 뜻
- 프로세스의 CPU 사용 시간은 타이머 인터럽트에 의해 제한됨
  - 타이머 인터럽트(타임아웃 인터럽트): 시간이 끝났음을 알림
- 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다림
- 다시 차례가 왔을 때 이전까지 실행했던 내용을 이어서 재개하기 위해 프로그램 카운터, 레지스터 값, 메모리 정보 등 지금까지의 중간 정보를 **백업**해야함
- 문맥: 프로세스의 수행을 재개하기 위해 기억해야 할 정보

### 문맥 교환

![Image](https://github.com/user-attachments/assets/48a1ccf5-c062-4d49-b106-a78536d1fa0f)

- 프로세스가 CPU를 사용할 수 있는 시간이 다 되거나 인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB에 문맥을 백업하고 뒤이어 실행할 프로세스의 문맥을 복구함
- 문맥 교환: 기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 새로운 프로세스를 실행하는 것
- 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리
- 프로세스 간에 너무 잦은 문맥 교환이 발생하면 캐시 미스가 발생할 가능성이 높아져 메모리에 접근할 일이 많아지고, 이는 큰 오버헤드로 이어질 수 있음

## 프로세스의 상태

![Image](https://github.com/user-attachments/assets/6827641c-5b12-46d3-b0ff-f854743e2687)

- 하나의 프로세스는 여러 상태를 거치며 실행됨
- 운영체제는 PCB를 통해 프로세스의 상태를 인식하고 관리함
- 대표적인 상태: 생성, 준비, 실행, 대기, 종료

### 생성 상태

- 프로세스를 생성 중인 상태로, 메모리에 적재되어 PCB를 할당받은 상태
- 생성 상태를 거쳐 실행할 준비가 완료된 프로세스는 준비 상태가 되어 CPU의 할당을 기다림

### 준비 상태

- CPU를 할당받아 실행할 수 있지만, 자신의 차례가 아니기 때문에 기다리고 있는 상태
- 준비 상태인 프로세스가 CPU를 할당받으면 실행 상태가 되며, 준비 상태인 프로세스가 실행 상태로 전환되는 것을 디스패치(dispatch) 라고 함

### 실행 상태

- CPU를 할당받아 실행중인 상태
- 일정 시간동안만 CPU를 사용할 수 있음
- 타이머 인터럽트가 발생하여 프로세스가 할당된 시간을 모두 사용하면 다시 준비 상태가 됨
- 실행 도중 입출력장치를 사용하여 입출력장치의 작업이 끝날 때까지 기다려야 하면 대기 상태가 됨

### 대기 상태

- 프로세스가 입출력 작업을 요청하거나 바로 확보할 수 없는 자원을 요청하는 등 곧장 실행이 불가능한 조건에 놓이는 경우 대기 상태가 됨
- 입출력 작업을 요청하는 경우가 대표적임
- 대기 상태였던 해당 프로세스는 입출력 작업이 완료되는 등 실행 가능한 상태가 되면 다시 준비 상태가 되어 CPU 할당을 기다림

### 종료 상태

- 프로세스가 종료된 상태
- 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리함

## 멀티프로세스와 멀티스레드

### 멀티프로세스

- 동시에 여러 프로세스가 실행되는 것
- 각기 다른 프로세스들이 기본적으로 자원을 공유하지 않고, 독립적으로 실행됨 -> 한 프로세스의 실행 과정에서 문제 발생하더라도 다른 프로세스에 영향 x

### 멀티스레드

![Image](https://github.com/user-attachments/assets/3540e9a4-5647-430e-b78e-a7209eb1e735)

- 프로세스를 동시에 실행하는 여러 스레드
- 하나의 스레드는 스레드를 식별할 수 있는 고유 정보인 스레드 ID, 프로그램 카운터, 레지스터 값, 스택 등으로 구성됨
- 스레드마다 각각의 프로그램 카운터 값과 스택을 가지고 있기 때문에 스레드마다 다음에 실행할 주소를 가질 수 있고, 연산 과정의 임시 저장 값을 가질 수 있음

### 멀티프로세스 vs 멀티스레드

- 가장 큰 차이점은 자원의 공유 여부임
- 서로 다른 프로세스들은 기본적으로 자원을 공유하지 않기 때문에 독립적으로 실행됨 -> 한 프로세스에 문제 생겨도 다른 프로세스에 지정 없거나 적음
- 같은 프로세스를 실행하는 여러 스레드들은 프로세스의 자원을 공유함 -> 한 스레드에 생긴 문제가 프로세스 전체의 문제가 될 수 있음
  - 코드/데이터/힙 영역, 열린 파일 등을 공유하기 때문에 쉽게 협력하고 통신할 수 있음

## 프로세스 간 통신

![Image](https://github.com/user-attachments/assets/a750779f-2fcc-43fb-a006-1d412df515cd)

- IPC(Inter-Process Communication): 프로세스 간에도 자원을 공유하고 데이터를 주고 받을 수 있는 방법
- 프로세스 간 통신이 이루어지는 방식: 공유 메모리, 메시지 전달

### 공유 메모리

- 데이터를 주고받는 프로세스가 공통적으로 사용할 메모리 영역을 두는 방식
- 공유 메모리라는 특별한 메모리 공간을 할당하여 프로세스가 해당 메모리 공간을 공유하여 읽고 쓸 수 있도록 함
- 공유 메모리 영역을 확보하는 시스템 콜을 기반으로 수행될 수도 있고, 간단하게 프로세스가 공유하는 변수나 파일을 활용할 수도 있음
- 각 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것처럼 통신함
- 프로세스가 주고받는 데이터가 커널 영역을 거치지 않는 경우가 많음
- 각 프로세스가 단순히 각자의 메모리 영역을 읽고 쓰는 것일 뿐이므로 메시지 전달 방식보다 통신 속도가 빠름
- 레이스 컨디션: 메모리 영역을 동시에 읽고 쓸 경우, 데이터의 일관성이 훼손될 수 있음

### 메시지 전달

- 프로세스 간에 주고받을 데이터를 커널을 거쳐 메시지의 형태로 주고받는 방식
- 메시지를 보내고 받는 시스템콜이 명확하게 정해져있음
  - send(): 메시지를 보내는 시스템 콜
  - recv(): 메시지를 받는 시스템 콜
- 커널의 도움을 받으므로 레이스 컨디션, 동기화 등의 문제를 고려하는 일이 상대적으로 적음
- 데이터가 커널을 통해 송수신 되므로 공유 메모리 기반보다 통신 속도가 느림
- 대표적인 수단: 파이프, 시그널, 소켓, 원격 프로시저 호출(RPC) 등이 있음

> RPC가 뭐지

#### 파이프

![Image](https://github.com/user-attachments/assets/b4d1d7ae-4be7-4ffb-b58f-c65e713088fe)

- 단방향 프로세스 간의 통신 도구
- 양방향 통신을 수행할 경우, 읽기용 파이프와 쓰기용 파이프 2개 필요
- 익명 파이프: 양방향 통신을 지원하지 않고, 부모 프로세스와 자식 프로세스 간에만 통신 가능
- 지명 파이프: 양방향 통신을 지원하며, 임의의 프로세스 간에도 통신 가능

#### 시그널

![Image](https://github.com/user-attachments/assets/1dbd172c-b26c-4766-868c-21621ff96cdf)

- 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기적 신호
- 시그널 자체는 IPC만을 위한 개념이 아니라 '시그널을 적절히 활용해 IPC를 수행할 수 있다' 임
- 리눅스 운영체제의 대표적인 시그널 예시
  - 대부분 인터럽트 관련 시그널이지만, 사용자 정의 시그널도 가능
    | 시그널 | 설명 | 기본 동작 |
    |-------|------|---------|
    | SIGCHLD | 자식 프로세스 종료 | 무시 |
    | SIGILL | 허용하지 않은 명령어 실행 | 코어 덤프 생성 후 종료 |
    | SIGINT | 키보드 인터럽트(Ctrl + C) | 종료 |
    | SIGKILL | 프로세스 종료(핸들러 재정의 불가능) | 종료 |
    | SIGSEGV | 잘못된 메모리 접근 | 코어 덤프 생성 후 종료 |
    | SIGTERM | 프로세스 종료(핸들러 재정의 가능) | 종료 |
    | SIGUSR1 | 사용자 정의 시그널 | 종료 |
    | SIGUSR2 | | 종료 |
- 프로세스는 시그널이 발생하면 인터럽트 처리 과정과 유사하게 하던일을 잠시 중단하고, 시그널 처리를 위한 **시그널 핸들러**를 실행한 뒤 실행을 재개함
- 프로세스는 직접 특정 시그널을 발생시킬 수 있고, 일부 시그널 핸들러를 (재)정의 할 수도 있음
- 시그널을 이용하는 방법은 직접적으로 메시지를 주고받지는 않지만, 비동기적으로 원하는 동작을 수행할 수 있는 좋은 수단임
- 코어 덤프: 주로 비정상적으로 종료하는 경우에 생성되는 파일로, 프로그램이 특정 시점에 작업하던 메모리 상태가 기록됨

  ```
  $ coredumpctl info
  PID: 7990 (python3)
  UID: 1000 (minchu1)
  GID: 1000 (minchu1)
  Signal: 11 (SEGV)
  Timestamp: Mon 2024-02-26 15:40:36 KST (1min 1s ago)
  Command Line: python3 coredumped.py
  Executable: /usr/bin/python3.8
  Control Group: /user.slice/user-1000.slice/session-33.scope
  Unit: session-33.scope
  Slice: user-1000.slice
  Session: 33
  Owner UID: 1000 (minchu1)
  Boot ID: abcdeabcde1234512345abcde12345ab
  Machine ID: abcde12345abcde12345abcde12345ab
  Hostname: homeserver
  Storage: /var/lib/systemd/coredump/core.python3.1000.abcdeabc...2345000000000000.123
  Message: Process 7990 (python3) of user 1000 dumped core.
    Stack trace of thread 7990:
    #0 0x00007f220dcb3f45 n/a (\_ctypes.cpython-38-x86_64-linux-gnu.so + 0x9f45)
    #1 0x00007f220e8efff5 n/a (libffi.so.7 + 0x6ff5)
    #2 0x00007f220e8ef40a n/a (libffi.so.7 + 0x640a)
    ...
    #15 0x0000000000673abb n/a (python3.8 + 0x273abb)
    #16 0x0000000000673b61 n/a (python3.8 + 0x273b61)
    #17 0x00000000006747e7 PyRun_SimpleFileExFlags (python3.8 + 0x2747e7)
    #18 0x000000000006b4072 Py_RunMain (python3.8 + 0x2b4072)
    #19 0x000000000006b43fd Py_BytesMain (python3.8 + 0x2b43fd)
    #20 0x00007f220e717083 \_\_libc_start_main (libc.so.6 + 0x24083)
    #21 0x000000000005da67e \_start (python3.8 + 0x1da67e)
  ```

> 재정의 가능/불가능한 시그널에는 뭐가 있을까?
> 특정 프로세스로 시그널을 어떻게 보낼 수 있는걸까?

#### 이 외의 방법들

- 이외에도 원격 프로시저 호출(RPC)나 네트워크 소켓을 통해 IPC를 수행할 수도 있음

**RPC**

- 원격 코드를 실행하는 IPC 기술
- 한 프로세스 내의 특정 코드 실행이 로컬 프로시저 호출이라면, 다른 프로세스의 원격 코드 실행이 원격 프로시저 호출인 셈
- RPC를 통해 프로그래밍 언어나 플랫폼과 무관하게 성능 저하를 최소화하고, 메시지 송수신이 가능하기 때문에 대규모 트래픽 처리 환경, 특히 서버 간 통신 환경에서 사용되는 경우가 많음

> RPC 자체가 뭔지 잘 이해가 안감
