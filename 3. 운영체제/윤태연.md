# 2절. 프로세스와 스레드

## 프로세스의 유형 및 구성

> [!NOTE]
> 컴퓨터가 실행되는 순간부터 메모리에 적재돼 실행되는 **프로그램의 인스턴스**
> 각 프로그램마다 **독립적인 실행 단위**

### 프로세스 유형

<img width="600" alt="image" src="https://github.com/user-attachments/assets/b5db6f03-f047-4892-ab53-02e2f8f483c6" />

- **포그라운드 프로세스**: 사용자가 보는 공간에서 상호작용하며 실행되는 프로세스
- **백그라운드 프로세스**: 사용자가 보지 못하는 곳에서 실행되는 프로세스
- **데몬**: 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스(윈도우에서는 서비스)

### 사용자 영역 구성

- **코드 영역(텍스트 영역)**: 실행 가능한 명령어가 저장되는 읽기 전용 공간
- **데이터 영역**: 프로그램 실행 동안 유지할 정적 변수나 전역 변수가 저장되는 공간
- **힙 영역**: **사용자가 직접 할당 가능**한 저장 공간, 메모리 누수 위험성 존재
  - 프로그램 실행 도중 비교적 자유롭게 할당해 사용 가능한 메모리 공간
  - 메모리 공간을 반환하지 않으면 **메모리 누수**(memory leak) 문제 발생
  - 일부 언어는 **가비지 컬렉션**(garbage collection) 기능으로 자동 메모리 관리
- **스택 영역**: **일시적 사용 값**(매개변수, 지역 변수, 함수 복귀 주소 등) 저장 공간
  - 스택 트레이스(stack trace): 특정 시점에 스택 영역에 저장된 함수 호출 정보로 디버깅에 유용

코드 영역과 데이터 영역은 크기가 변하지 않는 정적 할당 영역인 반면, 힙 영역과 스택 영역은 크기가 변할 수 있는 동적 할당 영역.

> [!TIP]
> BSS 영역은 데이터 영역과 유사하지만 초기화 여부에 차이가 있음
> **초깃값이 있는 정적/전역 변수는 데이터 영역**에, **초깃값이 없는 데이터는 BSS 영역**에 저장

## PCB와 문맥 교환

### PCB(프로세스 제어 블록)

> [!NOTE]
> 프로세스를 식별할 수 있는 커널 영역 내 정보 구조체
> 새 프로세스가 메모리에 적재될 때 생성되고, 프로세스 종료 시 폐기됨

| PCB 구성 요소            | 설명                                     |
| ------------------------ | ---------------------------------------- |
| **프로세스 식별자**(PID) | 각 프로세스를 구분하는 고유 ID           |
| **프로세스 상태**        | 생성, 준비, 실행, 대기, 종료 중 하나     |
| **프로그램 카운터**(PC)  | 다음에 실행할 명령어의 위치              |
| **CPU 레지스터**         | 프로세스가 CPU를 사용할 때의 레지스터 값 |
| **CPU 스케줄링 정보**    | 우선순위, 스케줄링 큐 포인터 등          |
| **메모리 관리 정보**     | 기준 레지스터, 한계 레지스터 값 등       |
| **입출력 상태 정보**     | 프로세스에 할당된 입출력 장치 목록       |
| **계정 정보**            | CPU 사용 시간, 계정 번호 등              |

- 여러 PCB들은 커널 내에 프로세스 테이블 형태로 관리됨
- 좀비 프로세스(zombie process): 비정상 종료돼 자원은 회수됐으나 PCB가 테이블에 남아있는 상태

> [!TIP]
> 구조체(struct)란 서로 다른 자료형으로 이루어진 데이터를 하나로 묶어 활용할 수 있도록 하는 복합 자료형의 일종
> PCB는 이러한 구조체 형태로 구현, 리눅스에서는 `task_struct`라는 이름으로 구현

### 문맥 교환

<img width="600" alt="image" src="https://github.com/user-attachments/assets/f931028b-40d8-4030-bfc6-11b878238547" />

- **문맥**: 프로세스 수행 재개를 위해 기억해야 할 정보(프로그램 카운터, 레지스터 값, 메모리 정보 등)
- **문맥 교환**: 기존 프로세스의 문맥을 PCB에 백업하고, 새 프로세스의 문맥을 복구하는 과정
- **타이머 인터럽트**(timer interrupt)가 발생하면 CPU 사용 양보 후 다음 차례 대기
- 문맥 교환이 너무 잦으면 **캐시 미스** 발생 가능성 증가로 **성능 저하** 발생

#### 문맥 교환 과정 상세 설명

- **작동 원리**: 프로세스들은 한정된 시간 동안 번갈아가며 CPU를 할당받아 실행됨
- **CPU 자원 관리**: 운영체제가 각 프로세스에 CPU 자원을 할당하고 회수하는 방식으로 동작
- **인터럽트 기반 제어**: 프로세스의 CPU 사용 시간은 타이머 인터럽트에 의해 제한됨
- **문맥 백업 과정**: 프로세스 A에서 B로 전환 시, A의 프로그램 카운터, 레지스터 값, 메모리 정보, 열린 파일, 입출력장치 정보 등 중간 상태를 PCB에 백업
- **문맥 복구 과정**: 다음 실행할 프로세스 B의 PCB에서 문맥을 복구하여 이전 실행 지점부터 재개
- **실행 흐름 관리**: 문맥 교환을 통해 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 구조 구현

실제 예시를 보며 이해해보자.

<img width="600" alt="image" src="https://github.com/user-attachments/assets/dcdd1ce2-c226-40aa-8fca-c93703e7c8cd" />

1. **프로세스 A 실행**: CPU 할당받아 실행 중인 상태
2. **타이머 인터럽트 발생**: 할당된 시간 종료
3. **문맥 저장**: A의 현재 상태(레지스터 값, 프로그램 카운터 등)를 A의 PCB에 저장
4. **스케줄링**: 다음 실행할 프로세스 B 선택
5. **문맥 복원**: B의 PCB에서 이전에 저장된 상태 로드하여 CPU 레지스터에 복원
6. **프로세스 B 실행**: B가 이전 실행 지점부터 수행 재개
7. **반복**: 다음 타이머 인터럽트 발생 시까지 프로세스 B 실행 후 다시 문맥 교환 발생

#### 문맥 교환의 오버헤드

- **캐시 미스**: 프로세스 전환 시 캐시 메모리에 저장된 정보가 무효화되어 새로운 프로세스 데이터를 메모리에서 가져와야 함
- **TLB 플러시**: 주소 변환 캐시(TLB) 정보가 초기화되어 메모리 접근 속도 저하
- **파이프라인 초기화**: CPU 명령어 파이프라인이 비워지고 새로운 프로세스의 명령어로 다시 채워지는 과정 필요
- **컨텍스트 저장/복구 시간**: PCB에 정보를 저장하고 불러오는 과정 자체에도 시간 소요
- **메모리 계층구조 충돌**: 서로 다른 프로세스 간 전환 시 캐시, 메모리 등의 계층구조에서 충돌 발생 가능

> 실제 작업보다 문맥 교환에 더 많은 시간이 소요되는 스래싱(thrashing) 현상이 발생함

## 프로세스의 상태

<img width="600" alt="image" src="https://github.com/user-attachments/assets/b798c969-2e8b-41cd-b337-663a3001196d" />

- **생성 상태(new)**: 프로세스 생성 중인 상태, 메모리 적재 및 PCB 할당 완료 상태
- **준비 상태(ready)**: CPU 할당받아 실행할 수 있지만 차례를 기다리는 상태 준비 상태에서 실행 상태로 전환되는 것을 **디스패치**(dispatch)라고 함
- **실행 상태(running)**: CPU 할당받아 실행 중인 상태 타이머 인터럽트 발생 시 준비 상태로 돌아가거나 입출력 요청 시 대기 상태로 전환
- **대기 상태(blocked)**: 입출력 작업 요청이나 바로 확보할 수 없는 자원 요청 등으로 실행 불가능한 상태 조건 충족 시 준비 상태로 이동
- **종료 상태(terminated)**: 프로세스가 종료된 상태, PCB와 사용 메모리 정리

> [!TIP]
> 프로세스가 실행 도중 입출력 작업을 진행해야한다고 가정 했을 때,
>
> - **블로킹 입출력(blocking I/O)**: 입출력 작업 수행 시 대기 상태로 전환돼 완료 시까지 기다림
> - **논블로킹 입출력(non-blocking I/O)**: 입출력 작업을 요청한 후 결과를 기다리지 않고 다음 명령 수행

## 멀티프로세스와 멀티스레드

### 멀티프로세스

- 동시에 여러 프로세스가 실행되는 환경
- 자원을 공유하지 않고 독립적으로 실행됨
- 한 프로세스에 문제가 생겨도 다른 프로세스에 영향 최소화

웹 브라우저의 탭이 대표적인 멀티프로세스 사례로, 각 탭이 각각의 PID를 가지고 있음. 즉, 별도 프로세스로 실행됨.

### 멀티스레드

- 하나의 프로세스 내에서 여러 실행 흐름을 동시에 관리하는 기법
- 스레드 구성 요소: 스레드 ID, 프로그램 카운터, 레지스터 값, 스택
- 코드, 데이터, 힙 영역이나 열린 파일 등 프로세스 자원을 공유함
- 한 스레드 문제가 전체 프로세스에 영향을 줄 수 있음
- 스레드 간 자원 공유로 협력과 통신이 용이함
- 여러 스레드가 함께 작업할 경우 사용자 입력, 화면 출력, 백그라운드 처리 등 동시 수행 가능

> [!TIP]
> 스레드 조인(join)은 **생성된 스레드가 종료될 때까지 기다리는 기능**
> 예를 들어 'main' 스레드가 'a' 스레드를 생성하고 join을 호출하면, 'main' 스레드는 'a' 스레드가 종료될 때까지 대기 상태로 머물게 됨
> C++, 자바, 파이썬, Go 등 대부분의 프로그래밍 언어에서 스레드 생성과 관리 기능을 제공함

## 프로세스 간 통신(IPC)

> [!NOTE]
> 프로세스 간 자원을 공유하고 데이터를 주고받는 방법
> 공유 메모리와 메시지 전달 두 가지 주요 방식이 존재

### 공유 메모리

- 프로세스 간 공유 메모리 영역을 통해 데이터 교환
- 각 프로세스가 자신의 메모리처럼 읽고 쓰는 방식으로 통신
- 메모리 영역을 확보하는 시스템 콜 기반 또는 공유 변수/파일 활용 가능
- **장점**: 커널 개입 최소화로 통신 속도가 빠름
- **단점**: 동시 읽기/쓰기 시 데이터 일관성 문제(레이스 컨디션) 발생 가능

### 메시지 전달

- 커널을 통해 데이터가 송수신되는 통신 방식
- 명확한 메시지 송수신 수단 구분(send/recv 시스템 콜 등)
- **장점**: 커널 도움으로 동기화 문제 고려 감소
- **단점**: 커널 경유로 통신 속도 상대적 저하

#### 메시지 전달 방식들

1. **파이프**
   - 프로세스 간 단방향 통신 도구
   - 한쪽에서 데이터 쓰면 반대쪽에서 읽는 구조
   - 양방향 통신 필요 시 파이프 2개 사용
   - 익명 파이프(unnamed pipe): 양방향 통신 미지원, 부모-자식 프로세스 간 통신만 가능
   - 지명 파이프(named pipe/FIFO): 양방향 통신 지원, 임의 프로세스 간 사용 가능
2. **시그널**
   - 이벤트 발생을 알리는 비동기적 신호
   - 시그널 발생 시 프로세스는 일시 중단 후 시그널 핸들러 실행
   - 프로세스가 시그널 발생 및 일부 핸들러 정의 가능
   - 다양한 시그널 유형 존재(SIGCHLD, SIGINT, SIGKILL 등)
   - 시그널 기본 동작: 종료, 무시, 코어 덤프 생성 후 종료
   - 코어 덤프(core dump): 비정상 종료 시 생성되는 메모리 상태 기록 파일, 디버깅에 활용
3. **원격 프로시저 호출(RPC)**
   - 다른 프로세스의 원격 코드 실행 기법
   - 언어나 플랫폼 독립적 작동
   - 성능 저하 최소화와 효율적 메시지 전달로 서버 간 통신에서 많이 사용됨
   - 구글의 gRPC 등 다양한 RPC 프레임워크 존재
4. **네트워크 소켓**
   - 네트워크를 통한 프로세스 간 통신 방식
   - 로컬 및 원격 프로세스 간 통신 가능
