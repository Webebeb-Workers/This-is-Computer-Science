# 1. 컴퓨터 구조의 큰 그림
## 1.1 컴퓨터가 이해하는 정보
- 데이터 : 숫자, 문자, 이미지, 동영상과 같은 정적인 정보 (수행할 대상)
- 명령어 : 데이터를 활용하는 정보 (수행할 동작)
- 데이터와 명령어는 0과 1로 이루어져 있다.

## 컴퓨터의 핵심 부품
### CPU
- 명렁어와 데이터를 읽어 들이고, 해석하고, 실행하는 부품
#### CPU 구조
- ALU(산술논리연산장치) : CPU가 처리할 명령어를 실직적으로 연산하는 요소
- CU(제어장치) : 명령어를 해석해 제어 신호를 내보내는 장치
- 레지스터 : CPU 내부의 작은 임시 저장장치

### 메모리와 캐시 메모리
#### 메인 메모리
- RAM, ROM
- `실행 중인 프로그램`을 구성하는 데이터와 명령어를 저장하는 부품
- RAM은 휘발성 저장장치로, 전원이 공급되지 않을 때 저장하고 있는 정보가 지워진다.

#### 캐시 메모리
- CPU가 더 빨리 메모리에 저장된 값에 접근하기 위해 사용하는 저장장치

### 보조기억장치
- 전원이 꺼져도 저장된 정보가 사라지지 않는 비휘발성 저장장치
- 하드 디스크 드라이브, 플래시 메모리 기반 SSD
- 어떠한 프로그램을 실행하려면 보조기억장치에서 보관하고 있는 프로그램을 메모리로 복사해야 한다.

### 입출력장치
- 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치
- 마우스, 키보드, 마이크, 스피커, 모니터, 프린터
- 보조기억장치는 메모리를 보조하는 임무를 수행하는 특별한 입출력 장치로 볼 수 있다.

### 메인보드와 버스
#### 메인보드
- 부품들을 고정하고 연결하는 기판

#### 버스
- 컴퓨터 부품들이 정보를 주고받는 통로
- 시스템 버스 : 핵심 부품 연결

> ## 저장장치의 계층 구조
> 1. CPU와 가까운 저장장치는 빠르고, 멀리 있는 저장장치는 느리다.
> 2. 속도가 빠른 저장장치는 용량이 작고, 가격이 비싸다.

# 2. 컴퓨터가 이해하는 정보
- CPU는 기본적으로 0과 1만을 이해할 수 있다.
#### 비트
- 0과 1을 나타내는 가장 작은 정보 단위
- N비트는 2^N개의 정보를 표현할 수 있다.

#### 바이트
- 8비트를 묶은 단위

#### 워드
- CPU가 한 번에 처리할 수 있는 데이터의 크기
- 일반적인 워드의 크기는 32비트 또는 64비트

## 데이터 - 0과 1로 숫자 표현하기
#### 2진법
- 숫자 1을 넘어가는 시점에 자림올림해 0과 1, 2개의 숫자만으로 모든 수를 표현한다.

### 소수를 나타내는 방법

![image](https://github.com/user-attachments/assets/03fe515b-f8e5-47a0-91fd-5d3e63d83e13)
- 결과 : Not Equal
- 부동 소수점 표현 방식의 정밀도 한계
    - 10진수 소수를 2진수로 표현할 떄, 10진수 소수와 2진수 소수의 표현이 딱 맞아떨어지지 않을 수 있기 떄문이다.
    - 예 : `1 * 3 ^ -1` != `0.333333... * 10 ^ 1`

#### 부동 소수점
- 소수점이 고정되어 있지 않은 소수 표현 방식으로 필요에 따라 소수점의 위치가 달라질 수 있다.
- m * 2 ^ n
    - 지수 : n (n > 0, 소수점을 왼쪽으로 이동한 횟수)
    - 기수 : m

#### 저장 방식
![image](https://github.com/user-attachments/assets/ca2fa251-f6c7-4874-8c74-3e04250fb29e)

- 기수
    - 정규화한 수 : 1.XXXXX...
    - 기수는 소수 부분만 저장된다. (XXXXX)

- 지수
    - 컴퓨터가 지수를 저장할 때는 바이어스 값이 더해진다.
    - 바이어스 값 : 2 ^ (k - 1) - 1

## 데이터 - 0과 1로 믄자 표현하기
- 문자 집합 : 컴퓨터가 이해할 수 있는 문자들의 집합
- 문자 인코딩 : 문자 집합 속 문자를 컴퓨터가 이해하는 0과 1로 이루어진 문자 코드로 변환하는 과정
- 문자 디코딩 : 0과 1로 표현된 문자를 사람이 이해하는 문자로 변환하는 과정

#### 아스키 코드
- 초창기 컴퓨터에서 사용하던 문자 집합 중 하나
- 영어 알파벳과 아라비아 숫자, 일부 특수 문자 포함
- 아스키 문자를 표현하기 위해서 1바이트를 사용한다. 그러나, 8비트 중 1비트는 패리티 비트로 실질적으로 사용되는 비트는 7비트이다.
- 아스키 코드는 한글을 표기할 수 없다.

#### EUC-KR
- KS X 1001, KS X 1003이라는 문자 집합 기반의 인코딩 방식
- 아스키 문자를 표현할 떄는 1 바인트, 하나의 한글 글자를 표현할 떄는 2바이트 크기의 코드를 부여한다.
- 모든 한글 조합을 표현할 순 없다.

#### 유니코드
- 한글을 포함해 EUC-KR에 비해 훨씬 많은 언어, 특수문자, 화살표, 이모티콘까지 코드로 표현할 수 있는 통일된 문자 집합으로 현재 가장 많이 사용된다.
- 국가별로 다른 문자 집합과 인코딩 방식을 준비할 필요가 없다.
- 인코딩 방식
    - 가변 길이 인코딩 방식
    - URF-8
    - UTF-16
    - UTF-32

#### base64
- 문자 뿐만 아니라 이진 데이터까지 아스키 문자 형태로 표현할 수 있는 인코딩 방식
- 64(2^6)진법을 의미하므로 6비트씩 나누어 하나의 문자로 변환한다.
- 6비트씩 나누어 떨어지지 않는 경우 0으로 채운다. (패딩)

## 명령어
- 연산 코드 : 명령어가 수행할 동작
- 오퍼랜드 : 동작에 사용될 데이터가 저장된 위치

### 기계어와 어셈블리어
- 기계어 : 0과 1로 표현된 정보
- 어셈블리어 : 기계어를 읽기 편한 형태로 단순 번역한 언어

### 명령어 사이클
- 명령어 사이클 : CPU가 명령어를 처리하기 위해 수행하는 일련의 단계
    - 인출 사이클 : 명령어를 CPU로 가지고 오는 단계
    - 실행 사이클 : CPU로 가져온 명령어를 실행하는 단계
    - 간접 사이클 : 명령어를 실행하기 위해 메모리에 한 번 더 접근하는 단계

# 3. CPU
## 레지스터
### 대부분의 CPU가 공통적으로 포함하고 있는 대표적인 주요 레지스터
#### 프로그램 카운터 (명령어 포인터)
- 메모리에서 다음으로 읽어 들일 명령어의 주소를 저장하는 레지스터

#### 명령어 레지스터
- 메모리에서 읽어 들인 명령어를 저장하는 레지스터

#### 범용 레지스터
- 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터

#### 플래그 레지스터
![image](https://github.com/user-attachments/assets/6873e8b3-bf63-413c-bc3b-3905d2b616f2)

- 연산의 결과 또는 CPU 상태에 대한 부가 정보인 플래그 값을 저장하는 레지스터
- 플래그는 CPU가 명령어를 처리하는 과정에서 반드시 참조해야 할 상태 정보를 의미한다.

#### 스택 포인터
- 메모리 내 스택 영역의 최상단 스택 데이터 위치를 가리키는 특별한 레지스터

## 인터럽트
- CPU의 작업을 방해하는 신호

#### 종류
- 동기 인터럽트
  - CPU에 의해 발생하는 인터럽트
  - 예외
- 비동기 인터럽트 (하드웨어 인터럽트)
  - 입출력장치에 의해 발생하는 인터럽트
  - 알림

### 하드웨어 인터럽트
- 하드웨어 인터럽트를 사용하지 않는다면 CPU는 주기적으로 입출력 장치의 완료 여부를 확인해야한다. (polling)
- 하드웨어 인터럽트를 사용하면 CPU는 작업이 끝나기를 마냥 기다릴 필요 없이 다른 작업을 처리할 수 있게 된다.

#### CPU가 하드웨어 인터럽트를 처리하는 순서
![image](https://github.com/user-attachments/assets/f3e8f339-a2f4-4bf8-8883-471e64de1ce8)

#### 인터럽트 요청 신호
- CPU에게 인터럽트 가능 여부를 확인하는 신호

#### 인터럽트 플래그
- CPU의 플래그 레지스터의 인터럽트 플래그에 따라 하드웨어 인터럽트를 받아들일지, 무시할지를 결정한다.
- 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니다.

![image](https://github.com/user-attachments/assets/020de7f9-d5a7-4bfb-beb3-81449741c5bf)

#### 인터럽트 서비스 루틴 (인터럽트 핸들러)
- 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램
- 메모리에 여러 개의 인터럽트 서비스 루틴들이 저장되어 있다.

![image](https://github.com/user-attachments/assets/8a6eed88-0ed2-46bf-9f6d-f5bd174b4044)

#### 인터럽트 벡터
- 인터럽트 서비스 루틴을 식별하기 위한 정보
- 인터럽트 서비스 루틴의 시작 주소를 포함하고 있다.
- CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 버스를 통해 인터럽트 벡터를 전달받는다.

#### 백업
- 현재 프로그램을 재개하기 위한 필요한 모든 내용을 메모리 내 스택에 백업한다.

#### 인터럽트 사이클을 포함한 명령어 사이클
![image](https://github.com/user-attachments/assets/38148ac5-53d7-4ad3-87eb-bf778d0ee66b)

### 예외
![image](https://github.com/user-attachments/assets/5ebe8481-80fa-43e7-8fe8-659b0983e322)

#### 폴트
- 예외가 발생한 명령어부터 실행을 재개하는 예외

![image](https://github.com/user-attachments/assets/56f92ee6-dd5b-4cc2-897b-2d6305c85328)

#### 트랩
- 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
- 디버깅의 브레이크 보인트

#### 중단
- CPU가 실행중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 떄 발생하는 예외

#### 소프트웨어 인터럽트
- 시스템 콜이 발생했을 떄 발생하는 예외

## CPU 성능 향상을 위한 설계
### CPU 클럭 속도
#### 클럭
- 컴퓨터의 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
- 헤르츠 단위로 측정되며, 이는 클럭이 1초에 몇 번 반복되는지를 나타낸다.
- 클럭 속도는 CPU의 속도 단위로 간주되기도 한다.

### 멀티코어와 스레드
#### 코어
- CPU 내에서 명령어를 읽어 들이고, 해석하고, 실행하는 부품

![image](https://github.com/user-attachments/assets/d5872d77-56cd-4ead-9281-1278f9d3dda1)

#### 멀티코어 CPU (멀티코어 프로세서)
- 여러 개의 코어를 포함하고 있는 CPU

#### 스레드
- 실행 흐름의 단위

#### 하드웨어 스레드 (논리 프로세서)
- 하나의 코어가 동시에 처리하는 명령어의 단위
- 병렬성을 구현하기 위한 물리적인 실행 단위
- **멀티스레드 프로세서 (멀티스레드 CPU)** : 하나의 코어로 여러 명령어를 동시에 처리하는 CPU

![image](https://github.com/user-attachments/assets/eeabee88-3c3c-446c-b707-3f59750386b0)

#### 소프트웨어 스레드
- 하나의 프로그램에서 독립적으로 실행되는 단위
- 동시성을 구현하기 위한 논리적인 실행 단위

#### 병렬성과 동시성
![image](https://github.com/user-attachments/assets/82032457-8419-44fc-a24b-a753f4f9a13b)

- **병렬성** : 작업을 물리적으로 동시에 처리하는 성질
- **동시성** : 동시에 작업을 처리하는 것처럼 보이는 성질

## 파이프라이닝을 통한 명령어 병렬 처리
### 명령어 병렬 처리 기법
- 여러 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시킴으로써 CPU의 성능을 높이는 기법

### 명령어 파이프라이닝
#### 하나의 명령어가 처리되는 과정
![image](https://github.com/user-attachments/assets/5a654c4f-6730-48fe-a683-e1aad6a0a24d)

#### 명령어 파이프라이닝
![image](https://github.com/user-attachments/assets/0e5bd446-6ca9-4980-a46e-2afff5195f1f)

- CPU가 각각의 단계를 동시에 실행할 수 있다.
- 명령어들을 명령어 파이프라인에 동시에 넣고 처리하는 기법

### 명령어 집합 유형
#### CISC
- 다채로운 기능을 지원하는 복잡한 명령어들로 구성된 명령어 집합
- 적은 수의 명령어로도 프로그램을 실행할 수 있다.
- CISC 기반 CPU : 인텔 x86
  
#### RISC
- 짧고 규격화된 명령어 집합, 1클럭 내외로 실행되는 명령어를 지향한다.
- RISC 기반 CPU : 애플 M1 CPU

#### 명령어 집합 유형에 따른 파이프라이닝
![image](https://github.com/user-attachments/assets/8fdceee6-6aa9-4f3e-a35c-9e6a707e6bc1)

- CISC는 파이프라이닝에 비효율적일 수 있지만 RISC는 최적화되어 있다.

### 파이프라이닝이 CPU 성능 향상에 실패하는 경우
#### 파이프라인 위험
- 파이프라이닝이 실패하여 성능 향상이 이루어지지 않는 상황

#### 데이터 위험
- 명령어 간의 데이터 의존성에 의해 발생한다.
- 어떤 명령어들은 동시에 처리할 수 없고, 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있다.

#### 제어 위험
- 프로그램 카운터의 갑작스러운 변화에 의해 발생한다.
- 인터럽트 등으로 인해 프로그램 실행 흐름이 바뀌면 미리 인출하거나 해석 중인 명령어가 쓸모없게 된다.

#### 구조적 위험 (자원 위험)
- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등 같은 CPU 부품을 사용하려고 할 때 발생한다.

# 4. 메모리
## RAM
- Random Access Memory
- 프로그램을 실행하기 위해서는 보조기억장치에 저장된 프로그램을 메모리로 로드해야 한다.

### 임의 접근 vs 순차 접근
![image](https://github.com/user-attachments/assets/ec3b9aeb-6c76-4218-ae86-3c3f5ee42198)

- 임의 접근 (직접 접근) : 임의의 위치에 곧장 접근 가능한 방식
- 순차 접근 : 처음부터 순차적으로 접근하는 방식

### RAM의 종류
#### 1. DRAM
- 시간이 지나면 저장된 데이터가 점차 사라지는 RAM
- 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화해야 한다.
- 소비 전력이 낮고 저렴하며 집적도가 높아 메모리를 대용량으로 설계하기 유리하다.

#### 2. SRAM
- 시간이 지나도 저장된 데이터가 사라지지 않는 RAM
- 속도는 빠르지만, 소비 전력이 크고 비싸며 집적도가 낮아 캐시 메모리에서 사용된다.

#### 3. SDRAM
- 클럭 신호와 동기화된 DRAM

#### 4. DDR SDRAM
- 대역폭을 넓혀 속도를 빠르게 만든 SDRAM

![image](https://github.com/user-attachments/assets/1cc1548d-5359-4d88-8017-9004e84bc039)

## 메모리에 바이트를 밀어넣는 순서
### 빅엔디안
- 낮은 번지의 주소에 상위 바이트부터 저장하는 방식
- 일상적으로 숫자 체계를 읽고 쓰는 순서와 동일하기 떄문에 메모리 값을 직접 읽거나 디버깅할 때 편리하다.

![image](https://github.com/user-attachments/assets/626f9c56-0946-41de-a80f-444da67766a5)

### 리틀엔디안
- 낮은 번지의 주소에 하위 바이트부터 저장하는 방식
- 수치 계산이 편리하다.

![image](https://github.com/user-attachments/assets/6f7fd6cd-d5f7-42ea-8492-eeea50a4eee0)

## 캐시 메모리
![image](https://github.com/user-attachments/assets/b000dcde-975a-4b44-8dcd-30bf048f84df)

- CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생한 저장장치
- CPU와 메모리 사이에 위치한 SRAM 기반의 저장장치

### L1, L2, L3 캐시
![image](https://github.com/user-attachments/assets/e6fffa58-20ac-4b0c-b442-04296f5ce0cc)

- 캐시 메모리의 크기 : L1 < L2 < L3
- 캐시 메모리의 속도 : L1 > L2 > L3
- 멀티코어 프로세서의 경우 일반적으로 L1, L2 캐시 메모리는 코어마다 고유한 캐시 메모리로 할당되고, L3 캐시는 여러 코어가 공유하는 형태로 구현된다.
- 분리형 캐시
 - L1I : 명령어만을 저장하는 L1 캐시
 - L1D : 데이터만을 저장하는 L1 캐시

### 캐시 히트와 캐시 미스
![image](https://github.com/user-attachments/assets/709dca1b-5f5b-4100-bfb8-469c7f6fa899)

- **캐시 히트** : 캐시 메모리가 예측하여 저장한 데이터가 CPU에 의해 실제로 사용되는 경우
- **캐시 미스** : CPU가 메모리로부터 필요한 데이터를 직접 가져와야 하는 경우
- **캐시 적중률** : 캐시가 히트되는 비율
    - `캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)`

### 참조 지역성의 원리
- **시간 지역성** : CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다. (예: 변수)
- **공간 지역성** : CPU는 접근한 메모리 공간의 근처에 접근하려는 경향이 있다. (예: 배열)

### 캐시 메모리의 쓰기 정책과 일관성
#### 즉시 쓰기
![image](https://github.com/user-attachments/assets/66a5cec8-81b2-47a1-a16b-f2192209fa81)

- 캐시 메모리와 메모리에 동시에 쓰는 방법
- 캐시 메모리와 메모리 간의 일관성이 깨지는 상황을 방지할 수 있다.
- 데이터를 쓸 때마다 메모리를 참조해야 하므로 버스의 사용 시간과 쓰기 시간이 늘어난다.

#### 지연 쓰기
![image](https://github.com/user-attachments/assets/9602393e-b136-44bd-96c0-b33b3fbc1e5d)

- 캐시 메모리에만 값을 써 두었다가 추후 수정된 데이터를 한번에 메모리에 반영하는 방법
- 메모리 접근 횟수를 줄일 수 있어 상대적으로 속도는 더 빠르다.
- 메모리와 캐시 메모리 간의 일관성이 꺠질 수 있다. 

> 데이터 접근에 있어 어느 정도의 빠른 성능은 보장할 수 있지만 그와 동시에 데이터의 일관성을 유지하기 위한 책임이 따른다.

# 5. 보조기억장치와 입출력장치
## RAID
#### 하드 디스크 드라이브(이하 하드 디스크)
![image](https://github.com/user-attachments/assets/4bf00101-badd-4b41-8da5-1247739beba5)

- 자기적인 방식으로 데이터를 읽고 쓰는 보조기억장치

#### 플래시 메모리
![image](https://github.com/user-attachments/assets/cd82180a-2ec1-4076-9628-a6d5d5399dd8)

- 전기적인 방식으로 데이터를 읽고 쓰는 반도체 기반의 저장장치
- USB, SSD 등

#### RAID
- 데이터의 안정성 혹은 성능을 확보하기 위해 여러 개의 독립적인 보조기억장치를 마치 하나의 보조기억장치처럼 사용하는 기술

### RAID0
![image](https://github.com/user-attachments/assets/b1c044a9-7154-4a9c-a9a1-bc59da31c589)

- 여러 보조기억장치에 단순하게 나누어 저장하는 구성 방식
- **스트라입** : 분산되어 저장된 데이터
- **스트라이핑** : 분산하여 저장하는 동작

#### 장점
- 빠른 입출력 속도 : 하나의 대용량 저장장치를 이용했다면 여러 번에 걸쳐 읽고 써야 했을 데이터를 한 번에, 동시에 읽고 쓸 수 있다.

#### 단점
- 저장된 정보가 안전하지 않다.

### RAID1(미러링)
![image](https://github.com/user-attachments/assets/fc6eeeb7-02b9-4ef8-96d0-27dc39726e13)

- 완전한 복사본을 만들어 저장하는 구성 방식

#### 장점
- 복구가 간단하고 안전성이 높다.

#### 단점
- 원본과 복사본 두 곳에 써야하기 때문에 쓰기 속도가 느려진다.
- 복사본이 저장된 크기만큼 사용 가능한 요량이 적어진다.

### RAID4
![image](https://github.com/user-attachments/assets/e39470df-d1f6-4ecc-a1dd-0b4da5ae30ba)

- 패리티 정보를 저장하는 디스크를 따로 두는 구성 방식
- **패리티** : 오류를 검출할 수 있는 정보

#### 장점
- RAID1에 비해 적은 하드디스크로도 안전하게 데이터를 보관할 수 있다.

#### 단점
- 패리티를 저장하는 장치에 병목 현상이 발생한다.

### RAID5
![image](https://github.com/user-attachments/assets/485d920e-bde1-4bed-9343-fcd03dc403ed)

- 패리티를 분산하여 저장하는 구성 방식

#### 장점
- RAID4의 병목 현상을 보완할 수 있다.

### RAID6
![image](https://github.com/user-attachments/assets/2fe24c0b-cbb5-4216-a046-3fc18dbc259d)

- 서로 다른 2개의 패리티를 두는 구성 방식

#### 장점
- 오류를 검출하고 복구할 수 있는 수단이 2개가 생겨 RAID4나 RAID5에 비해 안정성이 높다.

#### 단점
- 새로운 정보를 저장할 때마다 함께 저장할 패리티가 2개이므로 RAID5보다 쓰기 속도는 일반적으로 느리다.

## 입출력 기법
### 장치 컨트롤러와 장치 드라이버
#### 장치 컨트롤러
![image](https://github.com/user-attachments/assets/e4375115-000f-4fc1-b740-cc3ab89b9eca)

- CPU와 입출력장치 사이의 통신을 중개하는 중개자 역할의 하드웨어

#### 장치 드라이버
- 장치 컨트롤러의 동작을 알고, 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있도록 하는 프로그램
- 대중적인 장치 드라이버에 경우에는 운영체제에 포함되어 있는 경우가 많아 별도의 설치 없이 입출력장치를 사용할 수 있다.

### 프로그램 입출력
- 프로그램 속 명령어로 입출력 작업을 수행하는 방법
- 입출력 명령어를 실행함으로써 장치 컨트롤러와 상호작용할 수 있고, 이를 통해 입출력 작업을 수행한다.

### 인터럽트 기반 입출력: 다중 인터럽트
#### 인터럽트가 여러 입출력장치로부터 동시다발적으로 발생하는 경우
![image](https://github.com/user-attachments/assets/da38b88c-9ab6-47fd-9e35-54f38bcbfdbf)

- 인터럽트 비트를 비활성화한 채 인터럽트를 처리할 경우, 인터럽트 서비스 루틴을 순차적으로 실행한다.

![image](https://github.com/user-attachments/assets/4562e9c9-6e12-43a9-a409-dd15c32150ae)

- 인터럽트 비트가 활성화되어 있거나 NMI가 발행한 경우, 우선순위가 높은 인터럽트부터 먼저 처리한다.

#### 프로그래머블 인터럽트 컨트롤러(PIC)
![image](https://github.com/user-attachments/assets/55139e8a-d3f8-4014-825f-39df1cbff1cb)

- 여러 장치 컨트롤러에 연결되어 있어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤, CPU에게 지금 처리해야 할 하드웨어 인터럽트가 무엇인지 알려주는 장치
- 많은 하드웨어 인터럽트를 관리하기 위해 2개 이상의 계층으로 구성된다.

### DMA 입출력
![image](https://github.com/user-attachments/assets/c9bdc2cd-b658-4a50-9d76-13c21577019a)

- 프로그램 기반의 입출력과 인터럽트 기반의 입출력은 CPU가 입출력장치와 메모리 간의 데이터 이동을 주도해야 하며, 이동하는 데이터들도 반드시 CPU를 거친다.

#### DMA
![image](https://github.com/user-attachments/assets/e778939d-3bfa-4421-a09b-c9f1a3a22f1d)

- CPU를 거치지 않고도 입출력장치와 메모리가 상호작용할 수 있는 입출력 방식 
- 즉, 직접 메모리에 접근할 수 있는 입출력 기능

#### DMA 입출력 과정
![image](https://github.com/user-attachments/assets/5231e917-969d-4561-8c30-8f2e2bc7e5dc)

#### PCIe
![image](https://github.com/user-attachments/assets/77c21191-e047-462b-b955-6ffd362d618a)

- 대표적인 입출력 버스
- PCIe 버스는 지속적으로 발전하고 있으므로 버전이 존재한다. 버전에 따라 지원되는 최대 속도가 다르다.
- **레인** : PCIe 버스를 통해 정보를 송수신 하는 단위  
