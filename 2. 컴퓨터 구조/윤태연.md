# 1절. 컴퓨터 구조의 큰 그림

<img width="653" alt="image" src="https://github.com/user-attachments/assets/b37812b8-0f23-42a6-bf83-d2879cd1e5c8" />

## 컴퓨터가 이해하는 정보

컴퓨터는 프로그래밍 언어를 직접 이해하지 못하고, 데이터와 명령어라는 두 가지 형태의 **0과 1**로 이루어진 정보만 이해함.

- **데이터**
  - 숫자, 문자, 이미지, 동영상과 같은 정적인 정보로 명령의 대상이자 재료
  - 있는 그대로의 정보
- **명령어**
  - 데이터를 활용해 실행하는 정보로 수행할 동작을 지정
  - '더하라', '출력하라', '저장하라'와 같은 형태로 구성

## 컴퓨터의 핵심 부품

<img width="695" alt="image" src="https://github.com/user-attachments/assets/d0906159-76e8-4113-827d-9f4f84167ce8" />

### CPU (중앙처리장치)

데이터와 명령어를 읽고, 해석하고, 실행하는 핵심 부품으로 컴퓨터의 두뇌 역할을 담당함. 다음과 같은 구성 요소를 포함함.

<img width="486" alt="image" src="https://github.com/user-attachments/assets/85eb2246-59b1-4b70-af39-4275c2d3650a" />

- **산술논리연산장치(ALU)**: 사칙 연산, 논리 연산 등 연산을 수행하는 회로로 구성된 **계산기** 역할 담당
- **제어장치(CU)**: 명령어를 해석해 제어 신호를 내보내는 장치로 다른 부품을 작동시키는 전기 신호를 생성
- **레지스터**
  - CPU 내부의 작은 임시 저장장치로 데이터와 명령어 처리 과정의 값 저장
  - 여러 개의 레지스터가 각각 다른 역할을 수행
  - **CPU의 가장 중요한 구성 요소**
  - 얘만 봐도 프로그램이 어떻게 실행되는지 로우레벨에서 파악 가능

### 메모리(주기억장치)

> [!NOTE]
> 현재 실행 중인 프로그램을 구성하는 데이터와 명령어를 저장하는 부품
> CPU가 직접 접근 가능

<img width="627" alt="image" src="https://github.com/user-attachments/assets/901efafb-9078-4af7-9686-fafebf14fe03" />

#### 주요 특성

- **RAM(Random Access Memory)**: 일반적으로 메모리라고 부름, 주로 휘발성 특징을 가짐
- **ROM(Read Only Memory)**: 읽기 전용 메모리, 일부 중요 정보 저장에 사용
- **주소**: CPU가 원하는 정보에 빠르게 접근하기 위한 위치 식별자, 메모리의 정돈된 정보 관리에 필수적
- **휘발성**: 전원이 공급되지 않을 때 저장된 정보가 모두 지워지는 특성

#### 캐시 메모리

CPU가 조금이라도 더 빠르게 메모리에 저장된 값에 접근하기 위한 보조 저장장치임. CPU와 메모리 사이에 위치.

CPU 내부에 있기도 하고 외부에 있기도 하며, 여러 종류(L1, L2, L3 등)가 있음.

### 보조기억장치

> [!NOTE]
> 전원이 꺼져도 저장된 정보가 사라지지 않는 비휘발성 저장장치
> 메모리를 보조하는 역할 수행

<img width="662" alt="image" src="https://github.com/user-attachments/assets/53b48a03-4166-4649-aeae-e1428196332e" />

- **주요 종류**
  - **하드 디스크 드라이브(HDD)**: 자기 디스크 기반 저장장치
  - **SSD(Solid State Drive)**: 플래시 메모리 기반 저장장치, 빠른 접근 속도를 제공
  - **기타**: CD-ROM, DVD, USB 메모리, SD 카드 등
- **특징**: 보관할 프로그램 저장 및 프로그램 실행 시 해당 내용을 메모리로 복사해야 CPU가 처리 가능
- **RAID**: 안전하고 안정적으로 보조기억장치를 구성하는 기술로 중요 데이터 보호에 활용

### 입출력장치

컴퓨터 외부에 연결되어 내부와 정보를 교환하는 장치로 다음과 같이 구분됨.

- **입력장치**: 마우스, 키보드, 마이크 등 컴퓨터에 정보를 입력하는 장치
- **출력장치**: 모니터, 스피커, 프린터 등 컴퓨터의 정보를 받아 출력하는 장치

참고: 보조기억장치와 입출력장치는 완전히 배타적인 개념이 아니며, 보조기억장치는 메모리를 보조하는, 특별한 형태의 입출력장치로 볼 수 있음.
이들을 통틀어 주변장치라고 부르기도 함.

### 메인보드 & 버스

- **메인보드(마더보드)**: 컴퓨터 핵심 부품들을 고정하고 연결하는 기판으로 여러 부품을 연결할 수 있는 슬롯과 단자들이 있는 기판 형태
- **버스**
  - 부품들이 정보를 주고받는 통로, 버스의 종류는 다양함
  - 특히 **시스템 버스**는 CPU, 메모리 등 핵심 부품들을 연결하는 중요한 통로

<img width="616" alt="image" src="https://github.com/user-attachments/assets/af22c627-06ea-495c-a6bd-20c58c28695d" />

## 저장장치의 계층 구조

> [!NOTE]
> CPU와 가까운 저장장치는 빠르고 용량이 작으며 가격이 비싼 특성을 가지고, 멀어질수록 속도는 느려지지만 용량이 커지고 가격이 저렴해짐.

<img width="640" alt="Image" src="https://github.com/user-attachments/assets/a8d053c0-8e95-4284-bcdb-4a0d1f5630af" />

- **계층 순서**: 레지스터 → 캐시 메모리(L1, L2, L3) → 메모리 → 보조기억장치 순으로 CPU와의 거리 증가
- **특성**: 각 계층별 저장장치는 속도, 용량, 가격 측면에서 서로 다른 장단점을 가지므로 모두 함께 사용하는 것이 효율적

참고: 저장장치 계층 구조는 얼마든 추가할 수 있으니 상위-하위 계층에 대해 어떤 특징들이 있는지 대략적으로 숙지하도록!

#### 마무리

<img width="1002" alt="image" src="https://github.com/user-attachments/assets/b370bd91-76cc-4301-9734-a96953fd39ea" />

---

# 2절. 컴퓨터가 이해하는 정보

0과 1만을 이해하는 컴퓨터가 어떻게 문자와 숫자를 인식하는지, 그리고 그렇게 표 현된 정적인 데이터가 명령어에 의해 어떻게 실행되는지 학습.

## 0과 1로 이루어진 정보

> [!NOTE]
> 컴퓨터는 0과 1만을 이해할 수 있으며, 이러한 이진 정보를 통해 모든 데이터와 명령어를 표현함.

- **비트(bit)**
  - 0과 1을 나타내는 가장 작은 정보 단위
  - N비트는 2^N개의 정보 표현 가능
- **바이트(byte)**
  - 8비트를 묶은 단위
  - 2^8=256개의 정보 표현이 가능
- **워드(word)**
  - CPU가 한 번에 처리할 수 있는 데이터 크기
  - 일반적으로 32비트 또는 64비트

#### 정보 용량 단위

| 단위   | 크기            |
| ------ | --------------- |
| 1 byte | 8비트           |
| 1 KB   | 1,000바이트     |
| 1 MB   | 1,000킬로바이트 |
| 1 GB   | 1,000메가바이트 |
| 1 TB   | 1,000기가바이트 |

## 데이터 - 0과 1로 숫자 표현하기

### 2진법 & 16진법

- **2진법**
  - 숫자 1을 넘어가는 시점에 자리올림, 0과 1로만 모든 수를 표현
  - 표기법: 숫자 뒤 `(2)` 또는 `0b` 접두사 사용
- **16진법**
  - 2진수 표현의 길이가 길어지는 단점을 보완하기 위해 사용, 10~15는 A~F로 표현
  - 표기법: `(16)` 또는 `0x` 접두사를.사용함.
- **활용 사례**: 16진법 사용
  - MAC 주소(A1:C2:E3:A5:C6:E7)
  - IPv6 주소(2001:0a1b:1234:0000:0000:abcd:1234:ff02)

> `그래서 컴퓨터가 이해하는 정보를 표현할 때는 2진수와 더불어 16진수도 함께 사용합니다.`
> 16진수를 먹일 수 있는 컴퓨터는 어떤 종류일까요? CPU도 16진수를 이해할 수 있을까요?

### 소수 표현 방식

컴퓨터에서 소수 표현 시 발생하는 오차는 부동소수점 방식의 정밀도 한계에서 비롯함.

```py
a = 0.1
b = 0.2
c = 0.3

if a + b== c:
  print("Equal")
else:
  print("Not Equal")
```

결과는 `'Not Equal'`.. 왜 이럴까?

- **부동소수점**: 소수점이 고정되지 않은 표현 방식
  - `가수 × 기수^지수` 형태로 표현
- **정규화**: 가수의 정수부를 1로 통일(1.XXX 형태)해 저장 효율을 높임
- **저장 방식**: 지수부에는 바이어스(2^(k-1)-1) 값이 더해지고, 가수부에는 소수 부분만 저장됨.
- **오차 발생 원인**: 10진수 소수를 2진수로 정확히 표현할 수 없는 경우가 있어 근사값 사용으로 발생함.
- **IEEE 754 저장 형식**
  - 32비트(단정밀도): 1비트(부호) + 8비트(지수) + 23비트(가수)
  - 64비트(배정밀도): 1비트(부호) + 11비트(지수) + 52비트(가수)

## 데이터 - 0과 1로 문자 표현하기

> [!NOTE]
> 문자 집합은 컴퓨터가 이해할 수 있는 문자들의 모음이며, 이를 0과 1로 변환하는 과정이 문자 인코딩임.

### 문자 인코딩/디코딩

- **문자 인코딩**: 문자를 컴퓨터가 이해하는 0과 1로 이루어진 코드로 변환하는 과정
- **문자 디코딩**: 0과 1로 표현된 문자 코드를 사람이 이해하는 문자로 변환하는 과정
- **코드 포인트**: 문자 인코딩에서 글자에 부여된 고유한 값

### 주요 문자 집합과 인코딩

- **아스키(ASCII)**: 영어 알파벳, 숫자, 일부 특수문자를 포함한 128개 문자를 7비트로 표현함.
- **EUC-KR**: 한글을 지원하는 인코딩으로, 아스키는 1바이트, 한글은 2바이트로 표현하며 약 2,350개의 한글만 표현 가능함.
- **유니코드**: 전 세계 대부분의 문자를 통일된 방식으로 표현하는 표준으로, 다양한 인코딩 방식(UTF-8, UTF-16, UTF-32)을 사용함.

### Base64 인코딩

- 문자뿐만 아니라 이진 데이터까지 아스키 문자 형태로 표현할 수 있는 인코딩 방식임.
- 64진법을 사용하므로 6비트씩 나누어 하나의 문자로 변환함.
- 6비트씩 나누어 떨어지지 않는 경우 0으로 패딩하고 '='로 표시함.
- 이메일 첨부파일, 웹에서 이미지 데이터 전송 등에 활용됨.

## 명령어

> [!NOTE]
> 명령어는 컴퓨터가 수행할 동작(연산 코드)과 대상(오퍼랜드)으로 구성된 CPU가 이해하는 지시사항임.

### 명령어의 구성

- **연산 코드(Opcode)**: 명령어가 수행할 동작을 지정하는 부분
- **오퍼랜드(Operand)**: 연산에 사용될 데이터 또는 데이터가 저장된 위치를 명시하는 부분
  - 데이터 자체(예: 10, 100)
  - 데이터 위치(예: 메모리 32번지, 레지스터 이름)

### 주요 연산 코드 유형

- **데이터 전송**: MOVE, STORE, LOAD, PUSH, POP 등
- **산술/논리 연산**: ADD, SUBTRACT, MULTIPLY, DIVIDE, AND, OR, NOT 등
- **제어 흐름 변경**: JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN 등
- **입출력 제어**: READ, WRITE, START IO, TEST IO 등

### 기계어와 어셈블리어

- **기계어**: 0과 1로 표현된 CPU가 직접 이해하는 언어
- **어셈블리어**: 기계어를 사람이 읽기 쉬운 형태로 변환한 저수준 언어
- **특징**: 같은 프로그램이라도 CPU 아키텍처에 따라 다른 형태의 기계어와 어셈블리어로 표현됨(예: CISC와 RISC 기반 CPU)

### 명령어 사이클

- **인출 사이클**: 메모리에서 명령어를 CPU로 가져오는 단계
- **실행 사이클**: 인출한 명령어를 해석하고 실행하는 단계
- **간접 사이클**: 명령어 실행을 위해 메모리에 추가로 접근하는 단계(오퍼랜드 필드에 메모리 주소가 있을 경우)
- **인터럽트 사이클**: CPU 작업을 중단하고 인터럽트를 처리하는 단계
