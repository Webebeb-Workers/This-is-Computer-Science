# 1. 컴퓨터 구조의 큰 그림

![Image](https://github.com/user-attachments/assets/d3fcd297-a1af-4dd1-897b-f00b74229609)

**목표**

- 컴퓨터가 이해하는 정보 (예를 들어 0과 1)
- 프로그램을 실행하는 하드웨어

---

## 1.1 컴퓨터가 이해하는 정보

![Image](https://github.com/user-attachments/assets/08515018-ddd2-47fc-bbdb-50d133ad6714)

- 컴퓨터는 프로그래밍 언어를 직접 이해하지 못함
- 소스 코드는 내부적으로 컴퓨터가 이해할 수 있는 **데이터**와 **명령어**의 형태로 변환되어 실행됨

### 데이터

- 정적인 정보를 의미:
  - 숫자, 문자, 이미지, 동영상
- 0과 1만으로 다양한 정보들을 표현함
- 명령의 대상이자, 명령어의 재료

### 명령어

- 데이터를 활용해 명령어를 실행함
- CPU: 명령어를 이해하고 실행하는 주체
- CPU의 종류에 따라서 명령어의 종류와 처리 양상이 달라짐
- 명령어 사이클: CPU가 명령어를 처리하는 순서

## 1.2 컴퓨터의 핵심 부품

![Image](https://github.com/user-attachments/assets/20077a54-958e-44bd-87d2-0d2ebf1f110b)

- CPU(중앙처리장치)
- 메모리(주기억장치)
- 캐시 메모리
- 보조기억장치
- 입출력장치

### CPU

- 데이터와 명령어를 읽고, 해석하고, 실행하는 부품

#### CPU의 주요 구성 요소

![Image](https://github.com/user-attachments/assets/848ddd7d-f71b-482a-b4c4-a56736e7acc0)

**산술논리연산장치(ALU, Arithmetic and Logic Unit)**

- 사칙 연산, 논리 연산과 같은 연산을 수행할 회로로 구성되어 있음(일종의 계산기)
- CPU가 처리할 명령어를 실질적으로 연산하는 요소

**제어장치(CU, Control Unit)**

- 명령어를 해석해 제어 신호(전기 신호)를 내보내는 장치
- 제어 신호: 부품을 작동시키기 위한 신호
- ex) CPU가 입출력장치를 향해 제어 신호를 보내면 입출력 장치를 작동시킬 수 있음

**레지스터(register)**

- CPU 내부의 작은 임시 저장장치
- 데이터와 명령어를 처리하는 과정에서의 값을 저장함
- 여러 개의 레지스터가 존재하며, 각기 다른 이름과 역할을 가짐
- 가장 중요한 구성 요소, CPU가 처리하는 명령어는 반드시 레지스터에 저장되기 때문에 레지스터 값만 잘 관찰해도 프로그램이 어떻게 실행되는지 가장 낮은 단계에서 파악할 수 있음

### 메모리(주기억장치)

- 메모리: RAM, ROM
- 일반적으로 메모리는 RAM을 지칭함
- CPU가 읽고, 해석하고, 실행하는 모든 정보를 저장하는 장치
- 현재 **실행 중인 프로그램을 구성하는 데이터와 명령어를 저장하는 부품**
- 프로그램이 실행되려면 프로그램을 이루는 데이터와 명령어가 메모리에 저장되어있어야 함

**주소**

![Image](https://github.com/user-attachments/assets/bb930b1e-b6d1-4b8c-853c-023e4270d7fa)

- CPU가 원하는 정보로 접근하기 위해서 필요함

**휘발성**

- 전원이 공급되지 않을 때 저장하고 있는 정보가 지워지는 특성
- 메모리는 휘발성 저장장치로, 메모리에 저장된 정보는 컴퓨터의 전원이 꺼지면 모두 삭제됨

### 캐시 메모리

![Image](https://github.com/user-attachments/assets/eb81aef8-0a6e-40ec-b82e-ecab1d8b1d0a)

- CPU가 조금이라도 더 빠르게 메모리에 저장된 값에 접근하기 위해 사용됨
- 빠른 메모리 접근을 위한 보조 저장 장치
- CPU 안에 위치하기도 하고, CPU 밖에 위치하기도 함

### 보조 기억 장치

![Image](https://github.com/user-attachments/assets/6d265ccd-0e60-417a-b368-2ede52846e3a)

- 휘발성 저장장치인 메모리를 보조하기 위한 장치
- 전원이 꺼져도 저장된 정보가 사라지지 않는 **비휘발성** 저장장치
- CD-ROM, DVD, 하드 디스크 드라이브, 플래시 메모리(SSD, USB 메모리), 플로피 디스크 등이 있음
- 자주 사용되는 보조기억장치: 하드 디스크 드라이브, 플래시 메모리 기반 SSD

![Image](https://github.com/user-attachments/assets/84e4f88b-8bc2-4dac-b0df-09eeed350dea)

- 보관할 프로그램을 저장
- 프로그램을 실행하려면 보조기억장치에서 보관하고 있는 프로그램을 메모리로 복사해야함
- RAID: 안전하고 안정적으로 보조기억장치를 구성하는 기술

### 입출력장치

- 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치
- 입력장치: 컴퓨터에 어떠한 입력을 할 때 사용하는 장치
  - ex) 마우스, 키보드, 마이크
- 출력장치: 컴퓨터의 정보를 받기 위해 사용하는 장치
  - ex) 스피커, 모니터, 프린터
- 보조기억장치와 입출력장치는 완전 배타적 개념이 아님
  - 보조기억장치는 메모리를 보조하는 임무를 수행하는 특별한 입출력장치
  - 보조기억장치와 입출력장치를 주변장치라고 통칭하기도 함

### 메인 보드와 버스

![Image](https://github.com/user-attachments/assets/385cd7a2-58f5-4a79-9b2e-f7f8897dec08)

#### 메인 보드(마더 보드)

- 컴퓨터 핵심 부품들을 고정하고 연결하는 기판
- 부품들을 연결할 수 있는 슬롯과 연결 단자들로 구성됨

#### 버스

- 메인 보드에 연결된 부품들은 각자의 역할을 수행하기 위해 서로 정보를 주고 받음
- 버스: 부품들이 정보를 주고받는 통로
- **시스템 버스**: 핵심 부품들을 연결함

### 저장 장치의 계층 구조

- 레지스터, 메모리, 캐시 메모리, 보조기억장치의 특성:

  1. CPU와 가까운 저장장치는 빠르고, 멀리 있는 저장장치는 느림
  2. 속도가 빠른 저장장치는 용량이 작고, 가격이 비쌈

- CPU와 가까운 순서:

  레지스터 -> 캐시 메모리 -> 메모리 -> 보조기억장치

- 저장장치 계층 구조: 저장장치들은 CPU와의 거리, 용량과 성능을 기준으로 계층적 구조를 가짐

  ![Image](https://github.com/user-attachments/assets/54650580-c860-48fe-a61b-755f3e306343)

## 1.3 컴퓨터 구조 지도 그리기

![Image](https://github.com/user-attachments/assets/89b3b4b3-d306-4b2d-94fa-63c27e762c48)

# 2. 컴퓨터가 이해하는 정보

**목표**

- 0과 1만 이해하는 컴퓨터가 어떻게 문자와 숫자를 인식하나?
- 정적인 데이터가 명령어에 의해 어떻게 실행되나?

---

**비트**

- 가장 작은 정보의 단위(0과 1)
- N비트는 2^N개의 정보 표현 가능
- 단위(프로그램 크기 단위)
  - 1 byte: 8비트
  - 1KB: 1000바이트
  - 1MB: 1000KB
  - 1GB: 1000MB
  - 1TB: 1000GB

**워드**

- CPU가 한 번에 처리할 수 있는 데이터의 크기
- CPU는 프로그램을 워드 단위로 읽고 처리함
- CPU가 한 번에 처리할 수 있는 비트 수
  - ex) CPU가 한 번에 16비트 처리가능하면 1워드는 16비트
- 워드의 크기는 CPU마다 다르지만, 보통 32비트 또는 64비트

## 2.1 데이터 - 0과 1로 숫자 표현하기

### 2진법

- 2진수로 표현된 수는 숫자 뒤에 아래첨자로 (2)를 붙이거나 2진수 앞에 0b를 붙임

### 16진법

- 2진법은 숫자의 길이가 너무 길어진다는 단점이 있음
  - ex) 10진수 128을 2진수로 표현하면 10000000(2)
- 따라서 2진수와 더불어 16진수를 함께 사용함
- 16진법 체계에서는 10진수 10, 11, 12, 13, 14, 15를 각각 A, B, C, D, E, F로 표기함
- 16진수로 표현된 수는 뒤에 아래첨자로 (16)을 붙이거나 16진수 앞에 0x를 붙임
- 활용 예시:
  - MAC 주소: A1:C2:E3:A5:C6:E7
  - IPv6 주소: 2001:0a1b:1234:0000:0000:abcd:1234:ff02

### 2진수로 소수 나타내기

- 표현하고자 하는 소수와 저장되는 소수 간에 오차가 존재함
- 0.1 + 0.2 !== 0.3
- 오차가 발생하는 이유: 컴퓨터가 부동소수점을 저장하는 방식

**부동소수점**

- 소수점이 고정되어 있지 않은 소수 표현 방식, 필요에 따라 소수점의 위치가 이동할 수 있음
  - ex) 10진수 123.123 이라는 수를 m*10^n 으로 나타내면 1.23123 * 10^2, 1231.23 \* 10^(-1) 로 표현 가능
- 2진수 체계에서는 소수를 m \* 2^n의 꼴로 나타냄
  - ex) 10진수 107.6640623를 2진수로 나타내면 1101011.1010101임. 1.1010111010101 \* 2^6, 11010110.10101 \* 2(-2) 로 표현 가능
- 가수 \* 기수^(지수)
  - ex) 11010110,10101(가수), 2(기수), -2(지수)

**컴퓨터가 부동소수점을 저장하는 방식**

![Image](https://github.com/user-attachments/assets/079c79d9-c2b9-4e4d-b485-8ae48654b69a)

- 컴퓨터 내부에서 소수점을 나타내기 위해 사용하는 방식이며 정밀도에 한계가 있음
- 컴퓨터는 2진수의 지수와 가수를 위와 같이 저장함. 이와 같은 부동소수점 방식을 IEEE 754라고 함
- 가수의 정수부에는 1로 통일된 정규화한 수가 저장됨(1.XXX 형태)
- 2^지수 \* 1.XXX 형태가 고정되므로, 소수를 저장할 때는 지수와 XXX에 해당하는 소수 부분만 저장함
  - ex) 1.1010111010101 \* 2^6 -> 지수:6, 가수: 1010111010101
- 컴퓨터가 지수를 저장할 때는 바이어스(bias) 값이 더해져서 저장됨. 이때 바이어스 값은 2^(k-1)-1 (k는 지수의 비트 수)
  - 지수를 표현하기 위해 8비트가 사용됐으면 바이어스 값은 2^7 - 1 인 127
  - 따라서 1.1010111010101 \* 2^6이 32비트로 저장될 때는 127 + 6인 133(2진수 10000101)이 지수에 저장됨
- 10진수 소수를 2진수로 표현할 때, 10진수 소수와 2진수 소수의 표현이 딱 맞아떨어지지 않음
  - ex) 1/3을 10진수로 표현하면 0.3333 무한 소수
- 컴퓨터의 저장공간은 한정적이기 때문에 무한히 많은 소수점을 저장할 수 없어서 일부 생략해서 저장함 -> 오차 발생

## 2.2 데이터 - 0과 1로 문자 표현하기

**문자 집합**

- 컴퓨터가 이해할 수 있는 문자들의 집합

### 문자 인코딩

- 문자를 컴퓨터가 이해하는 0과 1로 이루어진 문자 코드로 변환하는 과정
- 동일한 문자 집합이더라도 다양한 문자 인코딩 방법이 있음

### 문자 디코딩

- 0과 1로 표현된 문자를 사람이 이해하는 문자로 변환하는 과정
- 웹사이트가 문자의 인코딩 또는 디코딩 방법을 지원하지 않으면 글자가 깨짐

### 아스키

- 초창기 컴퓨터에서 사용하던 문자 집합 중 하나
- 영어의 알파벳, 아리바아 숫자, 일부 특수 문자 포함
- 하나의 아스키 문자 표현하기 위해 8비트 사용, 8비트 중 1비트는 오류 검출을 위한 패리티 비트이므로 사실상 문자 표현을 위해 사용되는 비트는 7비트 -> 총 2^7인 128개의 문자 표현 가능

**아스키 코드표**

![Image](https://github.com/user-attachments/assets/4f745dcc-545a-4071-9d01-14f0bbfc9a1e)

**아스키 코드**

- 아스키 문자들은 0부터 127까지의 숫자 중 하나의 고유한 수에 대응되는데, 이를 아스키 코드라고 함
- 아스키 코드의 인코딩: 문자 'A'를 10진수 65로 인코딩
- 아스키 코드의 디코딩: 10진수 65를 문자 'A'로 디코딩
- 한글을 표기할 수 없음 -> 한글도 지원하는 EUC-KR 등장

### EUC-KR

![Image](https://github.com/user-attachments/assets/e58cf973-e7a8-4726-afdd-5b5daae405a7)

- KS X 1001, KS X 1003 이라는 문자 집합 기반의 인코딩 방식
- 아스키 문자를 표현할 때는 1바이트 크기의 코드를 부여함
- 한글 글자를 표현할 때는 2바이트 크기의 코드를 부여함
- 총 2,350 개의 한글 단어를 표현하므로 모든 한글 조합을 표현할 수는 없음 -> 유니코드 문자 집합 등장

### 유니코드

![Image](https://github.com/user-attachments/assets/d0c3917f-16b6-4ab2-bae3-dc3bd616c215)

- 훨씬 많은 언어, 특수문자, 화살표, 이모티콘까지 코드로 표현할 수 있는 통일된 문자 집합
- 대부분의 언어를 지원하기 때문에 국가별로 다른 문자 집합과 인코딩 방식을 사용할 필요가 없어짐
- 따라서 현대 가장 많이 사용되는 표준 문자 집합
- 아스키 코드나 EUC-KR은 글자에 부여된 값을 그대로 인코딩 값으로 삼았지만 유니코드는 다양한 방법으로 인코딩함 (UTF-8, UTF-16, UTF-32)
- UTF-8, UTF-16, UTF-32는 가변 길이 인코딩 방식으로, 인코딩된 결과의 길이가 일정하지 않음

### base64 인코딩

![Image](https://github.com/user-attachments/assets/5d64aba8-54b9-46ae-80da-0694e49d5365)

- 문자뿐만 아니라, 이진 데이터까지 변환할 수 있는 인코딩 방식
- 단순 문자 이외의 이미지 데이터까지 모두 아스키 문자 형태로 표현 가능
- 64진수 하나를 표현하기 위해 6비트가 필요함
- 변환할 데이터를 6비트씩 나눠서 하나의 문자로 변환함
- 예를 들어 'abc' 문자열 -> 아스키 코드 97, 98, 99로 인코딩 -> 8비트 크기의 2진수인 01100001, 01100010, 01100011 로 표현 -> base64에 따라 6비트씩 끊어 변환하여 'YWJj'가 됨
  ![Image](https://github.com/user-attachments/assets/c9645e9f-99bb-4d93-9634-29a09f89c0f4)

## 2.3 명령어

- 명령어는 수행할 동작과 수행할 대상으로 이루어짐
- 하나의 명령어는 연산 코드와 0개 이상의 오퍼랜드로 구성됨
- 연산 코드 필드: 연산 코드가 담기는 영역
- 오퍼랜드 필드: 오퍼랜드가 담기는 영역

**수행할 대상**

- 수행할 동작에 사용될 데이터 자체(ex. 10)
- 데이터가 저장된 위치(ex. 메모리 128번지)

**연산 코드: 연산자**

- 명령어가 수행할 동작
- 대부분의 CPU가 공통적으로 이해하는 연산 코드: 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어

![Image](https://github.com/user-attachments/assets/a328b041-50a9-4a81-b13d-2b9d8d1767be)
![Image](https://github.com/user-attachments/assets/59dbff4e-4143-4ae6-984f-2a2f993a3075)

**오퍼랜드: 피연산자**

- 데이터값 또는 데이터가 저장된 위치(주소)
- 보통 데이터가 직접 명시되기 보다는 위치(메모리 주소 또는 레지스터 이름)가 명시됨 -> 주소 필드라고도 부름

### 기계어와 어셈블리어

![Image](https://github.com/user-attachments/assets/e398338a-ac57-4282-a460-34bceaf1f89a)

**기계어**

- 0과 1로 표현된 언어

**어셈블리어**

- 0과 1로 표현된 기계어를 읽기 쉽게 나타낸 언어
- 어셈블리어를 보면 CPU가 이해할 수 있는 명령어의 종류와 동작 파악 가능

### 명령어 사이클

![Image](https://github.com/user-attachments/assets/d2545bad-30c0-439b-9d75-f5dcc287a702)

- CPU가 명령어를 처리하는 과정에서 반복되어 실행되는 것
- 인출 사이클: 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- 실행 사이클: CPU로 가져온 명령어를 실행하는 단계
- 간접 사이클: 명령어 실행을 위해 메모리에 접근하는 단계
  - 오퍼랜드 필드에 메모리 주소가 명시된 경우, 한 번 더 메모리에 접근해야 함
  - ex) 빼라, 메모리 32번지 안의 값과, 메모리 33번지 안의 값을
- 인터럽트 사이클: 다음 절에서 학습
