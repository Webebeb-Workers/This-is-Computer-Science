# 1. 컴퓨터 구조의 큰 그림

![Image](https://github.com/user-attachments/assets/d3fcd297-a1af-4dd1-897b-f00b74229609)

**목표**

- 컴퓨터가 이해하는 정보 (예를 들어 0과 1)
- 프로그램을 실행하는 하드웨어

---

## 1.1 컴퓨터가 이해하는 정보

![Image](https://github.com/user-attachments/assets/08515018-ddd2-47fc-bbdb-50d133ad6714)

- 컴퓨터는 프로그래밍 언어를 직접 이해하지 못함
- 소스 코드는 내부적으로 컴퓨터가 이해할 수 있는 **데이터**와 **명령어**의 형태로 변환되어 실행됨

### 데이터

- 정적인 정보를 의미:
  - 숫자, 문자, 이미지, 동영상
- 0과 1만으로 다양한 정보들을 표현함
- 명령의 대상이자, 명령어의 재료

### 명령어

- 데이터를 활용해 명령어를 실행함
- CPU: 명령어를 이해하고 실행하는 주체
- CPU의 종류에 따라서 명령어의 종류와 처리 양상이 달라짐
- 명령어 사이클: CPU가 명령어를 처리하는 순서

## 1.2 컴퓨터의 핵심 부품

![Image](https://github.com/user-attachments/assets/20077a54-958e-44bd-87d2-0d2ebf1f110b)

- CPU(중앙처리장치)
- 메모리(주기억장치)
- 캐시 메모리
- 보조기억장치
- 입출력장치

### CPU

- 데이터와 명령어를 읽고, 해석하고, 실행하는 부품

#### CPU의 주요 구성 요소

![Image](https://github.com/user-attachments/assets/848ddd7d-f71b-482a-b4c4-a56736e7acc0)

**산술논리연산장치(ALU, Arithmetic and Logic Unit)**

- 사칙 연산, 논리 연산과 같은 연산을 수행할 회로로 구성되어 있음(일종의 계산기)
- CPU가 처리할 명령어를 실질적으로 연산하는 요소

**제어장치(CU, Control Unit)**

- 명령어를 해석해 제어 신호(전기 신호)를 내보내는 장치
- 제어 신호: 부품을 작동시키기 위한 신호
- ex) CPU가 입출력장치를 향해 제어 신호를 보내면 입출력 장치를 작동시킬 수 있음

**레지스터(register)**

- CPU 내부의 작은 임시 저장장치
- 데이터와 명령어를 처리하는 과정에서의 값을 저장함
- 여러 개의 레지스터가 존재하며, 각기 다른 이름과 역할을 가짐
- 가장 중요한 구성 요소, CPU가 처리하는 명령어는 반드시 레지스터에 저장되기 때문에 레지스터 값만 잘 관찰해도 프로그램이 어떻게 실행되는지 가장 낮은 단계에서 파악할 수 있음

### 메모리(주기억장치)

- 메모리: RAM, ROM
- 일반적으로 메모리는 RAM을 지칭함
- CPU가 읽고, 해석하고, 실행하는 모든 정보를 저장하는 장치
- 현재 **실행 중인 프로그램을 구성하는 데이터와 명령어를 저장하는 부품**
- 프로그램이 실행되려면 프로그램을 이루는 데이터와 명령어가 메모리에 저장되어있어야 함

**주소**

![Image](https://github.com/user-attachments/assets/bb930b1e-b6d1-4b8c-853c-023e4270d7fa)

- CPU가 원하는 정보로 접근하기 위해서 필요함

**휘발성**

- 전원이 공급되지 않을 때 저장하고 있는 정보가 지워지는 특성
- 메모리는 휘발성 저장장치로, 메모리에 저장된 정보는 컴퓨터의 전원이 꺼지면 모두 삭제됨

### 캐시 메모리

![Image](https://github.com/user-attachments/assets/eb81aef8-0a6e-40ec-b82e-ecab1d8b1d0a)

- CPU가 조금이라도 더 빠르게 메모리에 저장된 값에 접근하기 위해 사용됨
- 빠른 메모리 접근을 위한 보조 저장 장치
- CPU 안에 위치하기도 하고, CPU 밖에 위치하기도 함

### 보조 기억 장치

![Image](https://github.com/user-attachments/assets/6d265ccd-0e60-417a-b368-2ede52846e3a)

- 휘발성 저장장치인 메모리를 보조하기 위한 장치
- 전원이 꺼져도 저장된 정보가 사라지지 않는 **비휘발성** 저장장치
- CD-ROM, DVD, 하드 디스크 드라이브, 플래시 메모리(SSD, USB 메모리), 플로피 디스크 등이 있음
- 자주 사용되는 보조기억장치: 하드 디스크 드라이브, 플래시 메모리 기반 SSD

![Image](https://github.com/user-attachments/assets/84e4f88b-8bc2-4dac-b0df-09eeed350dea)

- 보관할 프로그램을 저장
- 프로그램을 실행하려면 보조기억장치에서 보관하고 있는 프로그램을 메모리로 복사해야함
- RAID: 안전하고 안정적으로 보조기억장치를 구성하는 기술

### 입출력장치

- 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치
- 입력장치: 컴퓨터에 어떠한 입력을 할 때 사용하는 장치
  - ex) 마우스, 키보드, 마이크
- 출력장치: 컴퓨터의 정보를 받기 위해 사용하는 장치
  - ex) 스피커, 모니터, 프린터
- 보조기억장치와 입출력장치는 완전 배타적 개념이 아님
  - 보조기억장치는 메모리를 보조하는 임무를 수행하는 특별한 입출력장치
  - 보조기억장치와 입출력장치를 주변장치라고 통칭하기도 함

### 메인 보드와 버스

![Image](https://github.com/user-attachments/assets/385cd7a2-58f5-4a79-9b2e-f7f8897dec08)

#### 메인 보드(마더 보드)

- 컴퓨터 핵심 부품들을 고정하고 연결하는 기판
- 부품들을 연결할 수 있는 슬롯과 연결 단자들로 구성됨

#### 버스

- 메인 보드에 연결된 부품들은 각자의 역할을 수행하기 위해 서로 정보를 주고 받음
- 버스: 부품들이 정보를 주고받는 통로
- **시스템 버스**: 핵심 부품들을 연결함

### 저장 장치의 계층 구조

- 레지스터, 메모리, 캐시 메모리, 보조기억장치의 특성:

  1. CPU와 가까운 저장장치는 빠르고, 멀리 있는 저장장치는 느림
  2. 속도가 빠른 저장장치는 용량이 작고, 가격이 비쌈

- CPU와 가까운 순서:

  레지스터 -> 캐시 메모리 -> 메모리 -> 보조기억장치

- 저장장치 계층 구조: 저장장치들은 CPU와의 거리, 용량과 성능을 기준으로 계층적 구조를 가짐

  ![Image](https://github.com/user-attachments/assets/54650580-c860-48fe-a61b-755f3e306343)

## 1.3 컴퓨터 구조 지도 그리기

![Image](https://github.com/user-attachments/assets/89b3b4b3-d306-4b2d-94fa-63c27e762c48)

# 2. 컴퓨터가 이해하는 정보

**목표**

- 0과 1만 이해하는 컴퓨터가 어떻게 문자와 숫자를 인식하나?
- 정적인 데이터가 명령어에 의해 어떻게 실행되나?

---

**비트**

- 가장 작은 정보의 단위(0과 1)
- N비트는 2^N개의 정보 표현 가능
- 단위(프로그램 크기 단위)
  - 1 byte: 8비트
  - 1KB: 1000바이트
  - 1MB: 1000KB
  - 1GB: 1000MB
  - 1TB: 1000GB

**워드**

- CPU가 한 번에 처리할 수 있는 데이터의 크기
- CPU는 프로그램을 워드 단위로 읽고 처리함
- CPU가 한 번에 처리할 수 있는 비트 수
  - ex) CPU가 한 번에 16비트 처리가능하면 1워드는 16비트
- 워드의 크기는 CPU마다 다르지만, 보통 32비트 또는 64비트

## 2.1 데이터 - 0과 1로 숫자 표현하기

### 2진법

- 2진수로 표현된 수는 숫자 뒤에 아래첨자로 (2)를 붙이거나 2진수 앞에 0b를 붙임

### 16진법

- 2진법은 숫자의 길이가 너무 길어진다는 단점이 있음
  - ex) 10진수 128을 2진수로 표현하면 10000000(2)
- 따라서 2진수와 더불어 16진수를 함께 사용함
- 16진법 체계에서는 10진수 10, 11, 12, 13, 14, 15를 각각 A, B, C, D, E, F로 표기함
- 16진수로 표현된 수는 뒤에 아래첨자로 (16)을 붙이거나 16진수 앞에 0x를 붙임
- 활용 예시:
  - MAC 주소: A1:C2:E3:A5:C6:E7
  - IPv6 주소: 2001:0a1b:1234:0000:0000:abcd:1234:ff02

### 2진수로 소수 나타내기

- 표현하고자 하는 소수와 저장되는 소수 간에 오차가 존재함
- 0.1 + 0.2 !== 0.3
- 오차가 발생하는 이유: 컴퓨터가 부동소수점을 저장하는 방식

**부동소수점**

- 소수점이 고정되어 있지 않은 소수 표현 방식, 필요에 따라 소수점의 위치가 이동할 수 있음
  - ex) 10진수 123.123 이라는 수를 m*10^n 으로 나타내면 1.23123 * 10^2, 1231.23 \* 10^(-1) 로 표현 가능
- 2진수 체계에서는 소수를 m \* 2^n의 꼴로 나타냄
  - ex) 10진수 107.6640623를 2진수로 나타내면 1101011.1010101임. 1.1010111010101 \* 2^6, 11010110.10101 \* 2(-2) 로 표현 가능
- 가수 \* 기수^(지수)
  - ex) 11010110,10101(가수), 2(기수), -2(지수)

**컴퓨터가 부동소수점을 저장하는 방식**

![Image](https://github.com/user-attachments/assets/079c79d9-c2b9-4e4d-b485-8ae48654b69a)

- 컴퓨터 내부에서 소수점을 나타내기 위해 사용하는 방식이며 정밀도에 한계가 있음
- 컴퓨터는 2진수의 지수와 가수를 위와 같이 저장함. 이와 같은 부동소수점 방식을 IEEE 754라고 함
- 가수의 정수부에는 1로 통일된 정규화한 수가 저장됨(1.XXX 형태)
- 2^지수 \* 1.XXX 형태가 고정되므로, 소수를 저장할 때는 지수와 XXX에 해당하는 소수 부분만 저장함
  - ex) 1.1010111010101 \* 2^6 -> 지수:6, 가수: 1010111010101
- 컴퓨터가 지수를 저장할 때는 바이어스(bias) 값이 더해져서 저장됨. 이때 바이어스 값은 2^(k-1)-1 (k는 지수의 비트 수)
  - 지수를 표현하기 위해 8비트가 사용됐으면 바이어스 값은 2^7 - 1 인 127
  - 따라서 1.1010111010101 \* 2^6이 32비트로 저장될 때는 127 + 6인 133(2진수 10000101)이 지수에 저장됨
- 10진수 소수를 2진수로 표현할 때, 10진수 소수와 2진수 소수의 표현이 딱 맞아떨어지지 않음
  - ex) 1/3을 10진수로 표현하면 0.3333 무한 소수
- 컴퓨터의 저장공간은 한정적이기 때문에 무한히 많은 소수점을 저장할 수 없어서 일부 생략해서 저장함 -> 오차 발생

## 2.2 데이터 - 0과 1로 문자 표현하기

**문자 집합**

- 컴퓨터가 이해할 수 있는 문자들의 집합

### 문자 인코딩

- 문자를 컴퓨터가 이해하는 0과 1로 이루어진 문자 코드로 변환하는 과정
- 동일한 문자 집합이더라도 다양한 문자 인코딩 방법이 있음

### 문자 디코딩

- 0과 1로 표현된 문자를 사람이 이해하는 문자로 변환하는 과정
- 웹사이트가 문자의 인코딩 또는 디코딩 방법을 지원하지 않으면 글자가 깨짐

### 아스키

- 초창기 컴퓨터에서 사용하던 문자 집합 중 하나
- 영어의 알파벳, 아리바아 숫자, 일부 특수 문자 포함
- 하나의 아스키 문자 표현하기 위해 8비트 사용, 8비트 중 1비트는 오류 검출을 위한 패리티 비트이므로 사실상 문자 표현을 위해 사용되는 비트는 7비트 -> 총 2^7인 128개의 문자 표현 가능

**아스키 코드표**

![Image](https://github.com/user-attachments/assets/4f745dcc-545a-4071-9d01-14f0bbfc9a1e)

**아스키 코드**

- 아스키 문자들은 0부터 127까지의 숫자 중 하나의 고유한 수에 대응되는데, 이를 아스키 코드라고 함
- 아스키 코드의 인코딩: 문자 'A'를 10진수 65로 인코딩
- 아스키 코드의 디코딩: 10진수 65를 문자 'A'로 디코딩
- 한글을 표기할 수 없음 -> 한글도 지원하는 EUC-KR 등장

### EUC-KR

![Image](https://github.com/user-attachments/assets/e58cf973-e7a8-4726-afdd-5b5daae405a7)

- KS X 1001, KS X 1003 이라는 문자 집합 기반의 인코딩 방식
- 아스키 문자를 표현할 때는 1바이트 크기의 코드를 부여함
- 한글 글자를 표현할 때는 2바이트 크기의 코드를 부여함
- 총 2,350 개의 한글 단어를 표현하므로 모든 한글 조합을 표현할 수는 없음 -> 유니코드 문자 집합 등장

### 유니코드

![Image](https://github.com/user-attachments/assets/d0c3917f-16b6-4ab2-bae3-dc3bd616c215)

- 훨씬 많은 언어, 특수문자, 화살표, 이모티콘까지 코드로 표현할 수 있는 통일된 문자 집합
- 대부분의 언어를 지원하기 때문에 국가별로 다른 문자 집합과 인코딩 방식을 사용할 필요가 없어짐
- 따라서 현대 가장 많이 사용되는 표준 문자 집합
- 아스키 코드나 EUC-KR은 글자에 부여된 값을 그대로 인코딩 값으로 삼았지만 유니코드는 다양한 방법으로 인코딩함 (UTF-8, UTF-16, UTF-32)
- UTF-8, UTF-16, UTF-32는 가변 길이 인코딩 방식으로, 인코딩된 결과의 길이가 일정하지 않음

### base64 인코딩

![Image](https://github.com/user-attachments/assets/5d64aba8-54b9-46ae-80da-0694e49d5365)

- 문자뿐만 아니라, 이진 데이터까지 변환할 수 있는 인코딩 방식
- 단순 문자 이외의 이미지 데이터까지 모두 아스키 문자 형태로 표현 가능
- 64진수 하나를 표현하기 위해 6비트가 필요함
- 변환할 데이터를 6비트씩 나눠서 하나의 문자로 변환함
- 예를 들어 'abc' 문자열 -> 아스키 코드 97, 98, 99로 인코딩 -> 8비트 크기의 2진수인 01100001, 01100010, 01100011 로 표현 -> base64에 따라 6비트씩 끊어 변환하여 'YWJj'가 됨
  ![Image](https://github.com/user-attachments/assets/c9645e9f-99bb-4d93-9634-29a09f89c0f4)

## 2.3 명령어

- 명령어는 수행할 동작과 수행할 대상으로 이루어짐
- 하나의 명령어는 연산 코드와 0개 이상의 오퍼랜드로 구성됨
- 연산 코드 필드: 연산 코드가 담기는 영역
- 오퍼랜드 필드: 오퍼랜드가 담기는 영역

**수행할 대상**

- 수행할 동작에 사용될 데이터 자체(ex. 10)
- 데이터가 저장된 위치(ex. 메모리 128번지)

**연산 코드: 연산자**

- 명령어가 수행할 동작
- 대부분의 CPU가 공통적으로 이해하는 연산 코드: 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어

![Image](https://github.com/user-attachments/assets/a328b041-50a9-4a81-b13d-2b9d8d1767be)
![Image](https://github.com/user-attachments/assets/59dbff4e-4143-4ae6-984f-2a2f993a3075)

**오퍼랜드: 피연산자**

- 데이터값 또는 데이터가 저장된 위치(주소)
- 보통 데이터가 직접 명시되기 보다는 위치(메모리 주소 또는 레지스터 이름)가 명시됨 -> 주소 필드라고도 부름

### 기계어와 어셈블리어

![Image](https://github.com/user-attachments/assets/e398338a-ac57-4282-a460-34bceaf1f89a)

**기계어**

- 0과 1로 표현된 언어

**어셈블리어**

- 0과 1로 표현된 기계어를 읽기 쉽게 나타낸 언어
- 어셈블리어를 보면 CPU가 이해할 수 있는 명령어의 종류와 동작 파악 가능

### 명령어 사이클

![Image](https://github.com/user-attachments/assets/d2545bad-30c0-439b-9d75-f5dcc287a702)

- CPU가 명령어를 처리하는 과정에서 반복되어 실행되는 것
- 인출 사이클: 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- 실행 사이클: CPU로 가져온 명령어를 실행하는 단계
- 간접 사이클: 명령어 실행을 위해 메모리에 접근하는 단계
  - 오퍼랜드 필드에 메모리 주소가 명시된 경우, 한 번 더 메모리에 접근해야 함
  - ex) 빼라, 메모리 32번지 안의 값과, 메모리 33번지 안의 값을
- 인터럽트 사이클: 다음 절에서 학습

# 3. CPU

- 컴퓨터에서 가장 중요한 부품 중 하나

## 레지스터

- CPU 안에 있는 작은 임시 저장장치
- 각기 다른 이름과 역할이 있음
- 프로그램을 이루는 데이터와 명령어가 프로그램의 실행 전후로 레지스터에 저장됨
- 레지스터에 저장된 값만 잘 관찰해도 낮은 수준의 프로그램 작동 방식 파악 가능
- 레지스터 디버깅 도구: WinDbg(윈도우 운영체제), gdb(리눅스, 맥OS 운영체제)
- 아래 나오는 것은 대부분의 CPU가 공통적으로 포함하고 있는 대표적인 주요 레지스터

### 1. 프로그램 카운터(Program Counter)

- 메모리에서 다음으로 읽어 들일 명령어의 주소를 저장
- 어떤 CPU는 명령어 포인터(Instruction Pointer) 라고도 부름
- 일반적으로 1씩 증가하기 때문에 메모리에 저장된 프로그램이 순차적 으로 실행됨
  ![Image](https://github.com/user-attachments/assets/f78f7e09-6e0d-49ec-8100-e8787e1d0fd0)
- 조건문이나 리턴문을 만나면 프로그램이 순차적으로 실행되지 않게 되므로, PC값이 임의의 위치로 변경됨
  ![Image](https://github.com/user-attachments/assets/a07d3643-9737-4ce2-a8c6-6914a05936a5)

### 2. 명령어 레지스터

- 메모리에서 방금 읽어 들인 명령어를 저장하는 레지스터
- CPU 내의 제어장치는 명령어 레지스터 속 명령어를 해석한 뒤
  - ALU(산술논리연산장치)가 연산하도록 시키거나
  - 다른 부품에 제어 신호를 보내 작동시킴

### 3. 범용 레지스터

- 다양하고 일반적인 상황에서 자유롭게 사용 가능한 레지스터
- 데이터, 명령어, 주소 모두 저장 가능
- 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있음

### 4. 플래그 레지스터

- 플래그: 연산의 결과 혹은 CPU 상태에 대한 부가 정보(비트)
- 플래그값을 저장하는 레지스터
- ex) CPU가 연산을 수행한 직후
  - 플래그 레지스터의 부호 플래그가 1이 되었다면 연산의 결과가 음수임
  - 제로 플래그가 1이면 연산의 결과가 0임

| 종류              | 설명                                                      | 사용 예시                                                                                                         |
| ----------------- | --------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| 부호 플래그       | 연산 결과의 부호                                          | 부호 플래그가 1일 경우의 연산 결과는 음수, 0일 경우의 연산 결과는 양수를 의미                                     |
| 제로 플래그       | 연산 결과가 0인지의 여부                                  | 제로 플래그가 1일 경우의 연산 결과는 0, 0일 경우의 연산 결과는 0이 아님을 의미                                    |
| 캐리 플래그       | 연산 결과에 올림수나 빌림수가 발생했는지의 여부           | 캐리 플래그가 1일 경우에는 연산 결과에 올림수나 빌림수가 발생했음을 의미하고, 0일 경우에는 발생하지 않았음을 의미 |
| 오버플로우 플래그 | 오버플로우가 발생했는지의 여부                            | 오버플로우 플래그가 1일 경우에는 오버플로우가 발생했음을 의미하고, 0일 경우에는 발생하지 않았음을 의미            |
| 인터럽트 플래그   | 인터럽트가 가능한지의 여부                                | 인터럽트 플래그가 1일 경우에는 인터럽트가 가능함을 의미하고, 0일 경우에는 인터럽트가 불가능함을 의미              |
| 슈퍼바이저 플래그 | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지의 여부 | 슈퍼바이저 플래그가 1일 경우에는 커널 모드로 실행 중임을 의미하고, 0일 경우에는 사용자 모드로 실행 중임을 의미    |

### 5. 스택 포인터

- 메모리 내의, 실행 중인 각 프로그램들은 스택 형태의 주소 공간을 하나 이상 가지고 있음
- 스택 포인터: 메모리 내 스택 영역의 최상단 스택 데이터(마지막으로 스택에 저장된 데이터) 위치를 가리키는 특별한 레지스터
- 스택 포인터가 가리키는 곳의 데이터를 꺼내면 스택 포인터는 그 다음 데이터를 가리키게 됨
  ![Image](https://github.com/user-attachments/assets/d000ac86-af1c-4268-b0e0-211ab4756e5a)

## 인터럽트

- '방해하다', '중단시키다'의 의미
- CPU의 작업을 방해하는 신호

### 동기 인터럽트

- CPU에 의해 발생하는 인터럽트
- CPU가 프로그래밍 오류와 같은 예외적인(예상치 못한) 상황을 마주쳤을 때 발생
- 동기 인터럽트를 '예외' 라고도 부름
- 종류: 폴트 ,트랩, 중단, 소프트웨어 인터럽트 등
- CPU는 예외가 발생하면 하던 일 을 중단하고 예외를 처리한 후 다시 본래 하던 작업 실행을 재개
- CPU가 본래 하던 작업으로 돌아왔을 때 **예외가 발생한 명령어**부터 실행하느냐, **예외가 발생한 명령어의 다음 명령어**부터 실행하느냐에 따라 폴트와 트랩으로 나뉨

#### 폴트

- 예외를 처리한 직후 **예외가 발생한 명령어부터** 실행을 재개하는 예외
- 프로그램 실행에 필요한 데이터가 메모리에 없을 경우 CPU는 폴트를 발생시키고, 보조기억장치로부터 메모리를 가지고온 후 다시 실행을 재개함
- 즉, **폴트가 발생한 그 명령어부터** 실행해나감

#### 트랩

- 예외를 처리한 직후 **예외가 발생한 명령어의 다음 명령어부터** 실행을 재개하는 예외
- 예시: 디버깅의 브레이크 포인트
  - 브레이크 포인트를 만나 프로그램이 중단된 후, 디버깅이 끝나면(트랩을 처리하고 나면) 트랩이 발생한 그 다음 명령어부터 실행해 나감

#### 중단

- CPU가 실행 중인 **프로그램을 강제로 중단**시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외

#### 소프트웨어 인터럽트

- 시스템 콜이 발생했을 때 발생하는 예외(3장 학습 예정)

### 비동기 인터럽트

- 입출력장치에 의해 발생하는 인터럽트
- '알림'의 역할을 함
  - CPU가 프린터와 같은 입출력장치에게 입출력 작업을 부탁하면면, 작업을 끝낸 입출력장치가 CPU에게 완료 알림(인터럽트)을 보냄
  - 키보드, 마우스 같은 입출력장치가 어떤 입력을 받아들였을 때, 이를 처리하기 위해 CPU에게 입력 알림(인터럽트)을 보냄
- CPU는 효율적으로 명령어를 처리하기 위해 비동기 인터럽트(하드웨어 인터럽트) 사용
  - CPU는 프린트 작업이 끝나기를 기다리지 않고 다른 작업 처리

#### CPU가 하드웨어 인터럽트를 처리하는 순서

1. 입출력장치가 CPU에게 **인터럽트 요청 신호** 보냄
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부 확인
3. CPU는 인터럽트 요청을 확인하고, **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
4. 인터럽트를 받아들일 수 있다면 CPU가 지금까지의 작업을 백업
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
6. 인터럽트 서비스 루틴 실행이이 끝나면 '4'에서 백업해 둔 작업을 복구하여 실행 재개

#### 인터럽트 요청 신호

- 인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기 때문에 인터럽트하기 전에 CPU에게 인터럽트의 가능 여부 확인이 필요. 이를 위한 신호를 인터럽트 요청 신호라고 함

#### 인터럽트 플래그

- CPU가 인터럽트 요청을 수용하기 위해서 활성화되어 있어야하는 플래그 레지스터
- 만약 인터럽트 플래그가 불가능으로 설정돼있으면 CPU는 인터럽트 요청 무시

#### 막을 수 있는 인터럽트와 막을 수 없는 인터럽트

![Image](https://github.com/user-attachments/assets/fc54ce88-8dad-4262-b714-0b0145eddacc)

- 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아님
- 정전이나 하드웨어 고장으로 인한 인터럽트는 못막음

#### 인터럽트 서비스 루틴

![Image](https://github.com/user-attachments/assets/9b45a725-8105-49a3-bb4e-78b5219ac074)

- CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 인터럽트 서비스 루틴이라는 프로그램 실행하고 본래 수행하던 작업으로 되돌아옴
- 인터럽트를 처리하기 위한 프로그램, 인터럽트 핸들러라고도 부름
- 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램

#### 인터럽트 벡터

- CPU는 인터럽트 벡터를 이용해 각기 다른 인터럽트 서비스 루틴들을 구분
- CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 버스를 통해 인터럽트 벡터를 전달받음
- 인터럽트 벡터가 인터럽트 서비스 루틴의 시작 주소를 포함하고 있기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 실행할 수 있음
- ex) CPU가 작업을 수행하는 도중에 프린터 인터럽트 발생 -> CPU는 전달받은 인터럽트 벡터 참조해서 프린터 인터럽트 서비스 루틴 시작 주소를 알아내고 실행
  ![Image](https://github.com/user-attachments/assets/6f5d866f-51ba-4063-8ea4-d74eb39f3caa)

> 버스를 통해 어떻게 인터럽트 벡터를 전달받을까

#### 명령어 사이클 최종모습

![Image](https://github.com/user-attachments/assets/1a859e8a-be15-4e48-890e-c9440fe888fc)

## CPU 성능 향상을 위한 설계

- CPU는 복잡하고 중요 개념들이 담겨있음
- 더 빠른 CPU를 위해 클럭, 코어, 스레드 등 CPU 성능 향상을 위한 기법들이 도입됨

### CPU 클럭 속도

<img width="410" alt="Image" src="https://github.com/user-attachments/assets/56a2d904-304f-4449-985b-95da4e6376ce" />

- 클럭: 컴퓨터의 부품을 일사분란하게 움직일 수 있게 하는 시간의 단위
- 클럭 주기에 맞춰 레지스터에서 다른 레지스터로 데이터가 이동, ALU에서 연산이 수행, 메모리에 저장된 명령어를 읽어들임
- 클럭 속도: 헤르츠(Hz) 단위, 클럭이 1촣에 몇 번 반복되는지 나타냄
- 최근에는 CPU 클럭 속도가 매우 빨라져서 기가헤르츠(GHz) 단위로 측정하는 것이 일반적임
- 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복하기 때문에 클럭 속도가 높은 CPU는 성능이 좋음 -> **클럭 속도는 CPU의 속도로 간주되기도 함**
- 클럭 속도를 필요 이상으로 높이면 컴퓨터 발열이 심해지기 때문에 클럭 속도를 높이는 것만으로 CPU의 성능을 높이는 데에는 한계가 있음

### 멀티코어와 멀티스레드

- 클럭 속도를 높이는 방법 외에도 코어 수나 스레드 수를 늘리는 방법으로 CPU의 성능을 높일 수 있음
- 코어: CPU 내에서 명령어를 읽고/해석하고/실행하는 부품, 여러 개 존재할 수 있음
  <img width="566" alt="Image" src="https://github.com/user-attachments/assets/aae05ec6-5641-4ce7-b8d4-4b93efb45467" />
- 멀티코어 CPU(멀티코어 프로세서): 여러 개의 코어를 포함하고 있는 CPU
- CPU 안에 몇 개의 코어가 있는지에 따라 멀티코어 CPU의 명칭이 바뀜
  | 코어 개수 | 명칭 |
  |---------|------|
  | 1 | 싱글코어(single-core) |
  | 2 | 듀얼코어(dual-core) |
  | 3 | 트리플코어(triple-core) |
  | 4 | 쿼드코어(quad-core) |
  | 6 | 헥사코어(hexa-core) |
  | 8 | 옥타코어(octa-core) |
  | 10 | 데카코어(deca-core) |
  | 12 | 도데카코어(dodeca-core) |

### 스레드

- 스레드의 사전적 의미: 실행 흐름의 단위
- 종류: CPU에서 사용하는 하드웨어적인 스레드(하드웨어 스레드) 운영체제에서 사용하는 소프트웨어적인 스레드(스레드)

#### 하드웨어 스레드

- 하드웨어 스레드: 하나의 코어가 동시에 처리하는 명령어의 단위
- 멀티스레드 프로세서(멀티스레드 CPU): 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- 예시

  - 명령어 읽기/해석/실행 하는 부품 하나가 한 번에 하나의 명령어를 처리하면 -> 1코어 1스레드 CPU
  - 명령어 읽기/해석/실행 하는 부품 2개가 한 번에 4개의 명령어를 처리하면 -> 2코어 4스레드 CPU
    <img width="517" alt="Image" src="https://github.com/user-attachments/assets/8357bf15-4d28-43f3-8906-2c5fed4efe97" />

- 논리 프로세서: 어쨋든 메모리 속 프로그램의 입장에서 보면 스레드는 한 번에 하나의 명령어를 처리하는 1개의 CPU로 보이므로 논리 프로세서 라고 부르기도 함
  - ex) 2코어 4스레드 CPU를 메모리 속 프로그램의 입장에서 보면 '한 번에 하나의 명령어를 처리하는 4개의 CPU'로 보임

#### 소프트웨어 스레드

- 소프트웨어 스레드: 하나의 프로그램에서 독립적으로 실행되는 단위
- 어떤 프로그램이 여러 (소프트웨어) 스레드를 통해 실행될 수 있다는 말의 뜻 -> 메모리에 적재된 해당 프로그램을 구성하는 여러 부분이 동시에 실행될 수 있다는 뜻
- 하드웨어 스레드가 하나인 CPU로도 여러개의 소프트웨어 스레드를 만들 수 있음

> 그럼 결과적으로 둘이 다른점이 뭐지?? 하드웨어 스레드가 1코어 1스레드라고 가정했을 때, 소프트웨어 스레드가 하나이면 어딘가 block되면 다른 것 실행 안되는 것이고... 소프트웨어 스레드가 3개이면 테스크 1이 block됐어도 2,3이 스위칭 되면서 실행될 수 있는 그런건가??? 그럼 하드웨어 스레드가 2코어 4스레드이고, 소프트웨어 스레드가 하나인 상태에서 뭔가 block 됐을 시 다른 것이 실행이 안되는 건 똑같지만 block 처리가 병렬적으로 처리되기 때문에 빨라지나?

#### 병렬성

- 작업을 물리적으로 동시에 처리하는 성질
- 하드웨어 스레드가 4개인 CPU가 4개의 명령어를 동시에 실행하는 경우 같은 시점에 여러 작업을 동시에 처리할 수 있음
- 하드웨어 스레드는 '병렬성'을 구현하기 위한 물리적인 실행 단위에 가까움

#### 동시성

- 동시에 작업을 처리하는 것처럼 보이는 성질
- CPU가 빠르게 작업을 번갈아 가며 처리할 경우, 사용자의 눈에는 마치 여러 작업이 동시에 처리되는 것처럼 보임
- 소프트웨어 스레드는 '동시성'을 구현하기 위한 논리적인 실행 단위에 가까움

<img width="437" alt="Image" src="https://github.com/user-attachments/assets/f1191418-0eab-4906-aab7-8ce048c5e1db" />

## 파이프라이닝을 통한 명령어 병렬 처리

### 명령어 병렬 처리 기법

- 여러 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시킴으로써 CPU의 성능을 높이는 기법
- 현대 CPU의 명령어 처리에서의 핵심 기술
- 다양한 종류가 있지만 **명령어 파이프라이닝** 중요함

#### 명령어 파이프라이닝

<img width="396" alt="Image" src="https://github.com/user-attachments/assets/af9bb87c-1e4e-4251-9367-1d6e1638c18a" />

- 명령어 파이프라이닝: 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법
- 명령어 인출, 명령어 해석, 명령어 실행, 결과 저장의 과정에서 단계가 겹치지만 않으면 CPU가 **각각의 단계를 동시에 실행**할 수 있음
- CPU는 하나의 명령어가 인출되는 동안 다른 명령어를 실행할 수 있고, 하나의 명령어가 실행되는 동안 연산의 결과를 저장할 수 있음
- 슈퍼스칼라 프로세서(슈퍼스칼라 CPU): CPU 내부에 여러 명령어 파이프라인을 포함하는 구조
  <img width="401" alt="Image" src="https://github.com/user-attachments/assets/eac81613-7d2d-4cae-94fa-a86ed6fdcf30" />

> 왜 단계가 겹치면 안되지? -> 아 같은 CPU 부품에 접근하면 안돼서 그렇구나

#### CPU 종류 (feat. 파이프라이닝 성능 차이)

- 병렬 처리에 유리한 명령어 집합이 있고, 불리한 명령어 집합이 있음
- 파이프라이닝 성능의 차이를 보이는 대표적인 명령어 집합 유형으로 **CISC**와 **RISC**가 있음

  - CISC 기반 CPU: 인텔 x86, 인텔 x86-64
  - RISC 기반 CPU: 애플 M1 CPU

<img width="435" alt="Image" src="https://github.com/user-attachments/assets/0a7c195f-0dfd-4f51-bd90-a313bce34f23" />

**CISC**

- 다채로운 기능을 지원하는 복잡한 명령어들로 구성된 명령어 집합
- 적은 수의 명령어로도 프로그램 실행 가능
- 명령어가 복잡하고 다양한 기능을 제공하기 때문에 명령어 크기 및 실행되기 까지의 시간이 일정하지 않고, 하나의 명령어 실행에 여러 클럭 주기가 필요함 -> 명령어 수행 시간이 길고 들쑥날쑥해서 파이프라이닝에 비효율적

**RISC**

- CISC에 비해 활용 가능한 명령어 종류가 적음
- CISC와 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향함
- 같은 프로그램이더라도 RISC에는 CISC보다 많은 명령어가 필요함
- 명령어 크기가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 파이프라이닝에 최적화돼있음

#### 파이프라이닝이 CPU 성능 향상에 실패하는 경우

- 파이프라인 위험: 파이프라이닝이 실패하여 성능 향상이 이뤄지지 않는 상황
- 파이프라인 위험의 종류: 데이터 위험, 제어 위험, 구조적 위험

**데이터 위험**

- 명령어 간의 데이터 의존성에 의해 발생
- 이전 명령어를 끝까지 실행해야만 실행 가능

```
명렁어1: R1 <- R2 + R3
명령어2: R4 <- R1 + R5
```

**제어 위험**

- 프로그램 카운터의 갑작스러운 변화에 의해 발생
- JUMP, CONDITIONAL JUMP, 인터럽트 등으로 프로그램 실행 흐름이 바뀌어 프로그램 카운터 값이 변하면 미리 인출하거나 해석 중인 명령어들은 아무 쓸모가 없어짐

> 엥 프로그램 카운터는 단순히 현재 실행중인 명령어의 다음 주소로 갱신된다라고 알고있는데, 미리 값을 인출하고 해석한다구? 무슨 소리지?

**구조적 위험(자원 위험)**

- 서로 다른 명령어가 동시에 ALU, 레지스터 등 같은 CPU 부품을 사용하려고 할 때 발생

> 코어가 2개면 2개의 명령어에서 같은 CPU 부품에 동시에 접근 가능한가? 아닌가?
