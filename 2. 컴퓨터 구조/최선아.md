# 1. 컴퓨터 구조의 큰 그림

![Image](https://github.com/user-attachments/assets/d3fcd297-a1af-4dd1-897b-f00b74229609)

**목표**

- 컴퓨터가 이해하는 정보 (예를 들어 0과 1)
- 프로그램을 실행하는 하드웨어

---

## 1.1 컴퓨터가 이해하는 정보

![Image](https://github.com/user-attachments/assets/08515018-ddd2-47fc-bbdb-50d133ad6714)

- 컴퓨터는 프로그래밍 언어를 직접 이해하지 못함
- 소스 코드는 내부적으로 컴퓨터가 이해할 수 있는 **데이터**와 **명령어**의 형태로 변환되어 실행됨

### 데이터

- 정적인 정보를 의미:
  - 숫자, 문자, 이미지, 동영상
- 0과 1만으로 다양한 정보들을 표현함
- 명령의 대상이자, 명령어의 재료

### 명령어

- 데이터를 활용해 명령어를 실행함
- CPU: 명령어를 이해하고 실행하는 주체
- CPU의 종류에 따라서 명령어의 종류와 처리 양상이 달라짐
- 명령어 사이클: CPU가 명령어를 처리하는 순서

## 1.2 컴퓨터의 핵심 부품

![Image](https://github.com/user-attachments/assets/20077a54-958e-44bd-87d2-0d2ebf1f110b)

- CPU(중앙처리장치)
- 메모리(주기억장치)
- 캐시 메모리
- 보조기억장치
- 입출력장치

### CPU

- 데이터와 명령어를 읽고, 해석하고, 실행하는 부품

#### CPU의 주요 구성 요소

![Image](https://github.com/user-attachments/assets/848ddd7d-f71b-482a-b4c4-a56736e7acc0)

**산술논리연산장치(ALU, Arithmetic and Logic Unit)**

- 사칙 연산, 논리 연산과 같은 연산을 수행할 회로로 구성되어 있음(일종의 계산기)
- CPU가 처리할 명령어를 실질적으로 연산하는 요소

**제어장치(CU, Control Unit)**

- 명령어를 해석해 제어 신호(전기 신호)를 내보내는 장치
- 제어 신호: 부품을 작동시키기 위한 신호
- ex) CPU가 입출력장치를 향해 제어 신호를 보내면 입출력 장치를 작동시킬 수 있음

**레지스터(register)**

- CPU 내부의 작은 임시 저장장치
- 데이터와 명령어를 처리하는 과정에서의 값을 저장함
- 여러 개의 레지스터가 존재하며, 각기 다른 이름과 역할을 가짐
- 가장 중요한 구성 요소, CPU가 처리하는 명령어는 반드시 레지스터에 저장되기 때문에 레지스터 값만 잘 관찰해도 프로그램이 어떻게 실행되는지 가장 낮은 단계에서 파악할 수 있음

### 메모리(주기억장치)

- 메모리: RAM, ROM
- 일반적으로 메모리는 RAM을 지칭함
- CPU가 읽고, 해석하고, 실행하는 모든 정보를 저장하는 장치
- 현재 **실행 중인 프로그램을 구성하는 데이터와 명령어를 저장하는 부품**
- 프로그램이 실행되려면 프로그램을 이루는 데이터와 명령어가 메모리에 저장되어있어야 함

**주소**

![Image](https://github.com/user-attachments/assets/bb930b1e-b6d1-4b8c-853c-023e4270d7fa)

- CPU가 원하는 정보로 접근하기 위해서 필요함

**휘발성**

- 전원이 공급되지 않을 때 저장하고 있는 정보가 지워지는 특성
- 메모리는 휘발성 저장장치로, 메모리에 저장된 정보는 컴퓨터의 전원이 꺼지면 모두 삭제됨

### 캐시 메모리

![Image](https://github.com/user-attachments/assets/eb81aef8-0a6e-40ec-b82e-ecab1d8b1d0a)

- CPU가 조금이라도 더 빠르게 메모리에 저장된 값에 접근하기 위해 사용됨
- 빠른 메모리 접근을 위한 보조 저장 장치
- CPU 안에 위치하기도 하고, CPU 밖에 위치하기도 함

### 보조 기억 장치

![Image](https://github.com/user-attachments/assets/6d265ccd-0e60-417a-b368-2ede52846e3a)

- 휘발성 저장장치인 메모리를 보조하기 위한 장치
- 전원이 꺼져도 저장된 정보가 사라지지 않는 **비휘발성** 저장장치
- CD-ROM, DVD, 하드 디스크 드라이브, 플래시 메모리(SSD, USB 메모리), 플로피 디스크 등이 있음
- 자주 사용되는 보조기억장치: 하드 디스크 드라이브, 플래시 메모리 기반 SSD

![Image](https://github.com/user-attachments/assets/84e4f88b-8bc2-4dac-b0df-09eeed350dea)

- 보관할 프로그램을 저장
- 프로그램을 실행하려면 보조기억장치에서 보관하고 있는 프로그램을 메모리로 복사해야함
- RAID: 안전하고 안정적으로 보조기억장치를 구성하는 기술

### 입출력장치

- 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치
- 입력장치: 컴퓨터에 어떠한 입력을 할 때 사용하는 장치
  - ex) 마우스, 키보드, 마이크
- 출력장치: 컴퓨터의 정보를 받기 위해 사용하는 장치
  - ex) 스피커, 모니터, 프린터
- 보조기억장치와 입출력장치는 완전 배타적 개념이 아님
  - 보조기억장치는 메모리를 보조하는 임무를 수행하는 특별한 입출력장치
  - 보조기억장치와 입출력장치를 주변장치라고 통칭하기도 함

### 메인 보드와 버스

![Image](https://github.com/user-attachments/assets/385cd7a2-58f5-4a79-9b2e-f7f8897dec08)

#### 메인 보드(마더 보드)

- 컴퓨터 핵심 부품들을 고정하고 연결하는 기판
- 부품들을 연결할 수 있는 슬롯과 연결 단자들로 구성됨

#### 버스

- 메인 보드에 연결된 부품들은 각자의 역할을 수행하기 위해 서로 정보를 주고 받음
- 버스: 부품들이 정보를 주고받는 통로
- **시스템 버스**: 핵심 부품들을 연결함

### 저장 장치의 계층 구조

- 레지스터, 메모리, 캐시 메모리, 보조기억장치의 특성:

  1. CPU와 가까운 저장장치는 빠르고, 멀리 있는 저장장치는 느림
  2. 속도가 빠른 저장장치는 용량이 작고, 가격이 비쌈

- CPU와 가까운 순서:

  레지스터 -> 캐시 메모리 -> 메모리 -> 보조기억장치

- 저장장치 계층 구조: 저장장치들은 CPU와의 거리, 용량과 성능을 기준으로 계층적 구조를 가짐

  ![Image](https://github.com/user-attachments/assets/54650580-c860-48fe-a61b-755f3e306343)

## 1.3 컴퓨터 구조 지도 그리기

![Image](https://github.com/user-attachments/assets/89b3b4b3-d306-4b2d-94fa-63c27e762c48)

# 2. 컴퓨터가 이해하는 정보

**목표**

- 0과 1만 이해하는 컴퓨터가 어떻게 문자와 숫자를 인식하나?
- 정적인 데이터가 명령어에 의해 어떻게 실행되나?

---

**비트**

- 가장 작은 정보의 단위(0과 1)
- N비트는 2^N개의 정보 표현 가능
- 단위(프로그램 크기 단위)
  - 1 byte: 8비트
  - 1KB: 1000바이트
  - 1MB: 1000KB
  - 1GB: 1000MB
  - 1TB: 1000GB

**워드**

- CPU가 한 번에 처리할 수 있는 데이터의 크기
- CPU는 프로그램을 워드 단위로 읽고 처리함
- CPU가 한 번에 처리할 수 있는 비트 수
  - ex) CPU가 한 번에 16비트 처리가능하면 1워드는 16비트
- 워드의 크기는 CPU마다 다르지만, 보통 32비트 또는 64비트

## 2.1 데이터 - 0과 1로 숫자 표현하기

### 2진법

- 2진수로 표현된 수는 숫자 뒤에 아래첨자로 (2)를 붙이거나 2진수 앞에 0b를 붙임

### 16진법

- 2진법은 숫자의 길이가 너무 길어진다는 단점이 있음
  - ex) 10진수 128을 2진수로 표현하면 10000000(2)
- 따라서 2진수와 더불어 16진수를 함께 사용함
- 16진법 체계에서는 10진수 10, 11, 12, 13, 14, 15를 각각 A, B, C, D, E, F로 표기함
- 16진수로 표현된 수는 뒤에 아래첨자로 (16)을 붙이거나 16진수 앞에 0x를 붙임
- 활용 예시:
  - MAC 주소: A1:C2:E3:A5:C6:E7
  - IPv6 주소: 2001:0a1b:1234:0000:0000:abcd:1234:ff02

### 2진수로 소수 나타내기

- 표현하고자 하는 소수와 저장되는 소수 간에 오차가 존재함
- 0.1 + 0.2 !== 0.3
- 오차가 발생하는 이유: 컴퓨터가 부동소수점을 저장하는 방식

**부동소수점**

- 소수점이 고정되어 있지 않은 소수 표현 방식, 필요에 따라 소수점의 위치가 이동할 수 있음
  - ex) 10진수 123.123 이라는 수를 m*10^n 으로 나타내면 1.23123 * 10^2, 1231.23 \* 10^(-1) 로 표현 가능
- 2진수 체계에서는 소수를 m \* 2^n의 꼴로 나타냄
  - ex) 10진수 107.6640623를 2진수로 나타내면 1101011.1010101임. 1.1010111010101 \* 2^6, 11010110.10101 \* 2(-2) 로 표현 가능
- 가수 \* 기수^(지수)
  - ex) 11010110,10101(가수), 2(기수), -2(지수)

**컴퓨터가 부동소수점을 저장하는 방식**

![Image](https://github.com/user-attachments/assets/079c79d9-c2b9-4e4d-b485-8ae48654b69a)

- 컴퓨터 내부에서 소수점을 나타내기 위해 사용하는 방식이며 정밀도에 한계가 있음
- 컴퓨터는 2진수의 지수와 가수를 위와 같이 저장함. 이와 같은 부동소수점 방식을 IEEE 754라고 함
- 가수의 정수부에는 1로 통일된 정규화한 수가 저장됨(1.XXX 형태)
- 2^지수 \* 1.XXX 형태가 고정되므로, 소수를 저장할 때는 지수와 XXX에 해당하는 소수 부분만 저장함
  - ex) 1.1010111010101 \* 2^6 -> 지수:6, 가수: 1010111010101
- 컴퓨터가 지수를 저장할 때는 바이어스(bias) 값이 더해져서 저장됨. 이때 바이어스 값은 2^(k-1)-1 (k는 지수의 비트 수)
  - 지수를 표현하기 위해 8비트가 사용됐으면 바이어스 값은 2^7 - 1 인 127
  - 따라서 1.1010111010101 \* 2^6이 32비트로 저장될 때는 127 + 6인 133(2진수 10000101)이 지수에 저장됨
- 10진수 소수를 2진수로 표현할 때, 10진수 소수와 2진수 소수의 표현이 딱 맞아떨어지지 않음
  - ex) 1/3을 10진수로 표현하면 0.3333 무한 소수
- 컴퓨터의 저장공간은 한정적이기 때문에 무한히 많은 소수점을 저장할 수 없어서 일부 생략해서 저장함 -> 오차 발생

## 2.2 데이터 - 0과 1로 문자 표현하기

**문자 집합**

- 컴퓨터가 이해할 수 있는 문자들의 집합

### 문자 인코딩

- 문자를 컴퓨터가 이해하는 0과 1로 이루어진 문자 코드로 변환하는 과정
- 동일한 문자 집합이더라도 다양한 문자 인코딩 방법이 있음

### 문자 디코딩

- 0과 1로 표현된 문자를 사람이 이해하는 문자로 변환하는 과정
- 웹사이트가 문자의 인코딩 또는 디코딩 방법을 지원하지 않으면 글자가 깨짐

### 아스키

- 초창기 컴퓨터에서 사용하던 문자 집합 중 하나
- 영어의 알파벳, 아리바아 숫자, 일부 특수 문자 포함
- 하나의 아스키 문자 표현하기 위해 8비트 사용, 8비트 중 1비트는 오류 검출을 위한 패리티 비트이므로 사실상 문자 표현을 위해 사용되는 비트는 7비트 -> 총 2^7인 128개의 문자 표현 가능

**아스키 코드표**

![Image](https://github.com/user-attachments/assets/4f745dcc-545a-4071-9d01-14f0bbfc9a1e)

**아스키 코드**

- 아스키 문자들은 0부터 127까지의 숫자 중 하나의 고유한 수에 대응되는데, 이를 아스키 코드라고 함
- 아스키 코드의 인코딩: 문자 'A'를 10진수 65로 인코딩
- 아스키 코드의 디코딩: 10진수 65를 문자 'A'로 디코딩
- 한글을 표기할 수 없음 -> 한글도 지원하는 EUC-KR 등장

### EUC-KR

![Image](https://github.com/user-attachments/assets/e58cf973-e7a8-4726-afdd-5b5daae405a7)

- KS X 1001, KS X 1003 이라는 문자 집합 기반의 인코딩 방식
- 아스키 문자를 표현할 때는 1바이트 크기의 코드를 부여함
- 한글 글자를 표현할 때는 2바이트 크기의 코드를 부여함
- 총 2,350 개의 한글 단어를 표현하므로 모든 한글 조합을 표현할 수는 없음 -> 유니코드 문자 집합 등장

### 유니코드

![Image](https://github.com/user-attachments/assets/d0c3917f-16b6-4ab2-bae3-dc3bd616c215)

- 훨씬 많은 언어, 특수문자, 화살표, 이모티콘까지 코드로 표현할 수 있는 통일된 문자 집합
- 대부분의 언어를 지원하기 때문에 국가별로 다른 문자 집합과 인코딩 방식을 사용할 필요가 없어짐
- 따라서 현대 가장 많이 사용되는 표준 문자 집합
- 아스키 코드나 EUC-KR은 글자에 부여된 값을 그대로 인코딩 값으로 삼았지만 유니코드는 다양한 방법으로 인코딩함 (UTF-8, UTF-16, UTF-32)
- UTF-8, UTF-16, UTF-32는 가변 길이 인코딩 방식으로, 인코딩된 결과의 길이가 일정하지 않음

### base64 인코딩

![Image](https://github.com/user-attachments/assets/5d64aba8-54b9-46ae-80da-0694e49d5365)

- 문자뿐만 아니라, 이진 데이터까지 변환할 수 있는 인코딩 방식
- 단순 문자 이외의 이미지 데이터까지 모두 아스키 문자 형태로 표현 가능
- 64진수 하나를 표현하기 위해 6비트가 필요함
- 변환할 데이터를 6비트씩 나눠서 하나의 문자로 변환함
- 예를 들어 'abc' 문자열 -> 아스키 코드 97, 98, 99로 인코딩 -> 8비트 크기의 2진수인 01100001, 01100010, 01100011 로 표현 -> base64에 따라 6비트씩 끊어 변환하여 'YWJj'가 됨
  ![Image](https://github.com/user-attachments/assets/c9645e9f-99bb-4d93-9634-29a09f89c0f4)

## 2.3 명령어

- 명령어는 수행할 동작과 수행할 대상으로 이루어짐
- 하나의 명령어는 연산 코드와 0개 이상의 오퍼랜드로 구성됨
- 연산 코드 필드: 연산 코드가 담기는 영역
- 오퍼랜드 필드: 오퍼랜드가 담기는 영역

**수행할 대상**

- 수행할 동작에 사용될 데이터 자체(ex. 10)
- 데이터가 저장된 위치(ex. 메모리 128번지)

**연산 코드: 연산자**

- 명령어가 수행할 동작
- 대부분의 CPU가 공통적으로 이해하는 연산 코드: 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어

![Image](https://github.com/user-attachments/assets/a328b041-50a9-4a81-b13d-2b9d8d1767be)
![Image](https://github.com/user-attachments/assets/59dbff4e-4143-4ae6-984f-2a2f993a3075)

**오퍼랜드: 피연산자**

- 데이터값 또는 데이터가 저장된 위치(주소)
- 보통 데이터가 직접 명시되기 보다는 위치(메모리 주소 또는 레지스터 이름)가 명시됨 -> 주소 필드라고도 부름

### 기계어와 어셈블리어

![Image](https://github.com/user-attachments/assets/e398338a-ac57-4282-a460-34bceaf1f89a)

**기계어**

- 0과 1로 표현된 언어

**어셈블리어**

- 0과 1로 표현된 기계어를 읽기 쉽게 나타낸 언어
- 어셈블리어를 보면 CPU가 이해할 수 있는 명령어의 종류와 동작 파악 가능

### 명령어 사이클

![Image](https://github.com/user-attachments/assets/d2545bad-30c0-439b-9d75-f5dcc287a702)

- CPU가 명령어를 처리하는 과정에서 반복되어 실행되는 것
- 인출 사이클: 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- 실행 사이클: CPU로 가져온 명령어를 실행하는 단계
- 간접 사이클: 명령어 실행을 위해 메모리에 접근하는 단계
  - 오퍼랜드 필드에 메모리 주소가 명시된 경우, 한 번 더 메모리에 접근해야 함
  - ex) 빼라, 메모리 32번지 안의 값과, 메모리 33번지 안의 값을
- 인터럽트 사이클: 다음 절에서 학습

# 3. CPU

- 컴퓨터에서 가장 중요한 부품 중 하나

## 레지스터

- CPU 안에 있는 작은 임시 저장장치
- 각기 다른 이름과 역할이 있음
- 프로그램을 이루는 데이터와 명령어가 프로그램의 실행 전후로 레지스터에 저장됨
- 레지스터에 저장된 값만 잘 관찰해도 낮은 수준의 프로그램 작동 방식 파악 가능
- 레지스터 디버깅 도구: WinDbg(윈도우 운영체제), gdb(리눅스, 맥OS 운영체제)
- 아래 나오는 것은 대부분의 CPU가 공통적으로 포함하고 있는 대표적인 주요 레지스터

### 1. 프로그램 카운터(Program Counter)

- 메모리에서 다음으로 읽어 들일 명령어의 주소를 저장
- 어떤 CPU는 명령어 포인터(Instruction Pointer) 라고도 부름
- 일반적으로 1씩 증가하기 때문에 메모리에 저장된 프로그램이 순차적 으로 실행됨
  ![Image](https://github.com/user-attachments/assets/f78f7e09-6e0d-49ec-8100-e8787e1d0fd0)
- 조건문이나 리턴문을 만나면 프로그램이 순차적으로 실행되지 않게 되므로, PC값이 임의의 위치로 변경됨
  ![Image](https://github.com/user-attachments/assets/a07d3643-9737-4ce2-a8c6-6914a05936a5)

### 2. 명령어 레지스터

- 메모리에서 방금 읽어 들인 명령어를 저장하는 레지스터
- CPU 내의 제어장치는 명령어 레지스터 속 명령어를 해석한 뒤
  - ALU(산술논리연산장치)가 연산하도록 시키거나
  - 다른 부품에 제어 신호를 보내 작동시킴

### 3. 범용 레지스터

- 다양하고 일반적인 상황에서 자유롭게 사용 가능한 레지스터
- 데이터, 명령어, 주소 모두 저장 가능
- 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있음

### 4. 플래그 레지스터

- 플래그: 연산의 결과 혹은 CPU 상태에 대한 부가 정보(비트)
- 플래그값을 저장하는 레지스터
- ex) CPU가 연산을 수행한 직후
  - 플래그 레지스터의 부호 플래그가 1이 되었다면 연산의 결과가 음수임
  - 제로 플래그가 1이면 연산의 결과가 0임

| 종류              | 설명                                                      | 사용 예시                                                                                                         |
| ----------------- | --------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| 부호 플래그       | 연산 결과의 부호                                          | 부호 플래그가 1일 경우의 연산 결과는 음수, 0일 경우의 연산 결과는 양수를 의미                                     |
| 제로 플래그       | 연산 결과가 0인지의 여부                                  | 제로 플래그가 1일 경우의 연산 결과는 0, 0일 경우의 연산 결과는 0이 아님을 의미                                    |
| 캐리 플래그       | 연산 결과에 올림수나 빌림수가 발생했는지의 여부           | 캐리 플래그가 1일 경우에는 연산 결과에 올림수나 빌림수가 발생했음을 의미하고, 0일 경우에는 발생하지 않았음을 의미 |
| 오버플로우 플래그 | 오버플로우가 발생했는지의 여부                            | 오버플로우 플래그가 1일 경우에는 오버플로우가 발생했음을 의미하고, 0일 경우에는 발생하지 않았음을 의미            |
| 인터럽트 플래그   | 인터럽트가 가능한지의 여부                                | 인터럽트 플래그가 1일 경우에는 인터럽트가 가능함을 의미하고, 0일 경우에는 인터럽트가 불가능함을 의미              |
| 슈퍼바이저 플래그 | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지의 여부 | 슈퍼바이저 플래그가 1일 경우에는 커널 모드로 실행 중임을 의미하고, 0일 경우에는 사용자 모드로 실행 중임을 의미    |

### 5. 스택 포인터

- 메모리 내의, 실행 중인 각 프로그램들은 스택 형태의 주소 공간을 하나 이상 가지고 있음
- 스택 포인터: 메모리 내 스택 영역의 최상단 스택 데이터(마지막으로 스택에 저장된 데이터) 위치를 가리키는 특별한 레지스터
- 스택 포인터가 가리키는 곳의 데이터를 꺼내면 스택 포인터는 그 다음 데이터를 가리키게 됨
  ![Image](https://github.com/user-attachments/assets/d000ac86-af1c-4268-b0e0-211ab4756e5a)

## 인터럽트

- '방해하다', '중단시키다'의 의미
- CPU의 작업을 방해하는 신호

### 동기 인터럽트

- CPU에 의해 발생하는 인터럽트
- CPU가 프로그래밍 오류와 같은 예외적인(예상치 못한) 상황을 마주쳤을 때 발생
- 동기 인터럽트를 '예외' 라고도 부름
- 종류: 폴트 ,트랩, 중단, 소프트웨어 인터럽트 등
- CPU는 예외가 발생하면 하던 일 을 중단하고 예외를 처리한 후 다시 본래 하던 작업 실행을 재개
- CPU가 본래 하던 작업으로 돌아왔을 때 **예외가 발생한 명령어**부터 실행하느냐, **예외가 발생한 명령어의 다음 명령어**부터 실행하느냐에 따라 폴트와 트랩으로 나뉨

#### 폴트

- 예외를 처리한 직후 **예외가 발생한 명령어부터** 실행을 재개하는 예외
- 프로그램 실행에 필요한 데이터가 메모리에 없을 경우 CPU는 폴트를 발생시키고, 보조기억장치로부터 메모리를 가지고온 후 다시 실행을 재개함
- 즉, **폴트가 발생한 그 명령어부터** 실행해나감

#### 트랩

- 예외를 처리한 직후 **예외가 발생한 명령어의 다음 명령어부터** 실행을 재개하는 예외
- 예시: 디버깅의 브레이크 포인트
  - 브레이크 포인트를 만나 프로그램이 중단된 후, 디버깅이 끝나면(트랩을 처리하고 나면) 트랩이 발생한 그 다음 명령어부터 실행해 나감

#### 중단

- CPU가 실행 중인 **프로그램을 강제로 중단**시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외

#### 소프트웨어 인터럽트

- 시스템 콜이 발생했을 때 발생하는 예외(3장 학습 예정)

### 비동기 인터럽트

- 입출력장치에 의해 발생하는 인터럽트
- '알림'의 역할을 함
  - CPU가 프린터와 같은 입출력장치에게 입출력 작업을 부탁하면면, 작업을 끝낸 입출력장치가 CPU에게 완료 알림(인터럽트)을 보냄
  - 키보드, 마우스 같은 입출력장치가 어떤 입력을 받아들였을 때, 이를 처리하기 위해 CPU에게 입력 알림(인터럽트)을 보냄
- CPU는 효율적으로 명령어를 처리하기 위해 비동기 인터럽트(하드웨어 인터럽트) 사용
  - CPU는 프린트 작업이 끝나기를 기다리지 않고 다른 작업 처리

#### CPU가 하드웨어 인터럽트를 처리하는 순서

1. 입출력장치가 CPU에게 **인터럽트 요청 신호** 보냄
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부 확인
3. CPU는 인터럽트 요청을 확인하고, **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
4. 인터럽트를 받아들일 수 있다면 CPU가 지금까지의 작업을 백업
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
6. 인터럽트 서비스 루틴 실행이이 끝나면 '4'에서 백업해 둔 작업을 복구하여 실행 재개

#### 인터럽트 요청 신호

- 인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기 때문에 인터럽트하기 전에 CPU에게 인터럽트의 가능 여부 확인이 필요. 이를 위한 신호를 인터럽트 요청 신호라고 함

#### 인터럽트 플래그

- CPU가 인터럽트 요청을 수용하기 위해서 활성화되어 있어야하는 플래그 레지스터
- 만약 인터럽트 플래그가 불가능으로 설정돼있으면 CPU는 인터럽트 요청 무시

#### 막을 수 있는 인터럽트와 막을 수 없는 인터럽트

![Image](https://github.com/user-attachments/assets/fc54ce88-8dad-4262-b714-0b0145eddacc)

- 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아님
- 정전이나 하드웨어 고장으로 인한 인터럽트는 못막음

#### 인터럽트 서비스 루틴

![Image](https://github.com/user-attachments/assets/9b45a725-8105-49a3-bb4e-78b5219ac074)

- CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 인터럽트 서비스 루틴이라는 프로그램 실행하고 본래 수행하던 작업으로 되돌아옴
- 인터럽트를 처리하기 위한 프로그램, 인터럽트 핸들러라고도 부름
- 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램

#### 인터럽트 벡터

- CPU는 인터럽트 벡터를 이용해 각기 다른 인터럽트 서비스 루틴들을 구분
- CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 버스를 통해 인터럽트 벡터를 전달받음
- 인터럽트 벡터가 인터럽트 서비스 루틴의 시작 주소를 포함하고 있기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 실행할 수 있음
- ex) CPU가 작업을 수행하는 도중에 프린터 인터럽트 발생 -> CPU는 전달받은 인터럽트 벡터 참조해서 프린터 인터럽트 서비스 루틴 시작 주소를 알아내고 실행
  ![Image](https://github.com/user-attachments/assets/6f5d866f-51ba-4063-8ea4-d74eb39f3caa)

> 버스를 통해 어떻게 인터럽트 벡터를 전달받을까

#### 명령어 사이클 최종모습

![Image](https://github.com/user-attachments/assets/1a859e8a-be15-4e48-890e-c9440fe888fc)

## CPU 성능 향상을 위한 설계

- CPU는 복잡하고 중요 개념들이 담겨있음
- 더 빠른 CPU를 위해 클럭, 코어, 스레드 등 CPU 성능 향상을 위한 기법들이 도입됨

### CPU 클럭 속도

<img width="410" alt="Image" src="https://github.com/user-attachments/assets/56a2d904-304f-4449-985b-95da4e6376ce" />

- 클럭: 컴퓨터의 부품을 일사분란하게 움직일 수 있게 하는 시간의 단위
- 클럭 주기에 맞춰 레지스터에서 다른 레지스터로 데이터가 이동, ALU에서 연산이 수행, 메모리에 저장된 명령어를 읽어들임
- 클럭 속도: 헤르츠(Hz) 단위, 클럭이 1촣에 몇 번 반복되는지 나타냄
- 최근에는 CPU 클럭 속도가 매우 빨라져서 기가헤르츠(GHz) 단위로 측정하는 것이 일반적임
- 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복하기 때문에 클럭 속도가 높은 CPU는 성능이 좋음 -> **클럭 속도는 CPU의 속도로 간주되기도 함**
- 클럭 속도를 필요 이상으로 높이면 컴퓨터 발열이 심해지기 때문에 클럭 속도를 높이는 것만으로 CPU의 성능을 높이는 데에는 한계가 있음

### 멀티코어와 멀티스레드

- 클럭 속도를 높이는 방법 외에도 코어 수나 스레드 수를 늘리는 방법으로 CPU의 성능을 높일 수 있음
- 코어: CPU 내에서 명령어를 읽고/해석하고/실행하는 부품, 여러 개 존재할 수 있음
  <img width="566" alt="Image" src="https://github.com/user-attachments/assets/aae05ec6-5641-4ce7-b8d4-4b93efb45467" />
- 멀티코어 CPU(멀티코어 프로세서): 여러 개의 코어를 포함하고 있는 CPU
- CPU 안에 몇 개의 코어가 있는지에 따라 멀티코어 CPU의 명칭이 바뀜
  | 코어 개수 | 명칭 |
  |---------|------|
  | 1 | 싱글코어(single-core) |
  | 2 | 듀얼코어(dual-core) |
  | 3 | 트리플코어(triple-core) |
  | 4 | 쿼드코어(quad-core) |
  | 6 | 헥사코어(hexa-core) |
  | 8 | 옥타코어(octa-core) |
  | 10 | 데카코어(deca-core) |
  | 12 | 도데카코어(dodeca-core) |

### 스레드

- 스레드의 사전적 의미: 실행 흐름의 단위
- 종류: CPU에서 사용하는 하드웨어적인 스레드(하드웨어 스레드) 운영체제에서 사용하는 소프트웨어적인 스레드(스레드)

#### 하드웨어 스레드

- 하드웨어 스레드: 하나의 코어가 동시에 처리하는 명령어의 단위
- 멀티스레드 프로세서(멀티스레드 CPU): 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- 예시

  - 명령어 읽기/해석/실행 하는 부품 하나가 한 번에 하나의 명령어를 처리하면 -> 1코어 1스레드 CPU
  - 명령어 읽기/해석/실행 하는 부품 2개가 한 번에 4개의 명령어를 처리하면 -> 2코어 4스레드 CPU
    <img width="517" alt="Image" src="https://github.com/user-attachments/assets/8357bf15-4d28-43f3-8906-2c5fed4efe97" />

- 논리 프로세서: 어쨋든 메모리 속 프로그램의 입장에서 보면 스레드는 한 번에 하나의 명령어를 처리하는 1개의 CPU로 보이므로 논리 프로세서 라고 부르기도 함
  - ex) 2코어 4스레드 CPU를 메모리 속 프로그램의 입장에서 보면 '한 번에 하나의 명령어를 처리하는 4개의 CPU'로 보임

#### 소프트웨어 스레드

- 소프트웨어 스레드: 하나의 프로그램에서 독립적으로 실행되는 단위
- 어떤 프로그램이 여러 (소프트웨어) 스레드를 통해 실행될 수 있다는 말의 뜻 -> 메모리에 적재된 해당 프로그램을 구성하는 여러 부분이 동시에 실행될 수 있다는 뜻
- 하드웨어 스레드가 하나인 CPU로도 여러개의 소프트웨어 스레드를 만들 수 있음

> 그럼 결과적으로 둘이 다른점이 뭐지?? 하드웨어 스레드가 1코어 1스레드라고 가정했을 때, 소프트웨어 스레드가 하나이면 어딘가 block되면 다른 것 실행 안되는 것이고... 소프트웨어 스레드가 3개이면 테스크 1이 block됐어도 2,3이 스위칭 되면서 실행될 수 있는 그런건가??? 그럼 하드웨어 스레드가 2코어 4스레드이고, 소프트웨어 스레드가 하나인 상태에서 뭔가 block 됐을 시 다른 것이 실행이 안되는 건 똑같지만 block 처리가 병렬적으로 처리되기 때문에 빨라지나?

#### 병렬성

- 작업을 물리적으로 동시에 처리하는 성질
- 하드웨어 스레드가 4개인 CPU가 4개의 명령어를 동시에 실행하는 경우 같은 시점에 여러 작업을 동시에 처리할 수 있음
- 하드웨어 스레드는 '병렬성'을 구현하기 위한 물리적인 실행 단위에 가까움

#### 동시성

- 동시에 작업을 처리하는 것처럼 보이는 성질
- CPU가 빠르게 작업을 번갈아 가며 처리할 경우, 사용자의 눈에는 마치 여러 작업이 동시에 처리되는 것처럼 보임
- 소프트웨어 스레드는 '동시성'을 구현하기 위한 논리적인 실행 단위에 가까움

<img width="437" alt="Image" src="https://github.com/user-attachments/assets/f1191418-0eab-4906-aab7-8ce048c5e1db" />

## 파이프라이닝을 통한 명령어 병렬 처리

### 명령어 병렬 처리 기법

- 여러 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시킴으로써 CPU의 성능을 높이는 기법
- 현대 CPU의 명령어 처리에서의 핵심 기술
- 다양한 종류가 있지만 **명령어 파이프라이닝** 중요함

#### 명령어 파이프라이닝

<img width="396" alt="Image" src="https://github.com/user-attachments/assets/af9bb87c-1e4e-4251-9367-1d6e1638c18a" />

- 명령어 파이프라이닝: 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법
- 명령어 인출, 명령어 해석, 명령어 실행, 결과 저장의 과정에서 단계가 겹치지만 않으면 CPU가 **각각의 단계를 동시에 실행**할 수 있음
- CPU는 하나의 명령어가 인출되는 동안 다른 명령어를 실행할 수 있고, 하나의 명령어가 실행되는 동안 연산의 결과를 저장할 수 있음
- 슈퍼스칼라 프로세서(슈퍼스칼라 CPU): CPU 내부에 여러 명령어 파이프라인을 포함하는 구조
  <img width="401" alt="Image" src="https://github.com/user-attachments/assets/eac81613-7d2d-4cae-94fa-a86ed6fdcf30" />

> 왜 단계가 겹치면 안되지? -> 아 같은 CPU 부품에 접근하면 안돼서 그렇구나

#### CPU 종류 (feat. 파이프라이닝 성능 차이)

- 병렬 처리에 유리한 명령어 집합이 있고, 불리한 명령어 집합이 있음
- 파이프라이닝 성능의 차이를 보이는 대표적인 명령어 집합 유형으로 **CISC**와 **RISC**가 있음

  - CISC 기반 CPU: 인텔 x86, 인텔 x86-64
  - RISC 기반 CPU: 애플 M1 CPU

<img width="435" alt="Image" src="https://github.com/user-attachments/assets/0a7c195f-0dfd-4f51-bd90-a313bce34f23" />

**CISC**

- 다채로운 기능을 지원하는 복잡한 명령어들로 구성된 명령어 집합
- 적은 수의 명령어로도 프로그램 실행 가능
- 명령어가 복잡하고 다양한 기능을 제공하기 때문에 명령어 크기 및 실행되기 까지의 시간이 일정하지 않고, 하나의 명령어 실행에 여러 클럭 주기가 필요함 -> 명령어 수행 시간이 길고 들쑥날쑥해서 파이프라이닝에 비효율적

**RISC**

- CISC에 비해 활용 가능한 명령어 종류가 적음
- CISC와 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향함
- 같은 프로그램이더라도 RISC에는 CISC보다 많은 명령어가 필요함
- 명령어 크기가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 파이프라이닝에 최적화돼있음

#### 파이프라이닝이 CPU 성능 향상에 실패하는 경우

- 파이프라인 위험: 파이프라이닝이 실패하여 성능 향상이 이뤄지지 않는 상황
- 파이프라인 위험의 종류: 데이터 위험, 제어 위험, 구조적 위험

**데이터 위험**

- 명령어 간의 데이터 의존성에 의해 발생
- 이전 명령어를 끝까지 실행해야만 실행 가능

```
명렁어1: R1 <- R2 + R3
명령어2: R4 <- R1 + R5
```

**제어 위험**

- 프로그램 카운터의 갑작스러운 변화에 의해 발생
- JUMP, CONDITIONAL JUMP, 인터럽트 등으로 프로그램 실행 흐름이 바뀌어 프로그램 카운터 값이 변하면 미리 인출하거나 해석 중인 명령어들은 아무 쓸모가 없어짐

**구조적 위험(자원 위험)**

- 서로 다른 명령어가 동시에 ALU, 레지스터 등 같은 CPU 부품을 사용하려고 할 때 발생

# 4. 메모리

- 실행 중인 프로그램은 메모리에 저장됨
- CPU는 메모리에 저장된 정보를 읽고, 쓰고, 실행함
- 메모리의 하드웨어적 특징/종류, 2가지 주소 체계, 바이트 저장 순서에 대해 알아보자

## RAM(Random Access Memory)

- **휘발성 저장장치**: 전원을 끄면 저장하고 있던 데이터와 명령어가 날아감
- CPU가 실행할 대상을 저장함
- CPU는 보조기억장치에 저장된 프로그램을 실행하기 위해 메모리로 복사해야함
- RAM의 용량은 컴퓨터에 큰 영향 끼침:
  - RAM의 용량이 작으면 보조기억장치로부터 실행할 프로그램을 가지고 오는 일이 잦아져 실행 시간이 길어짐
  - RAM의 용량이 충분히 크면 보조기억장치로부터 많은 데이터를 가져와 미리 RAM에 저장할 수 있기 때문에 많은 프로그램을 동시에 실행하는데 유리
- **임의 접근(직접 접근)** 메모리: 저장된 요소에 순차적으로 접근할 필요 없이 임의의 위치에 곧장 접근 가능

  - 100번지 데이터에 접근하기 위해 1번지 -> 2번지 ... -> 100번지로 접근할 필요 없이 곧장 100번지로 접근 가능
  - 순차 접근과 반대 개념

- RAM의 종류: DRAM, SRAM, SDRAM, DDR SDRAM 등

### RAM의 종류

#### 1. DRAM(Dynamic RAM)

- 시간이 지나면 저장된 데이터가 점차 사라지는 RAM
- 단점: 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화(다시 저장)해야 함
- 장점: 소비 전력 낮음, 저렴, 집적도 높음 -> 대용량 메모리 설계 용이
- 단점에도 불구하고 장점으로 인해 DRAM을 메모리로 사용하는 것이 일반적

#### 2. SRAM(Static RAM)

- 시간이 지나도 저장된 데이터가 사라지지 않는 RAM
- 장점: DRAM보다 속도가 빠름
- 단점: 소비 전력이 큼, 가격이 비쌈, 집적도 낮음
- 캐시 메모리 등과 같이 대용량이 아닌, 속도가 빨라야 하는 저장장치에서 사용됨

#### 3. SDRAM(Synchronous Dynamic RAM)

- 클럭 신호와 동기화된, 보다 발전된 형태의 DRAM
- 클럭 신호와 동기화: 클럭 타이밍에 맞춰 CPU와 정보를 주고받을 수 있음
- 즉, 클럭에 맞춰 작동하며 CPU와 정보를 주고받을 수 있는 DRAM
- SDR SDRAM(Single Data Rate SDRAM)라고도 부름: 한 클럭 당 하나씩 데이터를 주고받음

> 그럼 DRAM은 어떤 주기에 맞춰 CPU와 정보를 주고받지?

#### 4. DDR SDRAM(Double Data Rate SDRAM)

**DDR SDRAM**

- 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
- 대역폭: 데이터를 주고받을 길의 너비
- SDRAM이 한 클럭당 한 번씩 CPU와 데이터를 주고받을 수 있다면, DDR SDRAM은 두 배의 대역폭으로, 한 클럭당 두 번씩 CPU와 데이터를 주고받을 수 있음
- SDRAM보다 전송 속도가 두 배 가량 빠름

**DDR2 SDRAM**

- DDR SDRAM보다 대역폭이 두 배 넓은 SDRAM

**DDR3 SDRAM**

- 대역폭이 DDR2 SDRAM보다 두 배 넓은 SDRAM

**DDR4 SDRAM**

- 대역폭이 DDR3 SDRAM보다 두 배 넓은 SDRAM
- 즉, SDRAM보다 16배 넓은 대역폭을 가진 SDRAM
- 최근에 흔히 볼 수 있는 메모리

## 메모리에 바이트를 밀어 넣는 순서 - 빅 엔디안과 리틀 레디안

- 현대 메모리는 대부분 데이터를 **바이트** 단위로 저장하고 관리함
- 메모리는 CPU로부터 바이트 단위가 아닌, 워드 단위로 받아들여짐
  - 일반적으로 4바이트(32비트), 혹은 8바이트(64비트)
- 여러 바이트로 구성된 데이터는 여러 주소에 걸쳐 저장됨
  - ex) 16진수 1A2B3C4D는 1A, 2B, 3C, 4D로 나누어 4개의 주소에 저장됨
  - ex) 16진수 1A2B3C4D5A6B7C8D는 1A, 2B, 3C, 4D, 5A, 6B, 7C, 8D로 나누어 8개의 주소에 저장됨
  - 16진수는 4비트, 메모리는 바이트(8비트) 단위이기 때문에 2개씩 저장 가능

### 빅엔디안

![Image](https://github.com/user-attachments/assets/59432890-931e-442f-9919-8524a9c41d58)

- 낮은 번지의 주소에 상위 바이트부터 저장하는 방식
- MSB가 있는 바이트, 즉 중요하고 큰 데이터부터 저장해 나가는 방식
- 장점: 일상적으로 숫자를 읽고 쓰는 순서와 동일하기 때문에 메모리 값을 직접 읽거나, 디버깅 할 때 편함
  - 주소에 1A, 2D, 3C, 4D 순서로 있으면 그대로 1A2D3C4D로 읽으면 됨

> 단점은 뭘까?

### 리틀엔디안

![Image](https://github.com/user-attachments/assets/a2f70de6-8c2b-46ac-b1a2-9d63619ba3e3)

- 낮은 번지의 주소에 하위 바이트부터 저장하는 방식
- LSB가 있는 바이트, 즉 덜 중요하고 작은 데이터부터 저장해 나가는 방식
- 단점: 메모리 값을 직접 읽고 쓰기에는 불편함
- 장점: 수치 계산이 편리
  - ex) 123 + 456 더할 때 가장 작은 값부터 계산해나감

### MSB(Most Significant Bit)

- 숫자의 크기에 가장 큰 영향을 미치는 유효 숫자
- 쉽게 말해, 가장 왼쪽에 있는 비트

### LSB(Least Significant Bit)

- 숫자의 크기에 가장 적은 영향을 미치는 유효 숫자
- 쉽게 말해, 가장 오른쪽에 있는 비트

## 캐시 메모리

**캐시 메모리의 등장**

- CPU는 프로그램 실행 과정에서 빈번히 메모리에 접근해야함
- CPU가 메모리에 접근하는 속도는 CPU가 레지스터에 접근하는 속도보다 느리기 때문에 CPU의 연산 속도가 빨라도 메모리에 접근하는 속도가 느리면 효용이 없음 -> 캐시 메모리 등장

**캐시 메모리**

![Image](https://github.com/user-attachments/assets/f461c19a-5031-4a99-bcfe-fd69d1e770c1)

- CPU의 연산 속도와 메모리 접근 속도 차이를 줄이기 위한 저장장치
- CPU와 메모리 사이에 위치한 SRAM 기반의 저장장치
- CPU가 매번 메모리에 왔다 갔다 하는 시간이 오래 걸리므로 메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가져와 활용

![Image](https://github.com/user-attachments/assets/b015776f-3251-45b6-ae59-3580b45f323d)

- 컴퓨터 내부에는 여러 종류의 캐시 메모리 있음
- **L1 캐시**: 코어와 가장 가까운 캐시 메모리
- **L2 캐시**: 그 다음으로 가까운 캐시 메모리
- **L3 캐시**: 그 다음으로 가까운 캐시 메모리
- 일반적으로 L1 캐시와 L2 캐시는 코어 내부에, L3 캐시는 코어 외부에 위치함
- 캐시 메모리의 크기: L1 < L2 < L3
- 캐시 메모리의 속도: L3 < L2 < L1
- CPU가 메모리 내에 데이터가 필요할 때 데이터 검색: L1 캐시 -> L2 캐시 -> L3 캐시
- 멀티코어 프로세서의 경우 일반적으로 L1과 L2 캐시 메모리는 코어마다 고유한 캐시 메모리로 할당되고, L3 캐시는 여러 코어가 공유함
  ![Image](https://github.com/user-attachments/assets/eee47a09-8396-4e01-b3cf-aca957e72b4e)
- **분리형 캐시**: 코어와 가장 가까운 L1 캐시 메모리는 명령어만 저장하는 L1 캐시인 **L1I 캐시**와 데이터만 저장하는 **L1D 캐시**로 구분되기도 함
  ![Image](https://github.com/user-attachments/assets/f0ce92ac-a20b-49e5-a1b1-4726e1a416b5)

### 캐시 히트와 캐시 미스

![Image](https://github.com/user-attachments/assets/7da3d334-a50a-4a2c-9cbc-f2731b18d9cc)

- 캐시 메모리는 메모리보다 용량이 작기 때문에 메모리에 있는 모든 내용을 캐시 메모리에 가져와 저장할 수는 없음 -> 메모리의 일부를 복사하여 저장함
- 캐시 메모리에 뭘 저장해야할까? -> **CPU가 사용할 법한 것** 저장
- **캐시 히트**: 캐시 메모리가 예측하여 저장한 데이터가 CPU에 의해 실제로 사용되는 경우
- **캐시 미스**: 틀린 예측으로 인해 CPU가 메모리로부터 필요한 데이터를 직접 가져와야하는 경우
- 캐시 미스가 발생하면 캐시 메모리의 이점이 사라지고 캐시 히트에 비해 CPU 성능이 떨어지게 됨
- **캐시 적중률**: 캐시가 히트되는 비율
  ```
  캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
  ```

### 참조 지역성의 원리

- 캐시 메모리의 이점을 제대로 활용하려면 CPU가 사용할 법한 데이터를 제대로 예측해서 캐시 적중률을 높여야함
- 캐시 메모리는 **참조 지역성의 원리** 라는 특정한 원칙에 따라 메모리로부터 가져올 데이터를 결정함
- 참조 지역성의 원리: CPU가 메모리에 접근할 때 보이는 주된 경항으로 **시간 지역성**과 **공간 지역성** 이 있음

#### 시간 지역성

- CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있음
- ex) 변수: 일반적으로 변수에 저장된 값은 프로그램이 실행되는 동안 여러 번 사용됨

#### 공간 지역성

- CPU는 접근한 메모리 공간의 근처에 접근하려는 경향이 있음
- ex) 배열

**메모리에 순차적으로 접근**

```python
for i in range(4):
  for j in range(4)
    matrix[i][j] = 1
```

![Image](https://github.com/user-attachments/assets/bed01368-cc7b-459c-a8ca-b7ff79b0f165)

**메모리에 순차적으로 접근하지 않음**

```python
for i in range(4):
  for j in range(4)
    matrix[j][i] = 1
```

![Image](https://github.com/user-attachments/assets/32a625bb-208f-4347-9bdf-3fa1b0b86dc4)

- 공간 지역성이 실제 실행 속도에 영향을 줌

### 캐시 메모리의 쓰기 정책과 일관성

- 캐시 메모리에 데이터를 쓰는 경우에 대해 알아보자
- CPU가 캐시 메모리에 데이터를 쓸 때는 캐시 메모리에 새롭게 쓰여진 데이터와 메모리 상의 데이터가 일관성을 유지해야 함
- 현재 메모리 1000번지에 200이라는 값이 저장돼있고, 이 값이 캐시 메모리에도 저장돼있다고 가정하자
  - CPU가 이 값을 200에서 300으로 바꾸고싶다면 어떻게 해야할까?
  - 메모리 1000번지로 가서 300으로 바꾸기 되면, 메모리와 캐시 메모리의 데이터 일관성이 깨짐
    ![Image](https://github.com/user-attachments/assets/41eada27-45f2-44d2-9916-6860b6c29985)
- 캐시 메모리, 나아가 캐싱을 한다는 것은 데이터 접근에 있어 어느 정도 빠른 성능을 보장할 수 있지만, 데이터의 일관성을 유지하기 위한 책임이 따름

#### 메모리와 캐시 메모리의 일관성 유지하는 방법

**즉시 쓰기**

![Image](https://github.com/user-attachments/assets/e9eb6797-8d9f-43ee-a0f5-49c08fe783ac)

- 캐시 메모리와 메모리에 동시에 쓰는 방법
- 장점: 메모리를 항상 최신 상태로 유지해 캐시 메모리와 메모리 간의 일관성이 깨지는 상황 방지
- 단점: 데이터를 쓸 때마다 메모리를 참조해야 하므로 버스의 사용 시간과 쓰기 시간이 늘어남
- 메모리 접근을 최소화하기 위해 캐시 메모리를 만들었는데, 데이터를 쓸 때마다 메모리와 캐시 메모리에 동시 접근해야 한다면 캐시 메모리를 둔 효율이 떨어짐

> 버스의 사용 시간??? 갑자기 왜 나온거지?? cpu가 버스로 메모리와 연결돼있어서 그런가? 버스의 사용 시간이 늘어나는 건 왜 단점일까?

**지연 쓰기**

![Image](https://github.com/user-attachments/assets/5942d2e6-d8fb-4298-89d6-dec051a2e6cf)

- 캐시 메모리에만 값을 써 두었다가 추후 수정된 데이터를 한 번에 메모리에 반영하는 방법
- 장점: 메모리 접근 횟수를 줄일 수 있어 즉시 쓰기 방식에 비해 속도가 더 빠름
- 단점: 메모리와 캐시 메모리 간의 일관성이 깨질 위험이 있음

> 아니 깃허브 터져서 안돼요 사진 변환해야하느데 ㅜ

#### 다른 코어가 사용하는 캐시 메모리와의 불일치

![Image](https://github.com/user-attachments/assets/9fd72904-7a68-4a8c-88ff-9c3e71284ed3)

- 캐시 메모리와 메모리 간의 불일치만 해결해야 하는 것은 아님
- 다른 코어가 사용하는 캐시 메모리와의 불일치도 발생할 수 있음
- 해결을 위해 '캐시 일관성 프로토콜' 개념이 있음
